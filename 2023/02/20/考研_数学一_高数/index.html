

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/logo.png">
  <link rel="icon" href="/img/bg/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="杨再俨">
  <meta name="keywords" content="">
  
    <meta name="description" content="24考研数学一高数复习总结">
<meta property="og:type" content="article">
<meta property="og:title" content="考研_数学一_高数">
<meta property="og:url" content="https://gintoki-jpg.github.io/2023/02/20/%E8%80%83%E7%A0%94_%E6%95%B0%E5%AD%A6%E4%B8%80_%E9%AB%98%E6%95%B0/index.html">
<meta property="og:site_name" content="Tintoki_blog">
<meta property="og:description" content="24考研数学一高数复习总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gintoki-jpg.github.io/img/bg/study.jpg">
<meta property="article:published_time" content="2023-02-20T07:43:00.000Z">
<meta property="article:modified_time" content="2023-08-12T08:59:21.882Z">
<meta property="article:author" content="YangZaiyan">
<meta property="article:tag" content="高等数学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gintoki-jpg.github.io/img/bg/study.jpg">
  
  
  
  <title>考研_数学一_高数 - Tintoki_blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gintoki-jpg.github.io","root":"/","version":"1.9.1","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tintoki_blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">考研_数学一_高数</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-20 15:43" pubdate>
          2023年2月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          57k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          475 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">考研_数学一_高数</h1>
            
            <div class="markdown-body">
              
              <hr>
<blockquote>
<p>寒假开始第一轮复习（已完成）</p>
</blockquote>
<p>2023&#x2F;1&#x2F;15 16:42 暂且先集中精力速度把这三个课程的视频刷完，其他的之后再考虑；</p>
<p>2023&#x2F;1&#x2F;17 16:27 跟着B站的视频学了两天，基本上确定是选对教材和视频的，但是有一个老毛病就是总喜欢抠字眼（还是那种视频中与知识点无关的字眼，非常浪费时间，这点注意要改正）</p>
<p>2023&#x2F;1&#x2F;18 17:14 听课的时候有一句话，学高数应该去思考为什么而不仅仅只是会使用，这个观点个人认为在高一学习阶段的确如此，但是在应试以及考研复习阶段直接硬背即可，千万不要花费大量时间去琢磨某个知识点，性价比不高；</p>
<p>2023&#x2F;1&#x2F;21 15:58 今天听课的时候遇到一个问题，就是有一个已知的知识点，但是总是想去找到前面看过的视频中是否讲到过去验证，这种做法不可取！首先这个知识点既然已经懂了就不需要再费时间反复验证，并且寻找之前的讲解视频是一件非常麻烦的事情，总之不要顾此失彼，应当以节约时间为重点！</p>
<p>2023&#x2F;1&#x2F;24 11:34 宋浩的课程讲的很细致，但是有个问题就是太慢了，不是很适合快速复习，所以接下来准备找个快一点的课程跟着学；</p>
<p>2023&#x2F;1&#x2F;24 15:52 刚刚粗略的看了一下其他的课程，还是不太行，这里对宋浩的课程的听课行为做一个改进，就是除了概念性的知识以外例题以及题外话都快速的跳过，听宋浩的课程主要是为了建立系统性的概念，知道所有知识点之间的关系；</p>
<p>2023&#x2F;1&#x2F;25 16:34 关于宋浩讲话有一些听不清楚的字眼不要去反复抠，因为实际上这些不清楚的部分并不是重点不需要很在意；</p>
<p>2023&#x2F;1&#x2F;26 10:10 关于做题方法的总结，如果前面没有总结则直接不总结了，后面注意总结即可，前面未总结的部分做题的时候总结即可；</p>
<p>2023&#x2F;1&#x2F;27 17:11 刚刚偶然翻到了大一上学期的时候学习数学分析时候做的课堂笔记，整体看下来感受非常浓烈，也知道为什么大一上下学期学数学分析考的那么差，首先一点是做笔记的方式，可以说非常的杂乱没有条理（这点应该是受到当时同学的影响，盲目的效仿别人的学习方式而不是寻找适合自己的方式） – 当时做的笔记现在看来没有任何参考价值，这种笔记就是垃圾笔记，一个好的笔记应该是能够一目了然，关于例题的集合应该也是有不同的题型、不同的解法分门别类，而不是大杂烩将所有毫无关系的题型总结在一起 – 另外一个做笔记的问题就是重复整理，一个知识点在这个笔记本里面有在另一个笔记本里面也有，关键还不是什么重点知识，纯粹浪费时间浪费精力；接着是听课习惯，听课之前不预习不说，听课的过程中打瞌睡、只听废话不听重点，课后对于重点知识没有下功夫理解，反而花费大量时间在无用笔记的整理、各种偏难点的计较上，浪费大量时间的同时并没有收获相应的回报；最后一点我觉得很重要的就是没有建立自己的知识网络，并没有将学习的知识点之间的关系串联起来，导致做题的过程中脑袋是空白的几乎没什么概念 – 这点真的很重要，个人认为不管是学哪门科目（就算是编译原理这些直接背也能考高分的理工科科目，对于高等数学来说这就更重要了），应当是将知识点转化为自己能够理解的形式而不是强行靠自己的记忆力去背诵（这是很致命的，特别是对现在的你来说记忆力已经没有之前好了，并且理工科要记得东西不像文科那么简单，很容易就被背混淆，千万千万别死记硬背，这种高中的复习方式只会让你得到60分的擦线分，无论你再怎么努力也是如此，因为并没有将精力花在刀刃上） – 希望之前自己走过的坑以后不要再走，只有亲身体会过才知道付出了但没有收到等额的回报是多么痛苦的一件事；</p>
<p>2023&#x2F;1&#x2F;28 10:44 差不多十天时间刷完了高数上学期的知识点，接下来准备打算用一周的时间把高数下学期的知识点刷完；</p>
<p>2023&#x2F;2&#x2F;1 9:46 现在就加快速度刷视频，笔记整理什么的回到学校也可以；</p>
<p>2023&#x2F;2&#x2F;2 10:32 刚才又在一个知识点卡住了，关于前面知识点的总结留到最后找一个机会全部总结，然后再找考研教材进一步的巩固和解题方法的增加、修改等；</p>
<p>2023&#x2F;2&#x2F;2 16:50 现在遇到一个问题就是不是很想听课了，特别想做笔记，但是这个我个人感觉应该抑制这种想法，因为做笔记是一个非常享受的过程，不能现在养成学习压力稍微有点大就用做笔记来逃避，现在一定要坚持住把高数的课程听完至少，线代和概率论之后开学刷也来得及；</p>
<p>2023&#x2F;2&#x2F;3 10:45 整理笔记的时候可以使用教材也可以使用其他参考，最好是有例题一起整理；</p>
<p>2023&#x2F;2&#x2F;3 16:27 高等数学第一轮复习完毕，已经将教材笔记上传到电脑，为之后二轮复习做准备，现在纠结的点在于是继续刷线性代数的网课还是开始找教材边刷题边整理高数，对我个人而言不是特别想听网课了，这段时间明显能感受到听网课的效率在明显降低，所以暂且计划就是开始找考研资料来边刷题边整理资料，关于资料的选择现在是毫无头绪，先在网上找一找推荐吧，另一点就是不用去听网课报班，浪费大量时间并且不适合个人；</p>
<p>2023&#x2F;2&#x2F;7 16:35 在刷题的过程中你出现很大的问题，就是总喜欢去同济版的教材中寻找“好像”记过的某些笔记，而这样的笔记实际上找了很多遍都找不到，非常浪费时间 – 解决方法是，过了一遍教材，现在教材上面的例题以及解题方法等都是过去式，都只是帮助你回忆而不是只能用教材上的方法，所以现在教材的作用就是帮助你回忆一些重要的定义，我们需要在刷题或者使用其他考研参考书、百度等进行总结！！！不要再浪费宝贵的时间了！！！ – 关于《三大计算》这本书，就是依托答辩，基础不好的可以直接刷同济教材的课后题，基础好的可以直接刷660或者1800根本没有必要碰这本书，所以现在可以直接放弃这本参考资料了；关于考研教材的使用方式，个人是不建议再花费大量时间去听对应的课程，可以直接硬啃教材，这里注意不要再像第一遍一样手动的做一个整理笔记等非常浪费时间，复习方法是看完一章的教程之后去寻找该章相应的试题来进行大量的练手，一定整理错题本，不要写太多的废话，现在的唯一宗旨就是节约时间！！！</p>
<p>2023&#x2F;2&#x2F;7 20:46 现阶段就集中精力复习高数即可，线代和概率论复习时间太久记忆力也不行，没必要开始的很早；</p>
<blockquote>
<p>开学初期开始第二轮复习</p>
</blockquote>
<p>2023&#x2F;2&#x2F;20 15:37 刚刚尝试了一下使用ipad手写总结高数的知识点，总感觉差了那么点意思，手写知识点的缺点在于回头查阅不直观并且容易零碎不全（这点在我们一轮复习同济教材的时候得到了充分的体现），所以现在基本的复习思路就是使用md文件记录所学知识点和刷题总结，使用ipad手写刷题（注意不要花费太多时间在整理知识点上，我们现阶段需要注重的是刷题）；</p>
<p>2023&#x2F;4&#x2F;10 16:29 还是需要简单的复习一下基本的几何数学，至少知道切线之类的基本概念（刚刚看了一下后面会介绍空间几何的知识点，等到时候复习空间几何的时候集中再看平面几何(初中)和解析几何(高中)都行），解析几何知识点参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_u71VsAaiDYdRbCuYNRE_Q">微信公众平台 (qq.com)</a>；</p>
<p>2023&#x2F;5&#x2F;15 10:07 现在的状态确实不是很好，每天复习考研的时间感觉完全不够，所以这里先直接把知识点过完（高数、概率论、线代）然后再刷题；</p>
<p>2023&#x2F;5&#x2F;16 22:46 把张宇教材的听完了再整理同济教材上的没有整理的笔记（实际上也就剩余高等数学下册的部分知识点）；</p>
<p>2023&#x2F;5&#x2F;24 23:47 还是得找时间把同济教材的知识点总结了，这之后就不需要再使用教材了，直接刷题即可；</p>
<p>2023&#x2F;5&#x2F;25 10:41 截止目前，高数第二轮复习完毕，将线性代数和概率论的第一轮复习完毕后，准备开始刷题；</p>
<p>2023&#x2F;8&#x2F;7 11：03 高数基础阶段完成，自我感觉基本功已经差不多足够了，下一步准备开始张宇强化；</p>
<blockquote>
<p>八月初开启第三轮复习</p>
</blockquote>
<p>2023&#x2F;8&#x2F;8 9:05 强化阶段就不要像基础阶段一样先整理一遍再回头刷题，效率太低了。直接边整理强化阶段的知识点边刷题进行巩固，争取快速过完强化阶段；本来打算的是不看视频，奈何这个书上的结构不看视频真的学不到什么…暂时先看视频尝试效果如何；</p>
<p>2023&#x2F;8&#x2F;8 16:41 说真的如果强化阶段不看张宇的视频简直就是一大损失，讲的太好了！我听课的时候有一种要起飞的感觉。虽然强化阶段的题型把我虐的体无完肤，但是我能明显感觉到自己积累的知识点和具体解题时候的运用的差距在哪里，通过这种不断地巩固我相信我的数学能力能够更上一层楼。需要注意因为强化阶段一节课的知识量就非常的巨大，所以推荐听一节课马上就做一节课的课后总结，千万不要拖到后面会忘记很多细节，效果也会大打折扣；</p>
<hr>
<h1 id="一、高数预备知识"><a href="#一、高数预备知识" class="headerlink" title="一、高数预备知识"></a>一、高数预备知识</h1><p>这一章作为衔接高中数学和高等数学之间的桥梁，总结了一些重要且常用的知识点；</p>
<h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h2><h3 id="1-1-函数的性质"><a href="#1-1-函数的性质" class="headerlink" title="1.1 函数的性质"></a>1.1 函数的性质</h3><h4 id="1-1-1-单调性"><a href="#1-1-1-单调性" class="headerlink" title="1.1.1 单调性"></a>1.1.1 单调性</h4><p>除了可以使用求导来讨论函数在某个区间上的单调性，也可以使用如下定义进行判断（利用单调性的定义）</p>
<p><img src="/images/image-20230220155233631.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-1-2-奇偶性"><a href="#1-1-2-奇偶性" class="headerlink" title="1.1.2 奇偶性"></a>1.1.2 奇偶性</h4><p>关于奇偶性的定义没什么好说的，尤其需要注意以下两个有关奇偶性的结论</p>
<blockquote>
<p>结论1：偶函数的图形关于y轴对称，奇函数的图形关于原点对称</p>
<p>结论2：设f（x）是定义在[-l，l]上的任意函数，则F（x）&#x3D; f（x）-f（-x）必为奇函数；F（x）&#x3D;f（x）+f（-x）必为偶函数</p>
</blockquote>
<h4 id="1-1-3-有界性"><a href="#1-1-3-有界性" class="headerlink" title="1.1.3 有界性"></a>1.1.3 有界性</h4><blockquote>
<p>函数有界性的定义如下（重要，常用于证明函数有界）</p>
<p><img src="/images/image-20230708144716613.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<ul>
<li>函数有界还是无界一定是基于区间I来讨论，否则没有意义；</li>
<li>证明函数有界的基本思路就是在给定区间上找到某个正数M使得|f(x)&lt;&#x3D;M|成立，证明函数无界的思路是在区间内找到一点使得limx-&gt;x<del>0</del>f(x)的值为无穷大；</li>
<li>判断某个连续函数在开区间上是否有界，只需要判断其左端点的右极限和右端点的左极限是否存在即可；</li>
</ul>
<h4 id="1-1-4-重要结论"><a href="#1-1-4-重要结论" class="headerlink" title="1.1.4 重要结论"></a>1.1.4 重要结论</h4><p>其中有关导函数和积分上限函数的函数性质才是这部分的重点</p>
<p><img src="/images/image-20230220160609532.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>(8)若f(x)是无穷阶可导，则求导一次，奇偶性互换一次</p>
</blockquote>
<h3 id="1-2-函数的图像"><a href="#1-2-函数的图像" class="headerlink" title="1.2 函数的图像"></a>1.2 函数的图像</h3><h4 id="1-2-1-直角坐标系"><a href="#1-2-1-直角坐标系" class="headerlink" title="1.2.1 直角坐标系"></a>1.2.1 直角坐标系</h4><h5 id="1-幂函数"><a href="#1-幂函数" class="headerlink" title="(1)幂函数"></a>(1)幂函数</h5><p>函数表达式：y&#x3D;x^u^（其中u是实数，即以底数为自变量，幂为因变量，指数为常数）</p>
<p><img src="/images/image-20230220162817680.png" srcset="/img/loading.gif" lazyload alt="常用幂函数图像"></p>
<blockquote>
<p>观察图像可以知道，x^3^和x^根号3^互为反函数</p>
</blockquote>
<h5 id="2-指数函数"><a href="#2-指数函数" class="headerlink" title="(2)指数函数"></a>(2)指数函数</h5><p>函数表达式：y&#x3D;a^x^（其中a作为常数，即以指数为自变量，幂为因变量，底数为常数的函数）</p>
<p><img src="/images/image-20230220163053858.png" srcset="/img/loading.gif" lazyload alt="指数函数图像"></p>
<h5 id="3-对数函数"><a href="#3-对数函数" class="headerlink" title="(3)对数函数"></a>(3)对数函数</h5><p>函数表达式：y&#x3D;log<del>a</del>x（其中a作为常数，即以真数&#x2F;幂作为自变量，指数作为因变量，底数为常数的函数，对数函数是指数函数的反函数）</p>
<p><img src="/images/image-20230220163155500.png" srcset="/img/loading.gif" lazyload alt="对数函数图像"></p>
<blockquote>
<p>对数运算法则：</p>
<p><img src="/images/image-20230223144134700.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h5 id="4-三角函数"><a href="#4-三角函数" class="headerlink" title="(4)三角函数"></a>(4)三角函数</h5><h6 id="正-x2F-余弦函数"><a href="#正-x2F-余弦函数" class="headerlink" title="正&#x2F;余弦函数"></a>正&#x2F;余弦函数</h6><p><img src="/images/image-20230220163305329.png" srcset="/img/loading.gif" lazyload alt="正弦函数和余弦函数图像"></p>
<p><img src="/images/image-20230220163432062.png" srcset="/img/loading.gif" lazyload alt="基本性质"></p>
<h6 id="正-x2F-余切函数"><a href="#正-x2F-余切函数" class="headerlink" title="正&#x2F;余切函数*"></a>正&#x2F;余切函数*</h6><p><img src="/images/image-20230220163614195.png" srcset="/img/loading.gif" lazyload alt="正切函数与余切函数图像"></p>
<p><img src="/images/image-20230220163708701.png" srcset="/img/loading.gif" lazyload alt="基本性质"></p>
<h6 id="正-x2F-余割函数"><a href="#正-x2F-余割函数" class="headerlink" title="正&#x2F;余割函数"></a>正&#x2F;余割函数</h6><p><img src="/images/image-20230220163759600.png" srcset="/img/loading.gif" lazyload alt="正割函数与余割函数图像"></p>
<p><img src="/images/image-20230220163843460.png" srcset="/img/loading.gif" lazyload alt="基本性质"></p>
<h5 id="5-反三角函数"><a href="#5-反三角函数" class="headerlink" title="(5)反三角函数"></a>(5)反三角函数</h5><blockquote>
<p>反三角函数相当好记，都是单调函数（可以利用这一点直接描点画得到反三角函数的图像）</p>
</blockquote>
<h6 id="反正-x2F-余弦函数"><a href="#反正-x2F-余弦函数" class="headerlink" title="反正&#x2F;余弦函数*"></a>反正&#x2F;余弦函数*</h6><p><img src="/images/image-20230220164213939.png" srcset="/img/loading.gif" lazyload alt="函数图象"></p>
<p><img src="/images/image-20230220164308893.png" srcset="/img/loading.gif" lazyload alt="基本性质"></p>
<h6 id="反正-x2F-余切函数"><a href="#反正-x2F-余切函数" class="headerlink" title="反正&#x2F;余切函数*"></a>反正&#x2F;余切函数*</h6><p><img src="/images/image-20230220164327785.png" srcset="/img/loading.gif" lazyload alt="函数图像"></p>
<p><img src="/images/image-20230220164704042.png" srcset="/img/loading.gif" lazyload alt="基本性质"></p>
<h5 id="6-分段函数"><a href="#6-分段函数" class="headerlink" title="(6)分段函数"></a>(6)分段函数</h5><p>下面列举几个重要的分段函数</p>
<h6 id="绝对值函数"><a href="#绝对值函数" class="headerlink" title="绝对值函数"></a>绝对值函数</h6><p><img src="/images/image-20230220165224344.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230220165237430.png" srcset="/img/loading.gif" lazyload></p>
<h6 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h6><p><img src="/images/image-20230220165333534.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230220165345546.png" srcset="/img/loading.gif" lazyload></p>
<h6 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h6><p>关于[]取整函数，表示不超过x的最大整数，即向下取整（考研数学中只有向下取整，没有四舍五入或者向上取整，请注意区分），其图像是右连续的，主要有以下两个重要性质</p>
<ul>
<li>x-1&lt;[x]&lt;&#x3D;x(常用)，[x]&lt;&#x3D;x&lt;[x]+1</li>
<li>[x+n]&#x3D;[x]+n，n为正整数(常用)</li>
</ul>
<p><img src="/images/image-20230220165416600.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230220165431601.png" srcset="/img/loading.gif" lazyload alt="取整函数图像"></p>
<h5 id="7-图像变换"><a href="#7-图像变换" class="headerlink" title="(7)图像变换"></a>(7)图像变换</h5><h6 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h6><p><img src="/images/image-20230220165727609.png" srcset="/img/loading.gif" lazyload alt="左加右减"></p>
<p><img src="/images/image-20230220170211528.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<p><img src="/images/image-20230220165824892.png" srcset="/img/loading.gif" lazyload alt="上加下减"></p>
<p><img src="/images/image-20230220170228551.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<h6 id="伸缩变换"><a href="#伸缩变换" class="headerlink" title="伸缩变换"></a>伸缩变换</h6><p><img src="/images/image-20230220170302305.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-2-2-极坐标"><a href="#1-2-2-极坐标" class="headerlink" title="1.2.2 极坐标*"></a>1.2.2 极坐标*</h4><p>一般情况下在极坐标中作图与直角坐标系中一样，都是通过描点作图 – 以下常见极坐标下的图形只需要记忆图形形状无需记忆极坐标方程；</p>
<h5 id="1-心形线"><a href="#1-心形线" class="headerlink" title="(1)心形线"></a>(1)心形线</h5><p>函数表达式：r&#x3D;a(1-cos θ) (a&gt;0)</p>
<p><img src="/images/image-20230220171122272.png" srcset="/img/loading.gif" lazyload alt="函数图像"></p>
<p><img src="/images/image-20230220171105085.png" srcset="/img/loading.gif" lazyload alt="2Π为周期"></p>
<h5 id="2-玫瑰线"><a href="#2-玫瑰线" class="headerlink" title="(2)玫瑰线"></a>(2)玫瑰线</h5><p>函数表达式：r&#x3D;asin 3θ(a&gt;0)</p>
<p><img src="/images/image-20230220171352942.png" srcset="/img/loading.gif" lazyload alt="函数图像"></p>
<p><img src="/images/image-20230220171334484.png" srcset="/img/loading.gif" lazyload alt="2/3Π为周期"></p>
<h5 id="3-阿基米德螺旋线"><a href="#3-阿基米德螺旋线" class="headerlink" title="(3)阿基米德螺旋线"></a>(3)阿基米德螺旋线</h5><p>函数表达式：r&#x3D;aθ(a&gt;&#x3D;0,θ&gt;&#x3D;0)</p>
<p><img src="/images/image-20230220171458139.png" srcset="/img/loading.gif" lazyload alt="函数图像"></p>
<h5 id="4-伯努利双纽线"><a href="#4-伯努利双纽线" class="headerlink" title="(4)伯努利双纽线"></a>(4)伯努利双纽线</h5><p>（这玩意真的只能硬背，本来极坐标下作图就比较困难…背下来节约很多时间）</p>
<p><img src="/images/image-20230220171547998.png" srcset="/img/loading.gif" lazyload alt="函数图像"></p>
<h4 id="1-2-3-特殊图像"><a href="#1-2-3-特殊图像" class="headerlink" title="1.2.3 特殊图像"></a>1.2.3 特殊图像</h4><h5 id="1-双曲正弦-amp-反双曲正弦"><a href="#1-双曲正弦-amp-反双曲正弦" class="headerlink" title="(1)双曲正弦&amp;反双曲正弦"></a>(1)双曲正弦&amp;反双曲正弦</h5><p><img src="/images/image-20230220192302357.png" srcset="/img/loading.gif" lazyload></p>
<p>反双曲正弦函数是一个非常常用的函数，它求导为如下表达式；且根据图像可知，当x-&gt;0时反双曲正弦函数与x趋于0的速度相同，因此可得等价无穷小替换</p>
<p><img src="/images/image-20230220192518215.png" srcset="/img/loading.gif" lazyload alt="特殊性质"></p>
<h5 id="2-双曲余弦函数"><a href="#2-双曲余弦函数" class="headerlink" title="(2)双曲余弦函数"></a>(2)双曲余弦函数</h5><p><img src="/images/image-20230808170750703.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="3-反函数"><a href="#3-反函数" class="headerlink" title="(3)反函数"></a>(3)反函数</h5><p>（有关反函数的具体定义教材和网上都没有一个比较统一的说法，因此这里也不给出严格的定义）</p>
<p>已知函数f(x)，求解其反函数f^-1^(x)，不用画图，步骤如下：</p>
<ol>
<li>将f(x)中x关于y的表达式写作y关于x的表达式，注意写出y的范围也就是值域；</li>
<li>将表达式中所有的y替换为x，所有的x替换为y，前面y的范围就是此处x的范围，得到f^-1^(x)的表达式；</li>
</ol>
<p>例题如下</p>
<p><img src="/images/image-20230610194648651.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>结论1：</p>
<ul>
<li>单调函数必有反函数，但不存在单调性的函数仍可能有反函数（分段函数不具备单调性但某些仍有反函数，故函数的单调性是反函数存在的充分非必要条件）</li>
<li>定义在区间上的<code>连续函数</code>存在反函数的<code>充分必要条件</code>是该函数在区间上<code>严格单调</code>（严格单调包含于单调，因为要一一对应所以必须严格单调）</li>
</ul>
<p>结论2：反函数与直接函数关于直线y&#x3D;x对称 – 需要注意的是，y&#x3D;f(x)的反函数x&#x3D;f^-1^(y)的图像在同一坐标系下完全重合，事实上只有y&#x3D;f^-1^(x)与y&#x3D;f(x)才是关于y&#x3D;x对称的；即y&#x3D;arcsinx和y&#x3D;sinx是关于y&#x3D;x对称，而x&#x3D;arcsiny和y&#x3D;sinx是完全重合的（原因是一个是y关于x的表达式，一个是x关于y的表达式，若要画在同一个坐标系中需要统一自变量和因变量）；</p>
</blockquote>
<h5 id="4-高斯曲线"><a href="#4-高斯曲线" class="headerlink" title="(4)高斯曲线"></a>(4)高斯曲线</h5><p>高斯曲线在(-∞,+∞)的面积为Π，这个积分是典型的用二重积分解决定积分的案例（详情见[高斯曲线的面积计算](# 6.3 基本结论*)）</p>
<p><img src="/images/image-20230808203519941.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-数列"><a href="#2-数列" class="headerlink" title="2.数列"></a>2.数列</h2><h3 id="2-1-等差数列"><a href="#2-1-等差数列" class="headerlink" title="2.1 等差数列"></a>2.1 等差数列</h3><p><img src="/images/image-20230220171915195.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-2-等比数列"><a href="#2-2-等比数列" class="headerlink" title="2.2 等比数列"></a>2.2 等比数列</h3><p><img src="/images/image-20230220171958777.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-数列求和"><a href="#2-3-数列求和" class="headerlink" title="2.3 数列求和"></a>2.3 数列求和</h3><p><img src="/images/image-20230220172054759.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-三角函数"><a href="#3-三角函数" class="headerlink" title="3.三角函数"></a>3.三角函数</h2><h3 id="3-1-三角转换"><a href="#3-1-三角转换" class="headerlink" title="3.1 三角转换"></a>3.1 三角转换</h3><p><img src="/images/image-20230220172251664.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230220172333407.png" srcset="/img/loading.gif" lazyload alt="奇变偶不变，符号看象限"></p>
<blockquote>
<p>口诀：奇变偶不变，符号看象限</p>
<ul>
<li><p>此处的奇偶指的是加上的角是Π&#x2F;2的奇数倍还是偶数倍；</p>
</li>
<li><p>此处的符号指的是将α看作锐角时，原三角函数如sin(Π&#x2F;2-α)在Π&#x2F;2-α的象限的符号（三角函数在四个象限中的符号可以背象限图）</p>
</li>
</ul>
<p><img src="/images/9e3df8dcd100baa1d75ce9b24810b912c8fc2e42.jpeg" srcset="/img/loading.gif" lazyload alt="象限图_直角坐标系"></p>
</blockquote>
<h3 id="3-2-三角函数值"><a href="#3-2-三角函数值" class="headerlink" title="3.2 三角函数值"></a>3.2 三角函数值</h3><p><img src="/images/image-20230220173001401.png" srcset="/img/loading.gif" lazyload alt="常用三角函数值"></p>
<h3 id="3-3-重要公式"><a href="#3-3-重要公式" class="headerlink" title="3.3 重要公式*"></a>3.3 重要公式*</h3><h4 id="3-3-1-倍角公式"><a href="#3-3-1-倍角公式" class="headerlink" title="3.3.1 倍角公式"></a>3.3.1 倍角公式</h4><p><img src="/images/image-20230220174208255.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-3-2-半角公式"><a href="#3-3-2-半角公式" class="headerlink" title="3.3.2 半角公式"></a>3.3.2 半角公式</h4><p>半角公式也称为降幂公式</p>
<p><img src="/images/image-20230220174236082.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-3-3-和差公式"><a href="#3-3-3-和差公式" class="headerlink" title="3.3.3 和差公式"></a>3.3.3 和差公式</h4><p>只需要记忆sin和cos的和差公式即可</p>
<p><img src="/images/image-20230220174259661.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-3-4-积化和差"><a href="#3-3-4-积化和差" class="headerlink" title="3.3.4 积化和差"></a>3.3.4 积化和差</h4><p>主要借助和差公式</p>
<p><img src="/images/image-20230220174332969.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-3-5-和差化积"><a href="#3-3-5-和差化积" class="headerlink" title="3.3.5 和差化积"></a>3.3.5 和差化积</h4><p>主要借助积化和差公式</p>
<p><img src="/images/image-20230220174353294.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-3-6-辅助角公式"><a href="#3-3-6-辅助角公式" class="headerlink" title="3.3.6 辅助角公式"></a>3.3.6 辅助角公式</h4><p><img src="/images/image-20230301194405752.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-3-7-平方关系"><a href="#3-3-7-平方关系" class="headerlink" title="3.3.7 平方关系"></a>3.3.7 平方关系</h4><p><img src="/images/image-20230301200019508.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-零散知识点"><a href="#4-零散知识点" class="headerlink" title="4.零散知识点"></a>4.零散知识点</h2><h3 id="4-1-一元二次方程"><a href="#4-1-一元二次方程" class="headerlink" title="4.1 一元二次方程"></a>4.1 一元二次方程</h3><p>二次函数的图像是一条对称轴与y轴平行或重合于y轴的抛物线</p>
<p><img src="/images/image-20230220174543490.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>结论6：一元二次方程的顶点坐标为<img src="/images/image-20230220191141038.png" srcset="/img/loading.gif" lazyload>，即抛物线的对称轴x&#x3D;-b&#x2F;2a与抛物线的交点</p>
</blockquote>
<h3 id="4-2-因式分解"><a href="#4-2-因式分解" class="headerlink" title="4.2 因式分解"></a>4.2 因式分解</h3><p><img src="/images/image-20230220174623311.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-3-重要不等式"><a href="#4-3-重要不等式" class="headerlink" title="4.3 重要不等式"></a>4.3 重要不等式</h3><p>（考研题型的综合性很强，这些知识点可能看起来很简单但是在解题的时候想不起来就容易卡住）</p>
<p><img src="/images/image-20230806160433494.png" srcset="/img/loading.gif" lazyload></p>
<p>(11)当0&lt;&#x3D;x&lt;&#x3D;1时，有0&lt;&#x3D;ln(1+t)&lt;&#x3D;t</p>
<blockquote>
<p>不等式的一个经典应用就是配合夹逼法则求极限；</p>
</blockquote>
<h3 id="4-4-充分条件和必要条件"><a href="#4-4-充分条件和必要条件" class="headerlink" title="4.4 充分条件和必要条件*"></a>4.4 充分条件和必要条件*</h3><p>充分条件是前推后，必要条件是后推前，需要注题干描述的术语（非常的绕，自己找合适的方式理解）</p>
<ul>
<li>xx是yy的充分&#x2F;必要条件，这里xx在前，yy在后</li>
<li>xx的充分&#x2F;必要条件是yy，这里yy在前，xx在后</li>
<li>xx是yy的充分&#x2F;必要条件&lt;&#x3D;&gt;yy的充分&#x2F;必要条件是xx</li>
<li>xx是yy的充分&#x2F;必要条件&lt;&#x3D;&gt;xx的必要&#x2F;充分条件是yy</li>
</ul>
<p>举例：</p>
<p>在某点可微的<code>必要条件</code>是偏导数f’x和f’y都存在（这里偏导存在在前，可微在后，可微可以推出偏导存在） &lt;&#x3D;&gt; 在某点可微是在该点偏导数f’x和f’y都存在的<code>充分条件</code>（可微在前，偏导存在，可微可以推出偏导存在）；</p>
<p>在某点可微的<code>充分条件</code>是偏导数存在且连续（偏导存在且连续在前，可微在后，偏导存在且连续可以推出可微）&lt;&#x3D;&gt;在某点可微是在该点偏导存在且连续的<code>必要条件</code>（可微在前，偏导存在且连续在后，偏导存在且连续可以推出可微）；</p>
<h1 id="二、数列极限"><a href="#二、数列极限" class="headerlink" title="二、数列极限*"></a>二、数列极限*</h1><blockquote>
<p>证明数列极限一般使用数列极限的定义或单调有界准则，求解数列极限一般使用常数法、夹逼准则或定积分的精确定义。本章知识点较少，但对应考研题型的难度相当大，与无穷级数、中值定理并称考研高数“三大拦路虎”</p>
</blockquote>
<h2 id="1-数列极限定义"><a href="#1-数列极限定义" class="headerlink" title="1.数列极限定义"></a>1.数列极限定义</h2><p><img src="/images/image-20230221185702167.png" srcset="/img/loading.gif" lazyload alt="数列极限定义"></p>
<blockquote>
<p>结论1：若数列收敛，则其任意子数列也收敛，并且其子数列和数列收敛到同一个极限(数列收敛的充要条件)；</p>
<p>结论2：数列的某个子列收敛并不能保证原数列收敛 – 若函数的两个收敛子列收敛到不同极限，则原数列一定发散；</p>
<p>结论3：数列的某个子列发散，则原数列一定发散；</p>
</blockquote>
<p>使用数列极限定义证明极限存在时，只需要找到正整数N即可（一般会对最后的答案进行取整[]+1的操作确保结果可靠）；</p>
<p>要证明数列极限不存在，总结有如下方法</p>
<ul>
<li>若数列无界，则数列极限不存在；</li>
<li>若数列的子列发散，则数列发散；</li>
</ul>
<h2 id="2-收敛数列的性质"><a href="#2-收敛数列的性质" class="headerlink" title="2.收敛数列的性质"></a>2.收敛数列的性质</h2><p><img src="/images/image-20230612094405185.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>一般情况下唯一性和存在为常数一起出现，即当limx<del>n</del>存在时，常记为limx<del>n</del>&#x3D;A其中A为某唯一常数</li>
<li>上述保号性的使用一般体现在脱帽戴帽法中，实际下面结论中的0改为任意常数a也成立<ul>
<li>脱帽：若limx<del>n</del>&#x3D;A&gt;0则当n-&gt;∞时x<del>n</del>&gt;0，若limx<del>n</del>&#x3D;A&lt;0则当n-&gt;∞时x<del>n</del>&lt;0（严格不等号）</li>
<li>戴帽：当n-&gt;∞时x<del>n</del>&gt;&#x3D;0则limx<del>n</del>&#x3D;A&gt;&#x3D;0，当n-&gt;∞时x<del>n</del>&lt;&#x3D;0则limx<del>n</del>&#x3D;A&lt;&#x3D;0（非严格不等号）<ul>
<li>一般情况下使用戴帽法会引入等号，而有些等号我们是不希望它存在的，可以使用<code>反证法</code>或<code>放缩法</code>(中间找人挡一下)进行排除</li>
</ul>
</li>
</ul>
</li>
<li>极限运算法则的使用前提是已知两个数列的极限都分别存在，盲目使用极限运算法则很容易做错！！！</li>
</ul>
<blockquote>
<p>补充一些比较重要的小结论：</p>
<p>结论1：</p>
<p>limx-&gt;x<del>0</del>f(x)&#x3D;f(x<del>0</del>)可以推出limx-&gt;x<del>0</del>|f(x)|&#x3D;|f(x<del>0</del>)|，反之不一定成立</p>
<p>结论2：</p>
<p><img src="/images/image-20230612095458165.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="3-夹逼准则-数列"><a href="#3-夹逼准则-数列" class="headerlink" title="3.夹逼准则(数列)"></a>3.夹逼准则(数列)</h2><p>数列的夹逼准则主要分为两步分别是“夹中间”(放缩)和“取极限”(求数列极限)，分为两种放缩方法，分别是利用基本放缩和题干条件，其中基本放缩有以下两个</p>
<p><img src="/images/image-20230811170728651.png" srcset="/img/loading.gif" lazyload></p>
<p>具体的使用方法如下</p>
<p><img src="/images/image-20230811170834710.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-方程列和区间列"><a href="#4-方程列和区间列" class="headerlink" title="4.方程列和区间列"></a>4.方程列和区间列</h2><p>方程列是这样的一种数列，即一系列不同的方程的根构成数列{x<del>n</del>}</p>
<p><img src="/images/image-20230811162204352.png" srcset="/img/loading.gif" lazyload></p>
<p>区间列是这样的一种数列，即同一个方程在不同区间上的根构成数列{x<del>n</del>}</p>
<p><img src="/images/image-20230811162247418.png" srcset="/img/loading.gif" lazyload></p>
<p>方程列和区间列的问题的解决基本思路与普通数列是相同的，所以不必过分担心</p>
<h1 id="三、函数极限与连续性"><a href="#三、函数极限与连续性" class="headerlink" title="三、函数极限与连续性"></a>三、函数极限与连续性</h1><h2 id="1-函数极限"><a href="#1-函数极限" class="headerlink" title="1.函数极限"></a>1.函数极限</h2><blockquote>
<p>1.1介绍完函数极限的定义之后，下面的基本都是在讲如何求解极限（没必要特地去总结有哪些更细致的方法什么有理化之类的（有的教程甚至总结了20多种方法，全记下来是最愚蠢的行为），核心就是下面几个以及<code>3.未定式极限计算</code>，其他的衍生题型无非就是多了一些对待求多项式的变形而已）</p>
</blockquote>
<h3 id="1-1-函数极限"><a href="#1-1-函数极限" class="headerlink" title="1.1 函数极限"></a>1.1 函数极限</h3><h4 id="1-1-1-函数极限的定义-去心"><a href="#1-1-1-函数极限的定义-去心" class="headerlink" title="1.1.1 函数极限的定义(去心)"></a>1.1.1 函数极限的定义(去心)</h4><p><img src="/images/image-20230222191445925.png" srcset="/img/loading.gif" lazyload alt="函数趋于某一点的极限"></p>
<p>自变量取值双向性：x-&gt;x<del>0</del>的方式，既需要考虑x-&gt;x<del>0</del>^-^，也需要考虑x-&gt;x<del>0</del>^+^</p>
<blockquote>
<p>结论1：因为函数极限的定义是在<code>去心邻域</code>，这表示f(x)在x0有无极限和f(x)在x0是否有定义无关；</p>
<p>结论2：函数在某点极限存在的<code>充要条件</code>是在该点左极限和右极限存在且相等 – 常用于判断极限是否存在；</p>
<p>结论3：如果极限存在则它可以表示为一个确定的数值，这也是一种常规的抽象表示方法limf(x)&#x3D;A。实际上除了极限，考研数学中当某点导数f’(x<del>0</del>)存在、某区间上定积分存在、二重积分以及三重积分存在均可令其为A建立等式；</p>
</blockquote>
<p><img src="/images/image-20230222191652402.png" srcset="/img/loading.gif" lazyload alt="函数趋于无穷的极限"></p>
<p>自变量取值双向性：x-&gt;∞，既包括x-&gt;-∞，也包括x-&gt;+∞！！！换句话说，limx-&gt;∞f(x)&#x3D;A等价于limx-&gt;-∞f(x)&#x3D;limx-&gt;+∞f(x)&#x3D;A</p>
<h4 id="1-1-2-函数极限的性质"><a href="#1-1-2-函数极限的性质" class="headerlink" title="1.1.2 函数极限的性质"></a>1.1.2 函数极限的性质</h4><p>在形式上，数列极限是函数极限的一种自变量为正整数的特例，因此数列极限的性质基本上都可以搬到函数极限上使用（但需要对描述进行一定的修改）</p>
<p><img src="/images/image-20230612135732202.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li><p>唯一性又称为自变量取值双向性：</p>
<ul>
<li><p>x-&gt;x<del>0</del>的方式，既需要考虑x-&gt;x<del>0</del>^-^，也需要考虑x-&gt;x<del>0</del>^+^</p>
</li>
<li><p>x-&gt;∞，既包括x-&gt;-∞，也包括x-&gt;+∞！！！换句话说，limx-&gt;∞f(x)&#x3D;A等价于limx-&gt;-∞f(x)&#x3D;limx-&gt;+∞f(x)&#x3D;A</p>
</li>
</ul>
</li>
<li><p>局部有界性是指，若f(x)在x<del>0</del>极限存在则在x<del>0</del>邻域内有界。举个例子，若limx-&gt;x<del>0</del>存在，则f(x)在x<del>0</del>的邻域有界 – 极限存在只是函数局部有界的充分条件而非必要条件：</p>
<ul>
<li><p>f(x)在[a,b]上连续，则f(x)在[a,b]上有界；</p>
</li>
<li><p>f(x)在(a,b)内连续且limx-&gt;a^+^和limx-&gt;b^-^都存在，则f(x)在(a,b)内有界 – 该结论常用于开区间的有界性判断；</p>
</li>
<li><p>f’(x)在(a,b)内有界则f(x)在(a,b)有界（可用牛莱公式理解）；</p>
</li>
</ul>
</li>
<li><p>函数极限和数列极限的另一个区别就在于函数是局部有界性和局部保号性（只在x的邻域内成立），这两个性质都很好理解，画图作出函数极值领域内的函数图像很好看出局部有界性和局部保号性；</p>
</li>
<li><p>局部保号性是三条性质中最重要的，需要记忆的是由局部保号性推导得到的不等式脱帽法和不等式戴帽法</p>
<ul>
<li>不等式脱帽法：若limf(x)&gt;0则f(x)&gt;0，若limf(x)&lt;0则f(x)&lt;0 – 严格不等号</li>
<li>不等式戴帽法：若f(x)&gt;0则limf(x)&gt;&#x3D;0，若f(x)&lt;0则limf(x)&lt;&#x3D;0 – 非严格不等号</li>
<li>相应的，还有等式脱帽和戴帽，互为充要条件描述如下：limf(x)&#x3D;A &lt;&#x3D;&gt; f(x)&#x3D;A+a其中lima&#x3D;0</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-1-3-极限运算法则"><a href="#1-1-3-极限运算法则" class="headerlink" title="1.1.3 极限运算法则"></a>1.1.3 极限运算法则</h4><p>与数列极限类似，函数极限仍然有四则运算法则</p>
<p><img src="/images/image-20230612220345564.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-2-洛必达法则"><a href="#1-2-洛必达法则" class="headerlink" title="1.2 洛必达法则"></a>1.2 洛必达法则</h3><p><img src="/images/image-20230222193334562.png" srcset="/img/loading.gif" lazyload alt="做题版"></p>
<blockquote>
<p>关于洛必达法则使用需要注意以下几点</p>
<p><img src="/images/image-20230222193845790.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>关于第一点，实际上还有其他类型也可以用洛必达，但是针对考研来说我们只认为有两种形式可以使用洛必达</li>
<li>第三点简单来说就是，函数极限存在其对应的洛必达结果可能不存在，而函数对应的洛必达结果存在则函数的极限一定存在；</li>
</ul>
</blockquote>
<h3 id="1-3-泰勒公式"><a href="#1-3-泰勒公式" class="headerlink" title="1.3 泰勒公式"></a>1.3 泰勒公式</h3><p>泰勒公式是计算极限的重要工具，下面给出几个重要泰勒公式（直接背，不用管泰勒公式如何导出，这涉及导数，将在后面详细介绍）</p>
<p><img src="/images/image-20230222194201160.png" srcset="/img/loading.gif" lazyload alt="x-&gt;0的几个重要麦克劳林展开式"></p>
<blockquote>
<p>注意：</p>
<p><img src="/images/image-20230222194327449.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>使用泰勒公式求极限，难点在于函数应当展开到x的几次幂，主要有以下几种情况</p>
<ol>
<li><p>A&#x2F;B型，如果分母（或分子）是x的k次幂，则应把分子（或分母）展开到x的k次幂，可称为“上下同阶”原则；</p>
<ul>
<li>注意，当展开的分子为加减法的时候相对简单，但是当展开的分子为乘法的时候存在一定难度，下面这题是一道经典的题型<br><img src="/images/image-20230808222904896.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li><p>A-B型，将 A，B 分别展开到它们的系数不相等的 x 的最低次幂为止，称为“幂次最低”原则（分别将A，B展开到x^n^的时候，其前面的系数不同，故展开到该幂次即可）；</p>
<ul>
<li>注意“最低”，也就是说如果缺项是可以补项的<br><img src="/images/image-20230808223142284.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ol>
<h3 id="1-4-海涅定理-归结原则"><a href="#1-4-海涅定理-归结原则" class="headerlink" title="1.4 海涅定理(归结原则)"></a>1.4 海涅定理(归结原则)</h3><p>海涅定理是联系数列极限和函数极限的桥梁，它指出：在极限存在的条件下，函数极限和数列极限可以相互转化</p>
<p><img src="/images/image-20230222195335169.png" srcset="/img/loading.gif" lazyload alt="海涅定理"></p>
<p>海涅定理看起来很抽象，简单来说，海涅定理就是当n-&gt;∞时f(x<del>n</del>)的极限值(数列极限)等于x-&gt;x<del>0</del>时f(x)的极限值(函数极限)，下面是海涅定理的一个应用（证明题）</p>
<p><img src="/images/image-20230709201640559.png" srcset="/img/loading.gif" lazyload></p>
<p>可以认为，函数极限中的x是一个连续变量满足x-&gt;x<del>0</del>，它对应数列极限中“无穷多个”符合x<del>n</del>-&gt;x<del>0</del>的离散变量x<del>n</del>，海涅定理更常见的应用如下（计算题）</p>
<p><img src="/images/image-20230810102523037.png" srcset="/img/loading.gif" lazyload></p>
<p>即“针对某一类数列通项为x<del>n</del>的具有相同性质(即limx<del>n</del>-&gt;x<del>0</del>)的数列，其极限计算的结果都等于同一个函数极限limx-&gt;x<del>0</del>f(x)”，也就是说海涅定理其实最牛的地方是用于简化数列极限的计算，将某一类数列极限的计算抽象为同一个函数极限的计算</p>
<h3 id="1-5-无穷小和重要极限"><a href="#1-5-无穷小和重要极限" class="headerlink" title="1.5 无穷小和重要极限"></a>1.5 无穷小和重要极限</h3><blockquote>
<p>定义：函数f(x)的极限值为0称<code>无穷小</code>，函数f(x)的极限值为无穷（无论正无穷还是负无穷）称为<code>无穷大</code>；</p>
</blockquote>
<p>无穷小的比阶是整个无穷小的使用的核心，当题干问道两个函数之间的无穷小关系，一般都是列出无穷小计算式并计算，根据如下计算结果得出两个函数之间的无穷小关系</p>
<p><img src="/images/image-20230612221330249.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>结论1：并不是任意两个无穷小都可以比阶，当两个无穷小无法比阶意味着这两个无穷小无高低阶的区分也无同阶可言；</p>
</blockquote>
<p>下面几个<code>无穷小</code>的运算法则尤其重要，注意使用的条件！！！</p>
<ul>
<li><p><code>有限个</code>无穷小的<code>和</code>是无穷小</p>
</li>
<li><p><code>有界函数</code>与无穷小的乘积是无穷小</p>
</li>
<li><p><code>有限个</code>无穷小的<code>乘积</code>是无穷小</p>
</li>
</ul>
<p>在<code>泰勒公式</code>的应用中，会对<code>高阶无穷小</code>进行计算，主要有以下法则</p>
<p><img src="/images/image-20230222200907119.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-5-1-等价无穷小"><a href="#1-5-1-等价无穷小" class="headerlink" title="1.5.1 等价无穷小"></a>1.5.1 等价无穷小</h4><h5 id="1-普通函数型"><a href="#1-普通函数型" class="headerlink" title="(1)普通函数型"></a>(1)普通函数型</h5><p><img src="/images/image-20230808194656075.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>使用时一般都要做广义化：可将x替换为趋向于0的函数；</li>
<li>等价无穷小替换原则：<ul>
<li>加减不能进行等价无穷小替换(如tanx-sinx)，只有商或积的时候可以替换(如tanx*(1-cosx)~x(1-cosx)) – 等价无穷小替换本质上就是泰勒展开式的一种特殊形式，仅仅只是保留了泰勒展开式的第一项，因此有时候精度不会那么准确，如果做加减法会进一步造成更大的误差；</li>
<li>可以只替换分子或分母，若分子或分母是若干因子乘积，也可以只替换其中的某个因子；</li>
<li>趋于常数的项直接提出去不用替换；</li>
</ul>
</li>
</ul>
</blockquote>
<p>除了上述常用等价无穷小外，下面补充解题中产生的其他有意义的无穷小</p>
<p><img src="/images/image-20230808162540977.png" srcset="/img/loading.gif" lazyload alt="重要极限无穷小"></p>
<p><img src="/images/image-20230811093654057.png" srcset="/img/loading.gif" lazyload alt="补充平方无穷小"></p>
<h5 id="2-复合函数型"><a href="#2-复合函数型" class="headerlink" title="(2)复合函数型"></a>(2)复合函数型</h5><p><img src="/images/image-20230808194807119.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>其证明如下（重要，解题依据）</li>
</ul>
<p><img src="/images/image-20230808194850213.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>(2),(3),(4),(5)的前提都是假设所给抽象函数均为研究区间上的连续函数</li>
<li>若m,n为实数（即可能是分数也可能是根式），则当x-&gt;0^+^时该命题仍然成立</li>
</ul>
</blockquote>
<h5 id="3-变上限积分型"><a href="#3-变上限积分型" class="headerlink" title="(3)变上限积分型"></a>(3)变上限积分型</h5><p><img src="/images/image-20230808194914987.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>其证明如下</li>
</ul>
<p><img src="/images/image-20230808194953533.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>若m为正实数，则当x-&gt;0^+^时该命题仍然成立</li>
</ul>
</blockquote>
<h5 id="4-复合函数与变上限积分型"><a href="#4-复合函数与变上限积分型" class="headerlink" title="(4)复合函数与变上限积分型*"></a>(4)复合函数与变上限积分型*</h5><p><img src="/images/image-20230808195223368.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>其证明如下</li>
</ul>
<p><img src="/images/image-20230808195257196.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>若m,n为正实数，则当x-&gt;0^+^时该命题仍然成立</li>
</ul>
</blockquote>
<h5 id="5-推广型"><a href="#5-推广型" class="headerlink" title="(5)推广型"></a>(5)推广型</h5><p><img src="/images/image-20230808195444553.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>推广型的“推广”意义在于，前四种形式都是被积函数趋于0的，而这种形式的被积函数不趋于0</li>
</ul>
</blockquote>
<h5 id="6-找大哥型"><a href="#6-找大哥型" class="headerlink" title="(6)找大哥型"></a>(6)找大哥型</h5><p><img src="/images/image-20230808195602377.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-5-2-重要极限"><a href="#1-5-2-重要极限" class="headerlink" title="1.5.2 重要极限"></a>1.5.2 重要极限</h4><p><img src="/images/image-20230222201252823.png" srcset="/img/loading.gif" lazyload></p>
<p>注意这里的两个重要极限都是可以广义化的，下面给出一道例题帮助理解</p>
<p><img src="/images/image-20230306194648056.png" srcset="/img/loading.gif" lazyload alt="例题_1"></p>
<p>因为广义化的存在，因此可以推出其他重要极限如下</p>
<p><img src="/images/image-20230808163333303.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-6-夹逼准则"><a href="#1-6-夹逼准则" class="headerlink" title="1.6 夹逼准则"></a>1.6 夹逼准则</h3><p>（数列极限同样有夹逼准则，但这里我们主要讨论函数的夹逼准则）</p>
<p><img src="/images/image-20230223150242230.png" srcset="/img/loading.gif" lazyload></p>
<p>简单来说就是f(x)的极限不好求解则借助g(x)和h(x)的极限侧面求解，这是求解函数极限的“杀手锏”</p>
<h2 id="2-函数连续与间断"><a href="#2-函数连续与间断" class="headerlink" title="2.函数连续与间断"></a>2.函数连续与间断</h2><h3 id="2-1-函数连续-不去心"><a href="#2-1-函数连续-不去心" class="headerlink" title="2.1 函数连续(不去心)"></a>2.1 函数连续(不去心)</h3><p><img src="/images/image-20230708153038931.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>结论1：函数在内点连续的<code>充要条件</code>是在该点既左连续又右连续；</p>
<p>结论2：连续在几何上的含义就是一笔画不提笔，可导的几何含义是既一笔画又光滑；</p>
<p>结论3：函数在内点处的连续定义就是上述定义1，在端点处的连续定义为</p>
<ul>
<li>设x∈[a,b]，若limx-&gt;a^+^f(x)&#x3D;f(a)则称f(x)在x&#x3D;a右连续</li>
<li>若limx-&gt;b^-^&#x3D;f(b)则称f(x)在x&#x3D;b左连续</li>
</ul>
<p>将内点的连续定义和端点的连续定义合并在一起就是上述定义2，即函数在闭区间上连续的定义</p>
</blockquote>
<h3 id="2-2-函数间断"><a href="#2-2-函数间断" class="headerlink" title="2.2 函数间断"></a>2.2 函数间断</h3><p>函数的连续性实际是函数极限的应用，在本节主要讨论函数的连续与间断。因为一切初等函数在定义区间内必连续，因此考研题型只研究两类特殊点的间断性（即“找函数间断点”题型中所谓的“可疑点”）</p>
<ul>
<li>函数无定义点：这种点必定为间断点，主要谈论其间断点类型</li>
<li>分段函数的分段点：可能是连续点也可能是间断点，主要判断其是否连续</li>
</ul>
<p>间断点的定义都是在函数f(x)在点x<del>0</del>的某<code>去心邻域有定义</code>，即f(x)在点x<del>0</del>的左右两侧均有定义（对于某些只有在x<del>0</del>某一侧f(x)才有定义的情况不讨论间断点，即不讨论区间端点是否间断）</p>
<p><img src="/images/image-20230809094350374.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>第一类间断点只有：可去间断点(不满足极限值等于函数值)，跳跃间断点(x<del>0</del>点左极限值不等于右极限值) – 极限值均存在</p>
<p>第二类间断点包含：无穷间断点，振荡间断点 – 极限值均不存在</p>
</blockquote>
<h3 id="2-3-可导-amp-连续-amp-可积"><a href="#2-3-可导-amp-连续-amp-可积" class="headerlink" title="2.3 可导&amp;连续&amp;可积"></a>2.3 可导&amp;连续&amp;可积</h3><p>下面是总结的四者之间的关系<br>$$<br>可微&#x3D;可导&gt;&#x3D;连续&gt;&#x3D;可积<br>$$</p>
<ul>
<li>可导必定连续，连续不一定可导（光滑必定一笔画，但一笔画不一定光滑）；</li>
<li>可微和可导等价；</li>
<li>可积不一定连续，连续必定可积；</li>
</ul>
<h2 id="3-未定式极限计算"><a href="#3-未定式极限计算" class="headerlink" title="3.未定式极限计算*"></a>3.未定式极限计算*</h2><blockquote>
<ul>
<li>未定式表示其极限可能存在可能不存在，需要通过计算来判断，除了下面七种未定式，其他非未定式要么极限一定存在要么极限一定不存在。对于非未定式，直接硬算就行，没什么难度；</li>
<li>这里仅仅只是提供一个解决大部分未定式极限计算的方法，不能保证对所有的未定式的极限计算都有用（数学最重要的是掌握知识点的核心而不是硬背解题模板）</li>
</ul>
</blockquote>
<p><img src="/images/image-20230222213027307.png" srcset="/img/loading.gif" lazyload alt="七种未定式"></p>
<p>主要分为三个步骤：</p>
<ol>
<li><p>判断是上述哪种未定式</p>
<ul>
<li>前三个未定式是最经典的，可以直接使用洛必达法则进行计算（使用洛必达之前适当进行化简） – 对于0·∞类型的，选择谁作为分母应该选择求导之后较简单的那一项，避免导致洛必达后计算复杂</li>
<li>对于∞-∞型的通常都要都要将其变为除法解决<ul>
<li>有分母则通分，没有分母则创造分母（倒代换、构造分母）</li>
</ul>
</li>
<li>对于∞^0^或0^0^这两种未定式，使用恒等变形<img src="/images/image-20230223152022330.png" srcset="/img/loading.gif" lazyload></li>
<li>对于1^∞^类型，如果limu^v^属于1^∞^型，有<img src="/images/image-20230223153536961.png" srcset="/img/loading.gif" lazyload>（该结论使用第二重要极限公式推导，当然对于某些1^∞^类型使用上述对数处理也能解出来，哪个方便用哪个)</li>
</ul>
</li>
<li><p>化简：</p>
<ul>
<li><p>化简首选等价无穷小替换（无穷小公式是可以广义替换的，不要只局限于已知的无穷小公式），等价无穷小替换注意使用条件 – 只能用于乘除法</p>
</li>
<li><p>恒等变形（加减同乘除、换元甚至高级定理等）</p>
<ul>
<li>见根号差【根号-&#x2F;+根号】，用有理化（实际上【根号+&#x2F;-非根号】也常用根号差有理化，不要管这个根号差是在分母还是分子） – 根号有理化不一定有用，但是提供了一种思想可用于尝试</li>
<li>一般普通换元需要注意，如果有x-&gt;-∞，一定要用t&#x3D;-x或t&#x3D;-1&#x2F;x换元才能将负号处理掉进入根号（这是一个极其关键点的考点）</li>
<li>换元还包括高级换元，诸如令xt&#x3D;u(认为x是常数)以解决如<img src="/images/image-20230809095734949.png" srcset="/img/loading.gif" lazyload>这种非定积分也非变限积分的积分问题</li>
<li>更多恒等变形的方法参考[恒等变形](# 3.1 恒等变形)；</li>
</ul>
</li>
<li><p>及时提出极限存在且不为0的因式（重要）</p>
</li>
</ul>
</li>
<li><p>计算（包括极限运算规则、夹逼准则、洛必达法则、泰勒公式、归结原则等） </p>
<ul>
<li>洛必达法则是最简单也是最容易想到的，需要注意使用条件 – 必须是0&#x2F;0或者∞&#x2F;∞型，且分子分母均可导，并且导函数的极限存在（广义存在，0,c或∞）</li>
<li>如果原式根本无法化简或f(x)可导性未知(如数列{x<del>n</del>}就根本不能求导)，使用泰勒公式、幂次相消(常用于∞&#x2F;∞的情况)等计算</li>
<li>常规求极限的方法无法使用的时候(比如求解[∞]的极限或证抽象函数的极限是否存在)，使用夹逼准则(求极限)或单调有界准则(证极限存在)<ul>
<li>夹逼准则无需证明左右等号，结合常用不等式常考</li>
<li>单调有界准则：单调有界必有极限。若当x-&gt;+∞时，f(x)单调增加&#x2F;减少，且f(x)有上界&#x2F;下界，则limf(x)存在</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-1-恒等变形"><a href="#3-1-恒等变形" class="headerlink" title="3.1 恒等变形"></a>3.1 恒等变形</h3><p><img src="/images/image-20230808195953484.png" srcset="/img/loading.gif" lazyload></p>
<p>上述定理中的N-L公式、拉格朗日以及对变限积分(上限为x+a下限为x)求导得f(x+a)-f(x)这三个工具是高数中常用的解决两个函数相减的工具</p>
<p><img src="/images/image-20230809162604941.png" srcset="/img/loading.gif" lazyload></p>
<p>当然某些时候不会显式给出两个函数相减的形式，此时可以手动构造</p>
<p><img src="/images/image-20230809162900536.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="四、一元函数微分学"><a href="#四、一元函数微分学" class="headerlink" title="四、一元函数微分学"></a>四、一元函数微分学</h1><h2 id="1-导数定义-不去心"><a href="#1-导数定义-不去心" class="headerlink" title="1.导数定义(不去心)"></a>1.导数定义(不去心)</h2><p>不去心指的是函数f(x)在点x<del>0</del>的某个邻域内有定义(函数在某点有定义即，函数在该点不为无穷大或不是无解，而是有限值)，该邻域是包含x<del>0</del>的</p>
<p><img src="/images/image-20230224144020734.png" srcset="/img/loading.gif" lazyload></p>
<p>上述导数的定义给出了极限和在某点极限形式的导数之间的转换关系，在某些情况下可以使用该公式适当进行转换；</p>
<p>需要注意的是，上述定义中分子和分母中的h的符号应当保持一致，同为正或同为负（从曲线斜率上来理解）</p>
<blockquote>
<p>结论1：函数f(x)在点x<del>0</del>处可导的<code>充要条件</code>是左导数和右导数存在且相等；</p>
<ul>
<li>更常见的说法是，函数f(x)在x<del>0</del>可导的<code>充要条件</code>是导函数在该点的左右极限存在且相等(注意是导函数而非原函数的左右极限)，且该点的导数值等于该极限值；</li>
<li>当使用求导公式遇到无定义点，并不能说明函数f(x)在该点不可导，此时使用导数的基本定义进行判断和求解（求导公式的成立条件是基于函数可导，但求导公式不成立不能反推函数不可导）</li>
</ul>
<p>结论2：函数在某点可导在该点必定连续（这表明函数的间断点一定是不可导点），反之函数在某点连续不一定在该点可导（光滑一定一笔画，一笔画不一定光滑）；</p>
<p>结论3：图像光滑但并不可导的特例是y&#x3D;x^1&#x2F;3^，其图像如下<img src="/images/image-20230224144954320.png" srcset="/img/loading.gif" lazyload>，因此说可导的图像光滑，额外的，图像某点的切线不能垂直于x轴</p>
<p>结论4：</p>
<ul>
<li>若函数f(x)在开区间I内的每个点上都可导，则称函数在I内可导，对应的f’(x)称为导函数；</li>
<li>若函数f(x)在开区间(a,b)内的每个点上都可导，且在x&#x3D;a处存在右导数，在x&#x3D;b处存在左导数，则称函数在区间[a,b]上可导；</li>
</ul>
<p>结论5：若f(x)在[a,b]上可导则f(x)在[a,b]上连续，进而f(x)在[a,b]上必定存在最大值和最小值</p>
<ul>
<li>若f(x)在x&#x3D;a处取得最大值则x&#x3D;a的右导数小于等于0，若取得最小值则在x&#x3D;a处的右导数大于等于0（由函数极限的保号性推得）</li>
<li>若f(x)在x&#x3D;b处取得最大值则x&#x3D;b的左导数大于等于0，若取得最小值则在x&#x3D;b的左导数小于等于0</li>
<li>若f(x)在(a,b)内取得最值，则必有f’(c)&#x3D;0（费马定理）</li>
</ul>
<p>结论6：只有当函数的导数在某个区间连续的时候才能将x&#x3D;x<del>0</del>代入导函数求得f’(x<del>0</del>)，否则只能用函数在某点的导数定义求解f’(x<del>0</del>)</p>
</blockquote>
<p>导数的几何意义：f(x)在点x<del>0</del>处的导数值f’(x<del>0</del>)就是曲线f(x)在点(x<del>0</del>,y<del>0</del>)处切线的斜率；</p>
<p>高阶导数的定义<img src="/images/image-20230224145225200.png" srcset="/img/loading.gif" lazyload></p>
<p>需要注意的是，函数f(x)与其绝对值|f(x)|之间的可导关系也常常出题，下面四个结论在解题时可直接使用（比如题干说|f(x)|有两个不可导点，可以直接转换为寻找f(x)的两个使得f’(x)!&#x3D;0的零点问题）</p>
<p><img src="/images/image-20230812091952567.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-微分定义-不去心"><a href="#2-微分定义-不去心" class="headerlink" title="2.微分定义(不去心)"></a>2.微分定义(不去心)</h2><p><img src="/images/image-20230224145326197.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>可微的几何意义：若f(x)在x<del>0</del>可微，则在曲线上的点(x<del>0</del>,y<del>0</del>)附近可以使用一段切线来近似代替这段曲线；</p>
</li>
<li><p>微分的数学意义：即根据已知的Δx&#x3D;dx，使用dy来近似求解Δy，误差为o(dy)（或o(Δx)，这两种都是正确的！！！）</p>
<ul>
<li><p>dy&#x3D;f’(x<del>0</del>)·Δx&#x3D;f’(x<del>0</del>)·dx – <code>函数的微分是函数增量的线性主部</code></p>
</li>
<li><p>Δy&#x3D;f(x<del>0</del>+Δx)-f(x<del>0</del>)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>结论1：函数在某点可微的<code>充要条件</code>是函数在该点可导（因此某些判定函数在某点是否可微的题目可以转换为判定在该点是否可导）；</p>
<p>结论2：函数的导数等于函数变量微分dy和自变量微分dx的比值，故导数也称为微商；</p>
</blockquote>
<p>另一种判断一元函数是否可微的主要步骤如下（不转换为判断可导，直接判断是否可微）</p>
<p><img src="/images/image-20230315215726816.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>结论3：在函数微分定义中的dx实际上并不是单纯的特指一次方的x(但是Δx中的x是特指一次方的x)，而是针对f(x)来说的，也就是说这个x实际上是有泛化意义的，即广义上的函数微分定义如下<br>$$<br>d[f(狗)]&#x3D;f’(狗)d(狗)<br>$$</p>
</blockquote>
<h2 id="3-导数与微分的计算"><a href="#3-导数与微分的计算" class="headerlink" title="3.导数与微分的计算"></a>3.导数与微分的计算</h2><p>求解函数在某点的导数值主要有两种思路，一是“函数在某点的导数值等于其左右导数在该点的极限值”，二是“直接求解导函数f’(x)再代入x&#x3D;x<del>0</del>求解”</p>
<h3 id="3-1-四则运算"><a href="#3-1-四则运算" class="headerlink" title="3.1 四则运算"></a>3.1 四则运算</h3><p>前提是下面的基本函数都可导，理论依据是可导函数的和、差、积、商等都可导</p>
<p><img src="/images/image-20230224151521766.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p><img src="/images/image-20230224151552487.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p><img src="/images/image-20230224151608968.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>求导要说明是针对哪个变量进行求导，而求微分是针对所有的变量求微分；</li>
</ul>
</blockquote>
<p>四则运算部分的题型一般考察将代求导函数f(x)拆分为多个可导函数的四则运算，下面这道例题是典型的考察题型（注意其中处理连乘的方法）</p>
<p><img src="/images/image-20230812092548341.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-特殊函数求导"><a href="#3-2-特殊函数求导" class="headerlink" title="3.2 特殊函数求导"></a>3.2 特殊函数求导</h3><p>在介绍特殊函数求导之前先介绍两个针对复杂表达式求导的常用手段：</p>
<ul>
<li>对数求导法：对于多项相乘、相除、开方、乘方的式子，一般先取对数再求导，需要注意取对数的步骤是先等式两边加绝对值后再取对数，得ln|y|&#x3D;ln|f(x)|（如果多项式可以确定一定大于0则可以不加绝对值，加绝对值是为了避免某些负数的情况下出错）</li>
<li>幂指函数求导法：对于u(x)^v(x)^这种形式的，除了可以适用对数求导法也可以先化为指数函数再对x求导（这种情况下就必须保证u(x)&gt;0才可以）</li>
</ul>
<h4 id="3-2-1-分段函数"><a href="#3-2-1-分段函数" class="headerlink" title="3.2.1 分段函数"></a>3.2.1 分段函数</h4><ul>
<li>在非分段点用求导公式求导（公式法）</li>
<li>在分段点用导数定义求导（定义法）</li>
</ul>
<p>一般分段函数(绝对值函数也是分段函数需要注意)求导的题型都会先让学生根据题干所给条件求出分段函数g(x)的具体表达式，然后再对g(x)进行求导</p>
<h4 id="3-2-2-复合函数"><a href="#3-2-2-复合函数" class="headerlink" title="3.2.2 复合函数"></a>3.2.2 复合函数</h4><p>洋葱法则：从函数最外层到最内层依次求导，不需要使用链式法则的中间变量</p>
<p><img src="/images/image-20230812160356940.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>有些复杂函数不能简单的看作洋葱求导（因为硬求是求不出来的），如y&#x3D;x^x^或y&#x3D;x^根号2^<code>*</code>(x+3)^4^&#x2F;(1-x)^2^（连乘除函数），需要化为y&#x3D;x^x^&#x3D;e^xlnx^或lny&#x3D;ln(x^根号2^<code>*</code>(x+3)^4^&#x2F;(1-x)^2^)</li>
<li>额外的，需要注意求导符号的位置</li>
</ul>
<p><img src="/images/image-20230812160511596.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>这里介绍几个比较有特点的题型</p>
<p><img src="/images/image-20230325105441563.png" srcset="/img/loading.gif" lazyload alt="例题_1"></p>
<ul>
<li>这道题是典型的复合函数求导，需要注意f是关于(x+y)一个变量的函数，F是关于x,y,z三个变量的函数；</li>
<li>另外一点，遇到这种有多个变量的情况，并且题干中并没有明确说明y和x之间是否存在关系时，我们认为所有的变量都是相关的，也就是在进行求导或者求微分的操作的时候均考虑（这样就算之后题目中说到了两个变量之间是独立的，也可以使用dy&#x2F;dx&#x3D;0确保最后的通式仍然正确）<ul>
<li>为什么y和x无关时，y对x的导数是0？因为导数的几何意义是函数在某点的变化率，而如果y和x无关也就意味着y不会随着x的变化而变化，即变化率是0，因此y对x的导数是0；</li>
</ul>
</li>
</ul>
<h4 id="3-2-3-反函数"><a href="#3-2-3-反函数" class="headerlink" title="3.2.3 反函数"></a>3.2.3 反函数</h4><p><img src="/images/image-20230709101403227.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>反函数的导数dx&#x2F;dy等于直接函数的倒数1&#x2F;(dy&#x2F;dx) – 这里的反函数是x作为因变量y作为自变量！！！</li>
<li>需要注意对谁求导最后表达式要化简为关于谁的式子，这才是反函数求导的考点！！！</li>
</ul>
</blockquote>
<p>另外，反函数二阶导以及自变量和因变量互换的结论都应当记忆以提高解题速度（当然推导过程也应当会，推导过程具有理解意义）</p>
<p><img src="/images/image-20230812162600955.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-2-4-参数方程"><a href="#3-2-4-参数方程" class="headerlink" title="3.2.4 参数方程"></a>3.2.4 参数方程</h4><p><img src="/images/image-20230224152635186.png" srcset="/img/loading.gif" lazyload></p>
<p>二阶参数方程的公式需要掌握推导方法（最好能背下来），很多情况下并不能简单的使用已求解出的一阶导数推出二阶，特别是一阶导数本身就有分式的情况下</p>
<p><img src="/images/image-20230812165718566.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>PS：这种引入中间变量的方法在求解某些导数卡住的时候非常好用，可视为一种解题“利器”</p>
</blockquote>
<h4 id="3-2-5-隐函数"><a href="#3-2-5-隐函数" class="headerlink" title="3.2.5 隐函数"></a>3.2.5 隐函数</h4><p>隐函数是指y不能表达成关于x的式子，主要有三种求导方法（一般情况下这三种方法都可以互相替换，但最好根据具体的情况选择最合适的方法）</p>
<ul>
<li>直接求导法：直接等式两边同时对x求导即可，这种情况下需要注意y是x的函数</li>
<li>全微分形式不变：说白了就是简单的复合函数求导公式推导而来的微分公式，这种情况下x和y互不纠缠（但注意不能视作常数）</li>
</ul>
<p><img src="/images/image-20230812161331388.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>隐函数存在定理：详情参考[隐函数存在定理](# 2.2 隐函数存在定理)，这种情况下对x求偏导视y为常数，对y求偏导视x为常数</li>
</ul>
<p><img src="/images/image-20230812161616407.png" srcset="/img/loading.gif" lazyload></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>适用情况</th>
</tr>
</thead>
<tbody><tr>
<td>直接法</td>
<td>因为二阶导不具备微分形式不变和所谓的公式，故求解隐函数的二阶导只能用直接法（隐函数方程两边关于x连续求导两次）</td>
</tr>
<tr>
<td>公式法</td>
<td>一般在有x^y^和y^x^这种自变量和因变量互相纠缠的情况下选择公式法隔离x和y，而适用全微分需要借助对数工具适当变形，至于针对这种形式的隐函数直接求导几乎是不可能的（太难理解很容易出错）</td>
</tr>
<tr>
<td>全微分</td>
<td>全微分是最容易理解也是计算速度最快准确率最高的方式，能用的情况下尽量都选择全微分</td>
</tr>
</tbody></table>
<h4 id="3-2-6-高阶导数"><a href="#3-2-6-高阶导数" class="headerlink" title="3.2.6 高阶导数"></a>3.2.6 高阶导数</h4><p>求高阶导数主要有三种方法（这里所说的高阶导数是指n阶导数）</p>
<p>(1)归纳法</p>
<p>从低阶开始求导探索规律得到通式（以下的几个都可以通过找规律导出，做题过程中能找规律就找规律，泰勒公式很复杂的 – 这些公式只是罗列出来推导参考的，别什么都想着背，抓住方法而不是死记硬背！）；</p>
<p><img src="/images/image-20230226084722292.png" srcset="/img/loading.gif" lazyload alt="重要高阶导数"></p>
<p><img src="/images/image-20230226084804275.png" srcset="/img/loading.gif" lazyload alt="重要高阶导数"></p>
<p>(2)高阶求导公式</p>
<p><img src="/images/image-20230224154139664.png" srcset="/img/loading.gif" lazyload></p>
<p>上述式子就是莱布尼兹公式，其中u^(0)^&#x3D;u，v^(0)^&#x3D;v，一般两个函数乘积的高阶导数直接使用莱布尼兹公式；</p>
<p>(3)和函数展开(泰勒展开，其实两者有一些细微的区别，将在之后讨论，此处忽略这种差异)</p>
<ul>
<li>f(x)的零次导等于其本身；</li>
<li>任何一个无穷阶可导的函数f(x)在收敛的条件下都可以写成（此处的x<del>0</del>常常取值为0）</li>
</ul>
<p><img src="/images/image-20230224154520416-16773730440404.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>利用已知的泰勒公式将题目所给的f(x)展开成幂级数</li>
</ul>
<p>常用泰勒公式如下（这里展示的实际是麦克劳林展开，即x<del>0</del>&#x3D;0时的泰勒展开，因为高阶导数比对的时候不需要高阶无穷小所以省略了最后的高阶无穷小）</p>
<p><img src="/images/image-20230224154613486.png" srcset="/img/loading.gif" lazyload></p>
<p>还有两个重要的泰勒公式</p>
<p><img src="/images/image-20230224154706154.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>根据函数展开式的唯一性，比较两个式子的n次方的系数即可得到f^(n)^(x<del>0</del>)或f^(n)^(0)；</li>
</ul>
<blockquote>
<p>使用泰勒展开的题目有很明显的特征，即规定求解函数f(x)在x<del>0</del>处的n阶导数才能使用，如果直接让求解f(x)的n阶导数泰勒展开是不能用的（这与泰勒展开的本质有关）</p>
</blockquote>
<h4 id="3-2-7-变限积分"><a href="#3-2-7-变限积分" class="headerlink" title="3.2.7 变限积分"></a>3.2.7 变限积分</h4><p><img src="/images/image-20230224155244421.png" srcset="/img/loading.gif" lazyload></p>
<p>求导变量x只出现在积分的上下限时才能使用上述公式，如果x出现在被积函数中则必须通过恒等变形（一般是换元）将其移出被积函数才能使用上述公式；</p>
<h3 id="3-3-基本求导公式"><a href="#3-3-基本求导公式" class="headerlink" title="3.3 基本求导公式*"></a>3.3 基本求导公式*</h3><p><img src="/images/image-20230812160254439.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<blockquote>
<p>Q：为什么1&#x2F;x的不定积分是ln|x|+C带绝对值？</p>
</blockquote>
<p>A：<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/428558165.html">X分之一的不定积分为什么是ln x的绝对值，通俗易懂点_百度知道 (baidu.com)</a>；</p>
<p>补充说明一点，<code>|1/x|的不定积分</code>需要分情况讨论，当x&gt;0时不定积分为ln|x|+C<del>1</del>，当x&lt;0时不定积分为-ln|x|+C<del>2</del>；</p>
<hr>
<h1 id="五、一元函数微分学的几何应用"><a href="#五、一元函数微分学的几何应用" class="headerlink" title="五、一元函数微分学的几何应用"></a>五、一元函数微分学的几何应用</h1><h2 id="1-极值与最值"><a href="#1-极值与最值" class="headerlink" title="1.极值与最值"></a>1.极值与最值</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><h4 id="1-1-1-极值的定义"><a href="#1-1-1-极值的定义" class="headerlink" title="1.1.1 极值的定义"></a>1.1.1 极值的定义</h4><p>极值：邻域内的最值</p>
<blockquote>
<p>更准确的定义极值，分为广义极值和真正极值</p>
<p><img src="/images/image-20230619203315315.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>注意：无论是广义还是真正定义，都要求f(x)在点x<del>0</del>的某个邻域内有定义</p>
<h4 id="1-1-2-最值的定义"><a href="#1-1-2-最值的定义" class="headerlink" title="1.1.2 最值的定义"></a>1.1.2 最值的定义</h4><p>最值：整个定义域上的最值</p>
<blockquote>
<p>更准确的定义最值，分为广义最值和真正最值</p>
<p><img src="/images/image-20230619203519832.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>注意：一般来说在真正极值和真正最值是教材中对极值和最值最常见的定义，此处给出广义定义和真正定义目的是为了提醒读者不要理所当然的认为这两个值只有一种定义；</p>
<h4 id="1-1-3-相关结论"><a href="#1-1-3-相关结论" class="headerlink" title="1.1.3 相关结论"></a>1.1.3 相关结论</h4><ul>
<li><p>结论1：极值不唯一，但极大值不一定大于极小值</p>
</li>
<li><p>结论2：最值唯一，但最值点不唯一</p>
</li>
<li><p>结论3：极值点不一定是最值点，最值点也不一定是极值点（如果f(x)在区间I上的最值点x<del>0</del>不是区间I的端点而是I内部的点，则该最值点一定是一个极值点）</p>
</li>
</ul>
<hr>
<blockquote>
<p>Q_1：为什么最值点不一定是极值点？</p>
</blockquote>
<p>A：<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1889505005262102668.html">函数的最值点是不是极值点？？？_百度知道 (baidu.com)</a></p>
<p>要注意一点，常说的无极值指的是既无极小值也无极大值，因此在验证函数在某个区间无极值的时候需要同时考虑这两方面；</p>
<p>举例说明，y&#x3D;f(x)&#x3D;x，如果定义在[0,1]上，其最大值点是1，但x&#x3D;1不是y&#x3D;x的极大值点。因为x&#x3D;1根本就不存在有定义的邻域使得f(x)&lt;&#x3D;f(1)，x&#x3D;1的右半邻域已经超出了f(x)的定义域。不考虑x&#x3D;1这个点，那么对于[0,1)上的任意x<del>0</del>，无论U(x<del>0</del>)取值多小都不可能满足总有f(x)&lt;&#x3D;f(x<del>0</del>)因为f(x)本身就是一个单调增的函数。由此可见f(x)在[0,1]上不存在极大值点，亦不存在极小值点，因此f(x)在[0,1]上不存在极值；</p>
<p>而极值点不一定是最值点很好理解此处不再赘述；</p>
<blockquote>
<p>Q_2：间断点可以是极值点吗？</p>
</blockquote>
<p>A：当然可以，因为极值点考虑的是邻域（或者去心邻域）内的点的函数值与该点函数值的大小关系（言外之意就是和函数的连续没有关系），下面几个例子证明了间断点可以是极值点</p>
<p><img src="/images/image-20230226093808213.png" srcset="/img/loading.gif" lazyload alt="例子"></p>
<h2 id="2-单调性与极值点"><a href="#2-单调性与极值点" class="headerlink" title="2.单调性与极值点"></a>2.单调性与极值点</h2><h3 id="2-1-单调性-一阶导数"><a href="#2-1-单调性-一阶导数" class="headerlink" title="2.1 单调性(一阶导数)"></a>2.1 单调性(一阶导数)</h3><p>使用导数判断函数的单调性是一种方式</p>
<ul>
<li>若f(x)在区间I上有f’(x)&gt;0则f(x)在I上严格单调增加；</li>
<li>若f(x)在区间I上有f’(x)&lt;0则f(x)在I上严格单调减少；</li>
</ul>
<p>另一种常见的方式是函数值做差判断，详情参考[单调性](# 1.1.1 单调性)</p>
<h3 id="2-2-极值点"><a href="#2-2-极值点" class="headerlink" title="2.2 极值点"></a>2.2 极值点</h3><h4 id="2-2-1-必要条件"><a href="#2-2-1-必要条件" class="headerlink" title="2.2.1 必要条件"></a>2.2.1 必要条件</h4><p>函数在某点取得极值的时候有什么性质？</p>
<blockquote>
<p>必要条件：若f(x)在x&#x3D;x<del>0</del>可导（大前提），f’(x<del>0</del>)&#x3D;0是f(x)在x<del>0</del>取得极值的必要条件；（即当在x<del>0</del>点取得极值的时候必然有f’(x<del>0</del>)&#x3D;0，反之不一定成立）</p>
</blockquote>
<p>PS：对于不可导的点不能根据这个必要条件的逆否命题判断不可导点不是极值点，这是一大陷阱；</p>
<h4 id="2-2-2-充分条件"><a href="#2-2-2-充分条件" class="headerlink" title="2.2.2 充分条件"></a>2.2.2 充分条件</h4><p>如何判断函数在驻点或不可导点是否可以取得极值（换句话说就是如何判断驻点或不可导点就是极值点）？这里给出判断函数极值点的三个充分条件</p>
<blockquote>
<ul>
<li><p>第一充分条件：若f(x)在x<del>0</del>连续且在x<del>0</del>的<code>某去心邻域可导</code>(一阶可导简称可导)，则f’(x)在x<del>0</del>的左右邻域变号是f(x)在x<del>0</del>取得极值的第一充分条件；</p>
</li>
<li><p>第二充分条件：若f(x)在x<del>0</del>处二阶可导且f’’(x<del>0</del>)!&#x3D;0，则f’(x<del>0</del>)&#x3D;0是f(x)在x<del>0</del>取得极值的第二充分条件，且</p>
<ul>
<li>当f’’(x<del>0</del>)&lt;0，x<del>0</del>为极大值点</li>
<li>当f’’(x<del>0</del>)&gt;0，x<del>0</del>为极小值点</li>
<li>当f’’(x<del>0</del>)&#x3D;0无法使用第二充分条件判断</li>
</ul>
</li>
<li><p>由上述第二充分条件可以推导出第三充分条件（不常用）</p>
<p><img src="/images/image-20230619204222785.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</blockquote>
<p>第一充分条件和第二充分条件非常好理解。</p>
<p>第一充分条件因为其使用条件是x<del>0</del>的某去心邻域，因此可以用于判断不可导点是否是极值点。</p>
<p>第二充分条件只能用于f(x)在x<del>0</del>该点可导的情况，因为二阶可导必须基于一阶可导。</p>
<h2 id="3-凹凸性与拐点"><a href="#3-凹凸性与拐点" class="headerlink" title="3.凹凸性与拐点"></a>3.凹凸性与拐点</h2><h3 id="3-1-凹凸性-二阶导数"><a href="#3-1-凹凸性-二阶导数" class="headerlink" title="3.1 凹凸性(二阶导数)"></a>3.1 凹凸性(二阶导数)</h3><p><img src="/images/image-20230226104912820.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>判别：若函数f(x)在I上二阶可导</p>
<ul>
<li>若在I上f’’(x)&gt;0则f(x)在I上的图形是凹；</li>
<li>若在I上f’’(x)&lt;0则f(x)在I上的图形是凸；</li>
</ul>
</blockquote>
<h3 id="3-2-拐点"><a href="#3-2-拐点" class="headerlink" title="3.2 拐点"></a>3.2 拐点</h3><p>连续曲线的凹弧与凸弧的分界点称为该曲线的拐点；</p>
<blockquote>
<p>易混概念：</p>
<ul>
<li>驻点是一阶导数为0的x的<code>值</code>x<del>0</del></li>
<li>拐点是二阶导数为0的<code>坐标</code>(x<del>0</del>,f(x<del>0</del>))（这么说不准确，因为二阶导数值为0只是拐点的必要条件）</li>
<li>零点、驻点、极值点都是x的值，拐点是坐标</li>
</ul>
</blockquote>
<h4 id="3-2-1-必要条件"><a href="#3-2-1-必要条件" class="headerlink" title="3.2.1 必要条件"></a>3.2.1 必要条件</h4><blockquote>
<p>必要条件：当二阶导数存在时（大前提），函数的二阶可导点是拐点的必要条件（即拐点可以推出该点的二阶导数值为0 – 对于不存在二阶导数的点不能用该结论确定该点不是拐点）</p>
</blockquote>
<h4 id="3-2-2-充分条件"><a href="#3-2-2-充分条件" class="headerlink" title="3.2.2 充分条件"></a>3.2.2 充分条件</h4><blockquote>
<p>第一充分条件：若f(x)在x<del>0</del>连续且在x<del>0</del>的<code>某去心邻域内存在二阶导数</code>，则f’’(x)在x<del>0</del>左右邻域变号是拐点的充分条件（如果二阶导数根本不存在，不能使用这个判断，如y&#x3D;x^1&#x2F;3^）</p>
<p>第二充分条件：若f(x)在x<del>0</del>点的<code>某邻域内三阶可导</code>，则f’’(x<del>0</del>)&#x3D;0且f’’’(x<del>0</del>)！&#x3D;0则(x<del>0</del>,f(x<del>0</del>))为拐点</p>
<ul>
<li>当f’’’(x<del>0</del>)&#x3D;0时无法用第二充分条件判断</li>
</ul>
<p>与极值点类似的，可以由第二充分条件推导出第三充分条件</p>
<p><img src="/images/image-20230226110441791.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="3-3-极值点-amp-最值点-amp-拐点的判断"><a href="#3-3-极值点-amp-最值点-amp-拐点的判断" class="headerlink" title="3.3 极值点&amp;最值点&amp;拐点的判断"></a>3.3 极值点&amp;最值点&amp;拐点的判断</h3><p>前面的理论性知识比较多，下面直接例举出在解题时如何快速判断处极值点、最值点以及拐点。在此之前先介绍不可导点这一概念</p>
<blockquote>
<p>不可导点：不可导点也就是左导数的值不等于右导数的值的点。简单来说，初等函数在其定义域内均可导。因此判断不可导点时考虑<code>分段函数的分段点</code>、<code>定义域的端点</code>以及<code>函数间断点</code>（具体问题具体分析）</p>
</blockquote>
<h4 id="3-3-1-最值的计算"><a href="#3-3-1-最值的计算" class="headerlink" title="3.3.1 最值的计算"></a>3.3.1 最值的计算</h4><ul>
<li>求闭区间上的连续函数的最大值和最小值<ul>
<li>计算f(x)在定义域内所有的驻点和不可导点以及端点的值，比较并确定范围</li>
</ul>
</li>
<li>求开区间上的连续函数的最大值和最小值（这类问题可能没有最值）<ul>
<li>计算f(x)在定义域内所有的驻点和不可导点的值，还有<code>左端点的右极限值A和右端点的左极限值B</code>，比较并确定范围</li>
</ul>
</li>
</ul>
<h4 id="3-3-2-极值点的计算"><a href="#3-3-2-极值点的计算" class="headerlink" title="3.3.2 极值点的计算"></a>3.3.2 极值点的计算</h4><p>理论依据</p>
<p><img src="/images/image-20230709151218213.png" srcset="/img/loading.gif" lazyload></p>
<p>一阶可导点的导数值为0（驻点）不一定表示该点为极值点（必要条件），比如<img src="/images/image-20230709151555319.png" srcset="/img/loading.gif" lazyload>这条直线上的所有点的一阶导都为0，但很明显每个点都不是极值点；</p>
<h4 id="3-3-3-拐点的计算"><a href="#3-3-3-拐点的计算" class="headerlink" title="3.3.3 拐点的计算"></a>3.3.3 拐点的计算</h4><p>理论依据</p>
<p><img src="/images/image-20230709151326001.png" srcset="/img/loading.gif" lazyload></p>
<p>二阶可导点的导数值为0不一定表示该点为拐点（必要条件），比如<img src="/images/image-20230709151639762.png" srcset="/img/loading.gif" lazyload>这条直线上的所有点的二阶导都为0但很明显每个点都不是拐点</p>
<h2 id="4-渐近线"><a href="#4-渐近线" class="headerlink" title="4.渐近线"></a>4.渐近线</h2><h3 id="4-1-铅垂渐近线"><a href="#4-1-铅垂渐近线" class="headerlink" title="4.1 铅垂渐近线"></a>4.1 铅垂渐近线</h3><p>若</p>
<p><img src="/images/image-20230620102331953.png" srcset="/img/loading.gif" lazyload></p>
<p>上述两个等式满足其一则表示x&#x3D;c是f(x)的一条垂直渐近线；</p>
<blockquote>
<p>此处的c要么是函数的无定义点，要么是函数定义区间的端点或分段函数的分段点</p>
</blockquote>
<h3 id="4-2-水平渐近线"><a href="#4-2-水平渐近线" class="headerlink" title="4.2 水平渐近线"></a>4.2 水平渐近线</h3><p>若满足</p>
<p><img src="/images/image-20230620102539112.png" srcset="/img/loading.gif" lazyload></p>
<p>上述三个等式中的任何一个，则表示b’或b是f(x)的一条水平渐近线；</p>
<h3 id="4-3-斜渐近线"><a href="#4-3-斜渐近线" class="headerlink" title="4.3 斜渐近线"></a>4.3 斜渐近线</h3><p>若满足下面两种情况之一（实际上还有第三种情况就是无论趋于正无穷还是负无穷也就是趋于∞，斜率和截距的计算值各自相等）</p>
<p><img src="/images/image-20230620102649465.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-4-渐近线的求解"><a href="#4-4-渐近线的求解" class="headerlink" title="4.4 渐近线的求解"></a>4.4 渐近线的求解</h3><blockquote>
<p>在求解渐近线的题目中我们不需要提前判断渐近线是否存在，直接上手计算，如果计算不出相应的结果那么相应的渐近线就不存在</p>
<ul>
<li>关于铅锤渐近线，x-&gt;c^+^或x-&gt;c^-^中的c点一般是无定义的点，所以在求铅锤渐近线的题目中我们可以直接找特殊的点（如求y&#x3D;1&#x2F;x+ln(1+e^x^)的铅锤渐近线我们可以直接计算limx-&gt;0^+^f(x)的值是否是无穷）</li>
<li>求解水平渐近线是最简单的，只需要把x分别趋于+∞和-∞计算得到的就是水平渐近线的表达式</li>
<li>关于斜渐近线中a、b的计算方式（无脑代入x-&gt;+∞&#x2F;-∞，先求解a再求解b）</li>
</ul>
<p><img src="/images/image-20230226112110604.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="5-函数作图"><a href="#5-函数作图" class="headerlink" title="5.函数作图"></a>5.函数作图</h2><p>函数作图的基本步骤如下：</p>
<ol>
<li>确定函数的定义域并考虑函数在区间上是否具备对称性；</li>
<li>分别用一阶导数和二阶倒是确定函数的单调性、凹凸性以及极值点、拐点</li>
<li>若函数有渐近线，确定函数的渐近线</li>
</ol>
<p>我们直接给出一道例题帮助理解</p>
<ol>
<li><p>首先确定函数的定义域<img src="/images/image-20230226165735840.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>接着求出所有的一阶导数为0的点（驻点）、一阶不可导点，确定函数在各个子区间上的单调性和极值点<img src="/images/image-20230226165755377.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>然后求出所有的二阶导数为0的点、二阶不可导点，确定函数在各个子区间上的凹凸性和拐点<img src="/images/image-20230226165824689.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>最后确定函数的渐近线（可能不存在某条渐近线，但最好都计算一下）</p>
<p><img src="/images/image-20230620103307826.png" srcset="/img/loading.gif" lazyload></p>
<p>最后做出图形即可</p>
<p><img src="/images/image-20230226170010128.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<hr>
<blockquote>
<p>Q：为什么要求不可导点？</p>
</blockquote>
<p>A：</p>
<ul>
<li><p>不可导点是划分子区间的一个重要端点；</p>
</li>
<li><p>不可导点也可能是极值点或者拐点，但是不能使用第二充分条件判断，因为顺带要求解单调性和凹凸性，所以我们可以先将单调性和凹凸性求解出来之后再进行判断；</p>
</li>
</ul>
<hr>
<h1 id="六、中值定理"><a href="#六、中值定理" class="headerlink" title="六、中值定理*"></a>六、中值定理*</h1><blockquote>
<p>中值定理这一章的几个微分中值定理和函数中值定理中的介值定理尤其重要，这一章的题目一般都非常难，是考研中证明题的核心，需要大量刷题总结；</p>
</blockquote>
<p>中值定理按照研究对象的不同可以分为三类：</p>
<ul>
<li>研究对象为函数f(x)：函数中值定理</li>
<li>研究对象为导函数f’(x)：微分中值定理</li>
<li>研究对象为函数的f(x)的积分：积分中值定理</li>
</ul>
<h2 id="1-微分中值定理"><a href="#1-微分中值定理" class="headerlink" title="1.微分中值定理"></a>1.微分中值定理</h2><h3 id="1-1-柯西中值定理"><a href="#1-1-柯西中值定理" class="headerlink" title="1.1 柯西中值定理"></a>1.1 柯西中值定理</h3><p><img src="/images/image-20230226152322467.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>柯西中值定理的证明不作要求，但一定要注意不能使用两次拉格朗日中值定理来证明柯西中值定理，因为柯西中f’(x)和F’(x)的ξ是同一个值；</li>
<li>柯西中值定理可以看作是无条件使用（F’(x)不为0是因为要作分母）；</li>
<li>柯西中值定理的考点在于题干一般不会给出具体的f(x)和F(x)，一般f(x)和F(x)一个是具体函数（其形式需要仔细侦察才能发现），一个是抽象函数；</li>
</ul>
</blockquote>
<h3 id="1-2-拉格朗日中值定理"><a href="#1-2-拉格朗日中值定理" class="headerlink" title="1.2 拉格朗日中值定理"></a>1.2 拉格朗日中值定理</h3><p><img src="/images/image-20230226152350116.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>拉格朗日中值定理的两个条件都是套话，这意味着拉格朗日定理的适用范围很大（几乎无条件使用）</p>
</blockquote>
<h4 id="1-2-1-应用"><a href="#1-2-1-应用" class="headerlink" title="1.2.1 应用"></a>1.2.1 应用</h4><p>题干中出现<code>f-f</code>或者是<code>复杂类型的导数表达式f&#39;</code>，一般需要使用拉格朗日中值定理，和罗尔中值定理一样，都需要先构造(一般构造的都是变限积分)</p>
<h3 id="1-3-罗尔中值定理"><a href="#1-3-罗尔中值定理" class="headerlink" title="1.3 罗尔中值定理*"></a>1.3 罗尔中值定理*</h3><p>（罗尔中值定理可以由费马定理推导得到，但是罗尔定理的证明不作要求故不介绍）</p>
<p><img src="/images/image-20230226152404915.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>罗尔定理的前两个条件都是套话，关键在于区间端点处的函数值相等，即解题的方向就在于千方百计的验证f(a)&#x3D;f(b)</p>
</blockquote>
<p>关于罗尔定理的推广（无论怎么推广，基本的思想都是<code>端点或端点的单侧极限值相等，在区间中必然存在一点使得在该点的一阶导数为0（斜率为0）</code>）</p>
<p><img src="/images/image-20230226172831957.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-3-1-应用"><a href="#1-3-1-应用" class="headerlink" title="1.3.1 应用"></a>1.3.1 应用</h4><p>罗尔定理在运用中不会明显的给出f(x)，常常需要构造辅助函数F(x)（一般会要求证明一个式子成立，我们根据该式子的特点构造F(x)，用γ∈(a,b)，F’(γ)&#x3D;0证明）；</p>
<p>另一方面，在还原之前先将公式中的ξ还原为x，比如<code>f&#39;(ξ)+αf(ξ)=0</code>先将其还原为<code>f&#39;(x)+αf(x)=0</code>，然后令F(x)&#x3D;f(x)e^αx^即构造完成，之后只需要找到使得函数值相等的两个点F(a)&#x3D;F(b)即可；</p>
<p><img src="/images/image-20230226185940172.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>使用罗尔中值定理证明一阶导数为0只需要一次，但是当要求证明二阶导数为0就需要多次使用罗尔中值定理，考点就在于找到函数值相等的三个不同点f(a)&#x3D;f(b)&#x3D;f(c)</p>
<p><img src="/images/image-20230226191048025.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="1-4-费马中值定理"><a href="#1-4-费马中值定理" class="headerlink" title="1.4 费马中值定理"></a>1.4 费马中值定理</h3><p><img src="/images/image-20230226172245505.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>第一个条件是套话，第二个条件是重点</p>
</blockquote>
<h4 id="1-4-1-证明"><a href="#1-4-1-证明" class="headerlink" title="1.4.1 证明"></a>1.4.1 证明</h4><p>关于费马定理需要掌握它的证明，主要分为两步，分别根据在x<del>0</del>点取得极值（极小值或极小值证明其一即可）且在x<del>0</del>可导（左导数等于右导数）</p>
<p><img src="/images/image-20230226172558431.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-4-2-应用"><a href="#1-4-2-应用" class="headerlink" title="1.4.2 应用"></a>1.4.2 应用</h4><p>在证明开区间(a,b)中某点导数为0的题型中，除了可以构造辅助函数使用罗尔中值定理以外，也可以使用费马定理。使用费马定理只需要指出<code>可导函数的最值在区间内部取得</code>（因为区间内部的最值一定是极值，当然正面求解区间内部的最值点不现实，常规方式是证明两个区间端点不是最值点反推最值点在区间内部），使用费马定理的题型一般带有不等式关系条件</p>
<h3 id="1-5-泰勒中值定理"><a href="#1-5-泰勒中值定理" class="headerlink" title="1.5 泰勒中值定理"></a>1.5 泰勒中值定理</h3><p>泰勒中值定理也称为泰勒公式、泰勒展开（因为其核心就是两个重要公式），泰勒公式的意义在于使用高次多项式来逼近函数f(x)</p>
<p><img src="/images/image-20230226173016214.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-5-1-泰勒中值定理1"><a href="#1-5-1-泰勒中值定理1" class="headerlink" title="1.5.1 泰勒中值定理1"></a>1.5.1 泰勒中值定理1</h4><blockquote>
<p>带拉格朗日余项的n阶泰勒公式定义</p>
<p><img src="/images/image-20230622172046975.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="1-5-2-泰勒中值定理2"><a href="#1-5-2-泰勒中值定理2" class="headerlink" title="1.5.2 泰勒中值定理2"></a>1.5.2 泰勒中值定理2</h4><blockquote>
<p>带佩亚诺余项的n阶泰勒公式</p>
<p><img src="/images/image-20230622172104001.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>考研的要求里不会考察拉格朗日余项和佩亚诺余项的区别，因此这里也不讨论这两种展开式的区别，考试的大多数时候使用的都是佩亚诺余项这点可以注意一下；</p>
<h4 id="1-5-3-麦克劳林展开式"><a href="#1-5-3-麦克劳林展开式" class="headerlink" title="1.5.3 麦克劳林展开式"></a>1.5.3 麦克劳林展开式</h4><p>当x<del>0</del>&#x3D;0时的泰勒公式被称为麦克劳林公式，下面几个是需要记忆的麦克劳林展开式</p>
<p><img src="/images/image-20230226173427236.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<blockquote>
<p>Q：前面已经分别在[函数极限与连续性](# 1.3 泰勒公式)、[一元函数微分学](# 3.2.6 高阶导数)中分别出现过泰勒展开式，那么泰勒展开和和函数展开究竟有什么区别？</p>
</blockquote>
<p>A：这个问题需要在学习了级数之后才能完全解答，这里给出两者在概念上的区别</p>
<p><img src="/images/image-20230709154534529.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="2-函数中值定理"><a href="#2-函数中值定理" class="headerlink" title="2.函数中值定理"></a>2.函数中值定理</h2><p>函数中值定理的前提条件就是f(x)在[a,b]上连续，但是基本上这个条件就是一个套话，题干一般默认给出</p>
<p><img src="/images/image-20230226173536206.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>一般称定理1为最值定理，可以描述为“闭区间的连续函数必定有上下界，且该上下界就是该函数在该区间的最大值和最小值”；</li>
<li>一般最值定理和介值定理联合使用，介值定理中的m和M分别是f(x)在[a,b]上的最小值和最大值 – <code>介值定理是该部分最重要的定理，当题干出现ξ=[a,b]即闭区间则无脑考虑介值定理</code>；</li>
<li>平均值定理不常用，需要注意的就是该定理是由最值定理和介值定理联合使用的典范；</li>
<li>零点定理可以看作是特殊的介值定理，其中的μ&#x3D;0，即端点值异号时必定有m&lt;0&lt;M，因此有f(ξ)&#x3D;μ&#x3D;0（注意端点函数值不能取0，即开区间(a,b)），这个定理在零点问题中常用；</li>
</ul>
</blockquote>
<h3 id="2-1-零点问题"><a href="#2-1-零点问题" class="headerlink" title="2.1 零点问题"></a>2.1 零点问题</h3><p>函数的零点问题也称为方程的根、曲线交点问题，讨论方程根的问题主要有以下两个方法：</p>
<ul>
<li>零点定理：主要用于证明根的<code>存在性</code></li>
<li>单调性：主要用于证明根的<code>唯一性</code></li>
</ul>
<p>额外有两个小工具适合解决解题过程中的某些步骤：</p>
<ul>
<li>罗尔推广：罗尔定理的推论</li>
<li>实系数奇次方程定理：实系数奇次方程至少有一个实根</li>
</ul>
<h4 id="2-1-1-零点定理"><a href="#2-1-1-零点定理" class="headerlink" title="2.1.1 零点定理"></a>2.1.1 零点定理</h4><p><img src="/images/image-20230227100237766.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>零点定理的推广类似于罗尔定理的推广，零点定理的推广主要拓展原始零点定理的闭区间为开区间，同时端点或端点值可以取有限数也可以是无穷大；</p>
</blockquote>
<p>与零点定理非常相似的一个不属于十大定理的“导数零点定理”，它是使用罗尔定理和费马定理推导出来的，其叙述如下</p>
<p><img src="/images/image-20230417225919050.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>千万不能与零点定理混淆，函数f(x)可导必定连续，但是f(x)连续不一定可导；</p>
</blockquote>
<h4 id="2-1-2-单调性"><a href="#2-1-2-单调性" class="headerlink" title="2.1.2 单调性"></a>2.1.2 单调性</h4><p><img src="/images/image-20230227100511165.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>f(x)在(a,b)内单调也可以说是一阶导数f’(x)在区间(a,b)存在且不等于0；</p>
</blockquote>
<h4 id="2-1-3-罗尔推广"><a href="#2-1-3-罗尔推广" class="headerlink" title="2.1.3 罗尔推广"></a>2.1.3 罗尔推广</h4><p>罗尔推广实际上就是罗尔定理的推论</p>
<p><img src="/images/image-20230227100632365.png" srcset="/img/loading.gif" lazyload></p>
<p>用通俗易懂的语言解释就是“导数方程至多有k个根，那么导数阶数降n阶的函数方程，至多有k+n个根”</p>
<blockquote>
<ul>
<li>常见的解题方式是给出f^(n)^(x)!&#x3D;0，那么可以得出f^(n)^(x)&#x3D;0至多0个根，则f(x)&#x3D;0至多n个根；</li>
<li>罗尔推广的逆否命题为“若f(x)&#x3D;0有(高数中的有都表示至少存在)k+n+1个根，则f^(n)^(x)至少有k+1个根”，配合n次多项式至多有n个根可以快速解决某些题；</li>
</ul>
</blockquote>
<h4 id="2-1-4-实系数奇次方程定理"><a href="#2-1-4-实系数奇次方程定理" class="headerlink" title="2.1.4 实系数奇次方程定理"></a>2.1.4 实系数奇次方程定理</h4><blockquote>
<p>Q：什么是实系数奇次方程？</p>
</blockquote>
<p>A：一元整式函数或方程的未知数最高次数就是函数或方程的次数，而这个次数是奇数，就是奇次方程，同时未知数的系数是实数，就是实系数奇次方程；</p>
<p><img src="/images/image-20230227102356646.png" srcset="/img/loading.gif" lazyload alt="任何实系数奇次方程"></p>
<p>下面给出证明“任何实系数奇次方程至少有一个实根”</p>
<p><img src="/images/image-20230227102718283.png" srcset="/img/loading.gif" lazyload></p>
<p>简单理解就是因为实系数奇次方程在x-&gt;+∞和x-&gt;-∞的时候f(x)取值分别是+∞和-∞，根据零点定理可知f(x)图像和y&#x3D;0至少有一个交点；</p>
<h4 id="2-1-5-解题框架"><a href="#2-1-5-解题框架" class="headerlink" title="2.1.5 解题框架"></a>2.1.5 解题框架</h4><p>一般题干会要求求解某个函数的零点个数，解题步骤为（这只是一个一般性的思想，不可能解决所有的问题，解题的时候一定不要局限在框架中跳不出来）：</p>
<ol>
<li><p>分析该函数奇偶性，是否可以将定义域划分讨论；</p>
</li>
<li><p>求解f’(x)的表达式，根据f’(x)与y&#x3D;0的交点个数</p>
<ul>
<li>可以适当用Δ&#x3D;b^2^-4ac判断解的个数；</li>
<li>当已知某部分的f(x)恒大于或者小于0时可以不考虑这部分的单调性，求解定义域剩余部分的f(x)单调性 – 缩小定义域是一种关键手段；</li>
</ul>
</li>
<li><p>根据单调性以及端点值的正负(一般来说不需要算出具体的端点值，只需要判断出其正负即可)可以大致做出定域内f(x)的图像，进而判断f(x)零点的个数；</p>
<ul>
<li>对于求解f’(x)的零点个数的问题适当使用罗尔推论；</li>
<li>一般地，最终结果应当由“至少k个根”和“至多k个根”一起限定得到在定义域上恰好存在k个根</li>
</ul>
</li>
</ol>
<h2 id="3-积分中值定理"><a href="#3-积分中值定理" class="headerlink" title="3.积分中值定理"></a>3.积分中值定理</h2><p>[积分中值定理推广](#7.1.1 中值定理)</p>
<p><img src="/images/image-20230226184810323.png" srcset="/img/loading.gif" lazyload alt="积分中值定理"></p>
<blockquote>
<ul>
<li>上述积分中值定理还能使用拉格朗日证明得到ξ∈(a,b)上该等式仍成立；</li>
<li>积分中值定理是一个非常重要的用于处理复杂&#x2F;抽象积分的定理，我们可以将一些复杂的积分转换为f(ξ)(b-a)的形式（另一种解决复杂积分的手段是将其用变限积分解决）；</li>
<li>积分中值定理与平均值定理完全等价，两者都是使用最值定理+介值定理推导得到，平均值定理可以认为是离散的均值，积分中值定理可以认为是连续的均值；</li>
</ul>
</blockquote>
<h2 id="4-微分不等式"><a href="#4-微分不等式" class="headerlink" title="4.微分不等式"></a>4.微分不等式</h2><blockquote>
<p>Q：为什么叫做微分不等式？是因为题干中的不等式包含微分形式吗？</p>
</blockquote>
<p>A：微分不等式并不意味着待证明的不等式是包含导数或微分的，而是我们在证明某些不等式的时候可以将其转换成f(x)，进而利用的微分&#x2F;导数形式求解；</p>
<hr>
<blockquote>
<p>这一小节和零点问题的求解步骤几乎一致，主要考察两种问题一个是求解零点的个数一个是求解函数与y&#x3D;0的大小关系；</p>
</blockquote>
<p>证明微分不等式主要有以下三种方法：</p>
<ul>
<li><p>函数性态（<code>单调性、凹凸性、极值</code>） – 与零点问题不同的是证明微分不等式几乎都需要求解二阶导数判断凹凸性</p>
</li>
<li><p>常量变量化 – 如果欲证的不等式中都是常量，则可以将其中一个或者几个常量变量化，再利用相关导数工具去证明</p>
<ul>
<li>一般对于复杂的表达式，会将多个常量变量化比如令x&#x3D;λx<del>1</del>+(1-λ)x<del>2</del></li>
</ul>
</li>
<li><p>中值定理（拉格朗日中值定理或泰勒公式）</p>
<ul>
<li>使用中值定理的题型一般都有非常明显的特征，主要思路在于根据等式的项的放缩进而得到不等式关系；</li>
<li>中值定理的使用是有难度的，但是针对某些题只有用中值定理解决，因此这种方法也需要掌握；</li>
</ul>
</li>
</ul>
<h2 id="5-刷题小结"><a href="#5-刷题小结" class="headerlink" title="5.刷题小结"></a>5.刷题小结</h2><p>早在一开始就已经声明这一章难度非常大，除了需要熟练记忆所有的中值定理公式外，还需要掌握一定的能力，做到一看到题就知道应该使用什么定理。下面是刷题时的一些总结，后续还将不断补充。</p>
<p>（1）若题干已知函数f(x)在闭区间[a,b]上连续，则可以直接推出最值定理(基本有界性定理，即连续函数在闭区间必定有界)和介值定理存在，简写为</p>
<p><img src="/images/image-20230709161839869.png" srcset="/img/loading.gif" lazyload alt="介值定理"></p>
<p>这两个定理的使用不需要任何证明，介值定理并不关心最小值m和最大值M是多少，但注意在同一区间上的最小值m和最大值M一定都是唯一的；</p>
<p>与此类似的，如果题干中有“函数f(x)连续且可导”或“函数f(x)有一阶连续导数”则可以直接使用拉格朗日中值定理；</p>
<p>（2）如何根据题干大致判断使用什么定理？</p>
<p>函数中值定理中除了零点定理，ξ的区间都是闭区间；微分中值定理中ξ的区间全都是开区间，因此在面对下面两种不同题干的时候选择使用不同的方法</p>
<p><img src="/images/image-20230709163408625.png" srcset="/img/loading.gif" lazyload alt="经典题型"></p>
<p>第一个等式将其看作连续的均值定理使用最值定理和介值定理即可证明，第二个等式使用拉格朗日证明，因为证明常用三大微分中值定理中，只有拉格朗日是可以无条件使用的（无论是构造的函数还是题干所给的函数，一般都满足连续可导的条件，所以一般认为拉格朗日可以无条件使用）</p>
<p><img src="/images/image-20230709163635420.png" srcset="/img/loading.gif" lazyload alt="微分中值定理使用条件"></p>
<p>另一个原因是，在微分中值定理中只有拉格朗日定理可以与积分建立联系，一般构造变限积分</p>
<p><img src="/images/image-20230709164951496.png" srcset="/img/loading.gif" lazyload alt="变限积分构造"></p>
<p>（3）在中值定理中也有重要性之分</p>
<p>罗尔定理和介值定理分别代表微分中值定理和函数中值定理中最核心的两个定理，证明题最常考的也就是这两个定理，其余中值定理可以为这两个定理服务</p>
<p>积分中值定理一般用于后面积分的计算，在中值定理证明题这一章一般不用它来解题</p>
<p>（4）罗尔中值定理的一个重要考点是构造辅助函数，以下是常见的构造方式</p>
<p><img src="/images/image-20230709164243313.png" srcset="/img/loading.gif" lazyload alt="罗尔中值定理的构造函数"></p>
<h1 id="七、一元函数积分学"><a href="#七、一元函数积分学" class="headerlink" title="七、一元函数积分学"></a>七、一元函数积分学</h1><h2 id="1-不定积分"><a href="#1-不定积分" class="headerlink" title="1.不定积分"></a>1.不定积分</h2><h3 id="1-1-原函数和不定积分"><a href="#1-1-原函数和不定积分" class="headerlink" title="1.1 原函数和不定积分"></a>1.1 原函数和不定积分</h3><blockquote>
<p>结论1：<code>不定积分是全体原函数的集合</code>(记作F(x)+C)，原函数是不定积分集合中的任意一个元素(记作F(x)，其具体形式使用[变限积分](# 3.2 变限积分性质)表达)；</p>
</blockquote>
<p>函数f(x)定义在某区间I上，若存在可导函数F(x)，对于区间I上的任意一点都有F’(x)&#x3D;f(x)成立，称F(x)是f(x)在区间I上的一个原函数，称<img src="/images/image-20230228101017396.png" srcset="/img/loading.gif" lazyload>为f(x)在区间I上的不定积分</p>
<p>不定积分的几何意义：一组平行的曲线簇</p>
<blockquote>
<p>结论2：f(x)的原函数和不定积分都必须指明f(x)的区间I，只有在“一个区间”上定义的不定积分才是明确无误的（未指明区间默认是定义域）；</p>
</blockquote>
<p>原函数F(x)必须在区间I上处处可导才能说F(x)是f(x)的原函数，否则F(x)不符合原函数的定义</p>
<p><img src="/images/image-20230228102219078.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>结论3：f(x)在一个区间上的任意两个原函数之间只相差一个常数C；</p>
</blockquote>
<h3 id="1-2-原函数存在定理"><a href="#1-2-原函数存在定理" class="headerlink" title="1.2 原函数存在定理"></a>1.2 原函数存在定理</h3><blockquote>
<p>结论1：连续函数f(x)一定有原函数F(x)</p>
</blockquote>
<p>求导必须保证函数图像光滑且连续，但是求原函数只需要保证函数连续即可</p>
<blockquote>
<p>结论2：含有第一类间断点(可去间断点、跳跃间断点)和无穷间断点的函数f(x)在包含该间断点的区间内一定没有原函数F(x)</p>
</blockquote>
<p>结论2的另一个说法是导函数F’(x)在I内一定没有第一类间断点和无穷间断点，而含有振荡间断点的函数f(x)有可能有原函数F(x)，我们只需要找出F(x)使得F’(x)&#x3D;f(x)即可验证f(x)有原函数；</p>
<blockquote>
<p>结论3：可导函数F(x)求导后的函数F’(x)&#x3D;f(x)不一定是连续函数，若有间断点只能是振荡间断点</p>
</blockquote>
<h3 id="1-3-原函数性质"><a href="#1-3-原函数性质" class="headerlink" title="1.3 原函数性质"></a>1.3 原函数性质</h3><p>（1）连续的奇函数的一切原函数都是偶函数，连续的偶函数的原函数中仅有一个原函数是奇函数(因为奇函数必须满足过坐标原点)；</p>
<p>（2）微分运算和不定积分运算是互逆的，即对微分求积分和对积分求微分会抵消或抵消后相差一个常数</p>
<p><img src="/images/image-20230301183612852.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230301183625683.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-定积分"><a href="#2-定积分" class="headerlink" title="2.定积分"></a>2.定积分</h2><h3 id="2-1-定积分的定义"><a href="#2-1-定积分的定义" class="headerlink" title="2.1 定积分的定义"></a>2.1 定积分的定义</h3><p>一元定积分也称为一重定积分，其几何意义为曲边矩形的面积；</p>
<h4 id="2-1-1-原始定义"><a href="#2-1-1-原始定义" class="headerlink" title="2.1.1 原始定义"></a>2.1.1 原始定义</h4><p><img src="/images/image-20230228104050407.png" srcset="/img/loading.gif" lazyload alt="定积分的定义"></p>
<blockquote>
<ul>
<li>其中ξ<del>i</del>是Δx<del>i</del>上任意的一个取值；</li>
<li>“a到b上的定积分”不一定表示a&lt;b，出现a&gt;b的情形是完全可以的；另外这里的[a,b]是指闭区间（网上说的是开闭区间都可以，但严谨来说黎曼积分就是闭区间）</li>
<li>定积分的值只与被积函数和积分区间有关，与积分变量的记法无关，即积分变量无论是x还是t，最后的结果都是相同的；</li>
<li>定积分的值不带常数C，因为常数-常数&#x3D;0；</li>
</ul>
</blockquote>
<h4 id="2-1-2-精确定义"><a href="#2-1-2-精确定义" class="headerlink" title="2.1.2 精确定义"></a>2.1.2 精确定义</h4><blockquote>
<p>使用定积分的精确定义，主要是为了计算一些特殊形式的数列极限 – 定积分精确定义和夹逼准则是计算数列极限的重要方法</p>
</blockquote>
<p>定积分的精确定义如下（考研重点），其中f(a+(b-a)i&#x2F;n)是矩形的高，(b-a)&#x2F;n是矩形的宽</p>
<p><img src="/images/image-20230302224031180.png" srcset="/img/loading.gif" lazyload></p>
<p>将式子中的a,b特殊化为0,1可以得到这样一个式子</p>
<p><img src="/images/image-20230302221018372.png" srcset="/img/loading.gif" lazyload></p>
<p>一般来说只要构造出i&#x2F;n和1&#x2F;n就可以直接替换成x和dx，进而使用定积分求解数列极限。因此使用定积分求解数列极限的三个步骤</p>
<ol>
<li>先从通式中提取出1&#x2F;n</li>
<li>再在通式中凑i&#x2F;n</li>
<li>将数列通式中的i&#x2F;n和1&#x2F;n替换成x和dx得到被积函数和被积表达式，积分区域为[0,1]</li>
</ol>
<hr>
<blockquote>
<p>Q：如何从原始定义到精确定义？</p>
</blockquote>
<p>A：参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/48551870">如何理解定积分原始定义中的极限符号？ - 知乎 (zhihu.com)</a>，需要注意的是一定是先有原始定义再有特殊定义</p>
<p><img src="/images/v2-488caf01b225f4a38308f943b95001d1_720w.webp" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Q：为什么会有精确定义？</p>
</blockquote>
<p>A：本来是没有定积分的精确定义，但是在计算数列极限的过程中发现某些数列极限的形式和定积分的原始定义非常相似，所以对其进行改造得到了精确定义，主要用于计算数列极限；</p>
<hr>
<h3 id="2-2-定积分存在定理"><a href="#2-2-定积分存在定理" class="headerlink" title="2.2 定积分存在定理"></a>2.2 定积分存在定理</h3><p>此处所说的可积性质都是指的常义下的，即“区间有限，函数有界”，这与之后所说的“区间无穷，函数无界”的反常积分有区别</p>
<h4 id="2-2-1-充分条件"><a href="#2-2-1-充分条件" class="headerlink" title="2.2.1 充分条件"></a>2.2.1 充分条件</h4><p><img src="/images/image-20230228104856188.png" srcset="/img/loading.gif" lazyload></p>
<p>4.原函数存在定理和定积分存在定理没有任何关系，可以参考如下关系图<br><img src="/images/image-20230806141701268.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>若f(x)在[a,b]存在原函数，在[a,b]上不一定存在定积分</li>
<li>若f(x)在[a,b]上不存在原函数，在[a,b]上仍然可能存在f(x)的定积分</li>
</ul>
<p>5.上述三点充分条件都可以归结为一点就是第三点，因为连续函数在闭区间上必定有界(最值定理)，而单调函数在闭区间上也必定有界(且有有限个间断点，自行作图就能理解)</p>
<blockquote>
<p>关于第三点容易和无界函数的反常积分混淆，<code>定积分和反常积分是两种不同类型的积分！！！</code>f(x)在某点邻域无界则一定没有定积分，但其反常积分可能收敛；</p>
</blockquote>
<h4 id="2-2-2-必要条件"><a href="#2-2-2-必要条件" class="headerlink" title="2.2.2 必要条件"></a>2.2.2 必要条件</h4><p><img src="/images/image-20230228104931313.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>该必要条件的逆否命题是若f(x)在[a,b]上无界，则定积分不存在(该结论常用于断定f(x)在[a,b]上不存在定积分)；用面积理解无界指的是某个Δx对应的高是∞，则该部分面积是∞故极限不存在，进而定积分不存在</p>
</blockquote>
<h3 id="2-3-定积分性质"><a href="#2-3-定积分性质" class="headerlink" title="2.3 定积分性质"></a>2.3 定积分性质</h3><p><img src="/images/image-20230806145551072.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>积分有线性性质即k<del>1</del>f(x)+&#x2F;-k<del>2</del>g(x)的积分等于k<del>1</del>f(x)的积分+&#x2F;-k<del>2</del>g(x)的积分，但是，不存在将<code>f(x)·g(x)的积分拆为f(x)的积分乘以g(x)的积分</code>这样的性质；</li>
</ul>
<p>上述几个性质是基本性质，下面的则是有关定积分的比较重要的两个定理</p>
<h4 id="2-3-1-估值定理"><a href="#2-3-1-估值定理" class="headerlink" title="2.3.1 估值定理"></a>2.3.1 估值定理</h4><p><img src="/images/image-20230228105457279.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-3-2-中值定理"><a href="#2-3-2-中值定理" class="headerlink" title="2.3.2 中值定理"></a>2.3.2 中值定理</h4><p>该中值定理就是前面中值定理章节介绍过同时证明过的[积分中值定理](# 3.积分中值定理)；</p>
<p><img src="/images/image-20230228105521640.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-变限积分"><a href="#3-变限积分" class="headerlink" title="3.变限积分"></a>3.变限积分</h2><h3 id="3-1-变限积分定义"><a href="#3-1-变限积分定义" class="headerlink" title="3.1 变限积分定义"></a>3.1 变限积分定义</h3><p><img src="/images/image-20230228105807253.png" srcset="/img/loading.gif" lazyload></p>
<p>变限积分的定义不重要，重要的是变限积分的性质和求导！！！</p>
<h3 id="3-2-变限积分性质"><a href="#3-2-变限积分性质" class="headerlink" title="3.2 变限积分性质"></a>3.2 变限积分性质</h3><p><img src="/images/image-20230228105847591.png" srcset="/img/loading.gif" lazyload></p>
<p>性质3：<code>变限积分只要存在，必然是连续的</code>（这一点可以用于快速判断变限函数的图像，相比于性质1和性质2更常用）；</p>
<p>性质4：如果函数f(x)在区间[a,b]上连续，则<img src="/images/image-20230626163947075.png" srcset="/img/loading.gif" lazyload>是f(x)在区间[a,b]上的一个原函数（考研常使用这种具体形式来表示函数f(x)的任意一个原函数)</p>
<h3 id="3-3-变限积分求导"><a href="#3-3-变限积分求导" class="headerlink" title="3.3 变限积分求导"></a>3.3 变限积分求导</h3><p><img src="/images/image-20230306111159317.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>变限积分求导公式要求求导变量(即上下限中的函数的变量)不能出现在被积函数中，否则必须通过换元将其移出被积函数才能使用上述公式</li>
</ul>
<h2 id="4-反常积分"><a href="#4-反常积分" class="headerlink" title="4.反常积分"></a>4.反常积分</h2><p>定积分存在需要有两个必要条件，一是积分区间有限，二是被积函数有界：</p>
<ul>
<li>如果破坏了积分区间的有限性（也就是闭区间变成了开区间），就引出无穷区间上的反常积分；</li>
<li>如果破坏了被积函数的有界性，就引出无界函数的反常积分；</li>
</ul>
<p>反常积分不属于定积分，因为不符合定积分的定义。在介绍反常积分之前需要先介绍一些基本概念：</p>
<ul>
<li>瑕点：若函数f(x)在点a的某一领域内无界，则称点a为函数f(x)的瑕点 – 简单来说瑕点就是使得函数极限为无穷的点（也就是无界函数中“无界”的那个点）；</li>
<li>奇点：一般将∞和瑕点统称为奇点；</li>
</ul>
<p>瑕点在解题过程中非常容易被忽略（考题会将瑕点埋伏在区间内部），不能看函数上下限来确定瑕点，要从函数本身进行分析（没有固定方法，只能找特殊点验证是否使得f(x)-&gt;∞）</p>
<p>而无论是无界反常积分还是无穷反常积分，其几何意义仍可以套用定积分中曲边梯形的面积来理解，比如下面下图引用部分是以x&#x3D;0为瑕点的无界反常积分的几何意义图示</p>
<p><img src="/images/image-20230228193434788.png" srcset="/img/loading.gif" lazyload></p>
<p>常说的反常积分收敛，其对应的几何意义就是上图阴影部分的面积是可以被计算的</p>
<h3 id="4-1-无穷区间上的反常积分"><a href="#4-1-无穷区间上的反常积分" class="headerlink" title="4.1 无穷区间上的反常积分"></a>4.1 无穷区间上的反常积分</h3><blockquote>
<p>无穷区间上的反常积分的概念与敛散性</p>
<p><img src="/images/image-20230228110822659.png" srcset="/img/loading.gif" lazyload alt="概念和敛散性"></p>
</blockquote>
<h3 id="4-2-无界函数的反常积分"><a href="#4-2-无界函数的反常积分" class="headerlink" title="4.2 无界函数的反常积分"></a>4.2 无界函数的反常积分</h3><blockquote>
<p>无界函数的反常积分的概念与敛散性定义</p>
<p><img src="/images/image-20230228193842602.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="4-3-反常积分的计算-x2F-敛散性判别"><a href="#4-3-反常积分的计算-x2F-敛散性判别" class="headerlink" title="4.3 反常积分的计算&#x2F;敛散性判别"></a>4.3 反常积分的计算&#x2F;敛散性判别</h3><h4 id="4-3-1-反常积分的计算"><a href="#4-3-1-反常积分的计算" class="headerlink" title="4.3.1 反常积分的计算"></a>4.3.1 反常积分的计算</h4><p>无论是带无穷区间还是瑕点的反常积分，直接使用上面对应公式求解即可非常简单，不必考虑敛散性（极限存在则收敛，极限不存在则发散）</p>
<h4 id="4-3-2-敛散性判别"><a href="#4-3-2-敛散性判别" class="headerlink" title="4.3.2 敛散性判别*"></a>4.3.2 敛散性判别*</h4><p>反常积分的收敛性可以通过求被积函数的原函数，然后按定义取极限，根据极限是否存在来判定，但这种方式往往计算量极大，当反常积分的被积函数较复杂时不推荐计算法。</p>
<p>判别反常积分的敛散性主要需要掌握如下两个重要结论</p>
<p><img src="/images/image-20230711174443334.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>在更加具有难度的题中，需要构造额外的函数进行无穷小或无穷大比阶；</p>
</li>
<li><p>无论是无穷区间还是无界函数的反常积分的敛散性，都只需要在其奇点处讨论；</p>
</li>
</ul>
<p>（2023&#x2F;8&#x2F;6 反常积分敛散性的判别暂时还不是很懂，之后刷题过程中继续巩固）</p>
<h2 id="5-不定积分积分法"><a href="#5-不定积分积分法" class="headerlink" title="5.不定积分积分法"></a>5.不定积分积分法</h2><p>无论是不定积分还是定积分的考研题型技巧性都不会很强，特别依赖公式所以公式非常重要！！！这一章涉及非常多的[三角公式](# 3.三角函数)也需要记忆；</p>
<h3 id="5-1-基本积分公式"><a href="#5-1-基本积分公式" class="headerlink" title="5.1 基本积分公式*"></a>5.1 基本积分公式*</h3><blockquote>
<p>(1)重要积分公式</p>
</blockquote>
<p><img src="/images/image-20230301190826019.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<blockquote>
<p>Q:上面的个别积分公式可能会引起疑惑，比如为什么只给了1&#x2F;(1+x^2^)的原函数却没给-1&#x2F;(1+x^2^)的原函数呢？如果利用积分的性质，直接将被积函数中的负号提出再求积分，岂不是原函数分别是arctanx+C和-arctanx+C?</p>
</blockquote>
<p>A：实际上并没有问题，对于-1&#x2F;(a+x^2^)来说，其原函数既可以是-arctanx+C也可以是arccotx+C，因为有定理arctanx+arccotx&#x3D;Π&#x2F;2，所以arccotx+C&#x3D;Π&#x2F;2-arctanx+C&#x3D;-arctanx+C；</p>
<p>上面的例子也给我们这样一个启发：<code>导数互为相反数的原函数并不一定是相反数</code>，但它们的和一定是一个常数；</p>
<hr>
<blockquote>
<p>(2)复杂积分公式</p>
</blockquote>
<p>下面这部分其实已经不能算基本的积分公式了，需要手动推导，当然能背是最好的(这些公式实际上也很常见)</p>
<p><img src="/images/image-20230301190943181.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>(3)补充积分公式</p>
</blockquote>
<p>最后补充几个书上没有但是比较重要的积分公式</p>
<p><img src="/images/image-20230302193452070.png" srcset="/img/loading.gif" lazyload alt="lnx的原函数"></p>
<p>以及<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349530983">带有根号下x^2^+a^2^和根号下x^2^-a^2^的不定积分</a>；</p>
<h3 id="5-2-凑微分法"><a href="#5-2-凑微分法" class="headerlink" title="5.2 凑微分法"></a>5.2 凑微分法</h3><p><img src="/images/image-20230228125651198.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-3-换元法"><a href="#5-3-换元法" class="headerlink" title="5.3 换元法"></a>5.3 换元法</h3><p><img src="/images/image-20230228125724682.png" srcset="/img/loading.gif" lazyload alt="换元法的基本思想"></p>
<p>与凑微分法往积分变量中提取不同，换元法是将d内部的往外提取，且需要显式进行中间变量的替换，最终用反函数替换得到关于x的表达式。简单来说这就是把x换成关于t的表达式，使得被积函数容易积分，最后用t关于x的表达式回代。</p>
<p>换元法主要消除被积函数中的根号，当然也可以解决一些其他类型的不定积分，主要总结如下的换元法题型（具体解题的时候要分析被积函数的具体情况选取尽可能简单的代换，不要拘泥于这些变量代换，方法不唯一的好处就是我们可以使用多种方法去尝试） – 换元法一定要注意换元前后的定义域！！！</p>
<p><img src="/images/image-20230705155655457.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-4-分部积分法"><a href="#5-4-分部积分法" class="headerlink" title="5.4 分部积分法"></a>5.4 分部积分法</h3><p>分部积分法的基本公式如下</p>
<p><img src="/images/image-20230807090847569.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>一般使用分部积分法都需要使用多次，一般选择积分后“简单”的作为v，而微分后“简单”的作为u<ul>
<li>u的优先选择顺序应该是：反三角函数，对数函数，幂函数，三角函数，指数函数，简称为“反对幂三指”，微分难度递增（这里三角函数和指数函数可以交换顺序）</li>
<li>相对的，v的优先选择顺序应该是：“指三幂对反”，积分难度递增</li>
</ul>
</li>
<li>连续使用分部积分法的时候一定要把上一次的分部积分形式解出来才能继续使用分部积分</li>
</ul>
</blockquote>
<p>分部积分的推广公式如下</p>
<p><img src="/images/image-20230807091354393.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>上述推广公式主要用于快速计算多次使用分部积分的题型，对于含三角函数或n次多项式的分部积分尤其有用；</li>
<li>实际上述公式可以使用表格法形式化记忆</li>
</ul>
<p><img src="/images/image-20230807092053576.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="5-5-有理函数的积分"><a href="#5-5-有理函数的积分" class="headerlink" title="5.5 有理函数的积分"></a>5.5 有理函数的积分</h3><blockquote>
<p>注：此处的有理函数实际上是指有理分式，即分子和分母都是高次多项式</p>
</blockquote>
<p>分子多项式的次数小于分母多项式(头小屁股大)称为真分式，否则称为假分式</p>
<ul>
<li>利用多项式的除法，总可以将一个假分式变换为一个真分式</li>
<li>对于真分式，若分母可以分解为两个多项式的乘积，则可拆解为两个真分式的和</li>
</ul>
<p>有理分式的积分的本质就是对真分式的分母进行因式分解，“将整个真分式拆成若干项最简有理分式之和”，一般使用待定系数法解决</p>
<h4 id="5-5-1-待定系数法"><a href="#5-5-1-待定系数法" class="headerlink" title="5.5.1 待定系数法"></a>5.5.1 待定系数法</h4><p>使用待定系数法对真分式进行分解的理论思想如下</p>
<p><img src="/images/image-20230302220309677.png" srcset="/img/loading.gif" lazyload></p>
<p>通过下面这些例子可以牢牢掌握待定系数法的基本用法（分子究竟是常数还是多项式对于待定系数的设定没有任何影响，只看分母）</p>
<p><img src="/images/image-20230706110736898.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-6-方法总结"><a href="#5-6-方法总结" class="headerlink" title="5.6 方法总结"></a>5.6 方法总结</h3><p>求解不定积分的所有题型归根结底都是围绕[已知基本积分公式](# 5.1 基本积分公式*)，高级技术手段无非就是凑微分(又称第一类换元)、换元(又称第二类换元)以及分部积分</p>
<ol>
<li>最简单的类型就是原式能观察原式凑出基本积分公式中的形式；</li>
<li>不能直接凑微分的式子，使用分部积分或换元法化简原式，最后凑出微分<ul>
<li><p>当出现根号的时候考虑换元法（换元法一定要注意限定t的范围）</p>
<ul>
<li>不需要有理化！不需要有理化！不需要有理化！前面极限有理化是为了方便计算，此处就算有理化过后也得换元没有意义；</li>
<li>对于复杂的表达式，有时候需要先进行配方等恒等变化才能换元，否则换元后也解决不了问题</li>
<li>当出现三角函数时考虑常见的三角恒等变换（半角公式、和差化积…）后再进行化简处理</li>
<li>某些复杂的题型是可能出现两次换元的，因此最终回代也需要进行两次回代</li>
</ul>
</li>
<li><p>分部积分常用于凑微分和换元统统失效时的“杀手锏”</p>
<ul>
<li>当出现反三角函数、根号等复杂表达式并未知应该对谁换元时，直接用分部积分可能出现奇效</li>
<li>分部积分的另一种应用就是分部处理过后可能出现与原式相同的积分表达式，此时可以将复杂积分等价为简单积分的计算</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>有理分式&#x2F;函数的积分通常作为不定积分计算过程中的题型出现，只需要牢牢掌握待定系数法即可</p>
<h2 id="6-定积分积分法"><a href="#6-定积分积分法" class="headerlink" title="6.定积分积分法"></a>6.定积分积分法</h2><p>定积分的计算可以借助牛莱公式转换为前面介绍的不定积分计算，但牛莱公式不适用于有无限个间断点的情况，换句话说牛莱公式并不是万能的（考研题如果让求解必然是满足牛莱使用条件的所以不用考虑这个问题，这里只是做一个提醒）</p>
<p><img src="/images/image-20230228130146313.png" srcset="/img/loading.gif" lazyload alt="牛莱公式"></p>
<blockquote>
<p>牛莱公式的推广：在积分区间[a,b]上存在<code>有限个间断点</code>的被积函数f(x)，只要在[a,b]上存在原函数，牛莱公式仍然成立</p>
</blockquote>
<p>牛莱公式极大的简化了定积分的计算，将计算一个连续函数在区间[a,b]上的定积分的问题转换成计算该函数的任意一个原函数在区间[a,b]上的增量</p>
<p>结合牛莱公式和不定积分的计算方法，可以得到定积分换元以及定积分的分部积分</p>
<h3 id="6-1-定积分的换元积分法"><a href="#6-1-定积分的换元积分法" class="headerlink" title="6.1 定积分的换元积分法"></a>6.1 定积分的换元积分法</h3><p><img src="/images/image-20230228130403090.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>如果在换元的过程中没有显式的写出新变量t则不要变更积分的上下限；</li>
<li>定积分的换元可能会让初学者产生误解，一种平替的方法是使用牛莱公式+不定积分换元（好理解但是计算量往往会比直接定积分换元麻烦）</li>
</ul>
<hr>
<blockquote>
<p>Q：在换元的时候究竟需不需要考虑换元函数的单调性？？还是只是简单的代入值就可以了？那么三角函数换元又应该如何解释？</p>
</blockquote>
<p>A：在不定积分的换元法中规定了换元函数必须是单调可导函数，但是在定积分的换元法中并没有规定这一点，而实际上定积分中的换元函数是否需要具备单调性不重要，因为强调了只需要端点值对应即可；</p>
<p>那么有些人可能会考虑x&#x3D;1，x&#x3D;sint，那么t不是可以取多个值？这忽略了x&gt;0，t∈(0,Π)这一条件；</p>
<p>如果实在是存在疑问，那么就认为定积分中的换元函数必须在给定区间内单调；</p>
<hr>
<h3 id="6-2-定积分的分部积分法"><a href="#6-2-定积分的分部积分法" class="headerlink" title="6.2 定积分的分部积分法"></a>6.2 定积分的分部积分法</h3><p><img src="/images/image-20230228130429407.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-3-基本结论"><a href="#6-3-基本结论" class="headerlink" title="6.3 基本结论*"></a>6.3 基本结论*</h3><p>定积分的计算区分于不定积分的计算主要在可以使用一些性质辅助求解，比如对称性、几何意义以及点火&#x2F;华里士公式、区间再现公式等，因此定积分的计算相对于不定积分来说计算量更小但更加灵活</p>
<p><img src="/images/image-20230228130529406.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>关于上述结论有以下几点需要注意：</p>
<ul>
<li><code>区间再现公式</code>，准确的说区间再现公式并不是指某个具体的公式，而是一种换元思想。一般另x&#x3D;a+b-t进行换元，其中a和b分别是定积分的上限和下限(对于积分区间为[Π&#x2F;2,Π]使用x&#x3D;Π-t换元可以将积分区间将为[0,Π&#x2F;2]) – 一般在计算定积分的题中出现复合的三角函数使用该方法换元，使用的时候注意换元对应的上下限，使用区间再现一般都是将难以计算的积分等价于另一个好计算的积分；</li>
<li>华里士公式是通过分部积分得到，利用华里士公式可以快速计算三角函数的幂次的积分，需要注意其积分上下限是[0,Π&#x2F;2]，当不满足该原则时可以使用区分再现公式换元或拆分上下限使其满足，华里士公式还有如下变形<ul>
<li><img src="/images/image-20230313152934202.png" srcset="/img/loading.gif" lazyload></li>
<li><img src="/images/image-20230306104622201-16780708820703.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</blockquote>
<p>(6)在面对一些较难的一重积分问题时可以考虑使用换元、平方等方式转换为二次积分解决（即可以用二重积分&#x2F;二次积分处理某些一元积分的问题）</p>
<p><img src="/images/image-20230806193910430.png" srcset="/img/loading.gif" lazyload alt="例题"></p>
<h3 id="6-4-方法总结"><a href="#6-4-方法总结" class="headerlink" title="6.4 方法总结"></a>6.4 方法总结</h3><p>常规求解定积分的三大步骤如下：</p>
<ol>
<li>判断是否具有对称性</li>
<li>判断是否具有几何意义</li>
<li>若均无上述性质再进行定积分的计算<ul>
<li><p>一般情况使用定积分换元积分或分部积分搭配区间再现、点火公式完全能够解题</p>
<ul>
<li>出现复杂的三角函数或高次三角函数一般使用区间再现都能够处理</li>
</ul>
</li>
<li><p>在满足使用条件的任何情况下使用牛莱公式都可以计算出定积分，当然计算量可能会非常大</p>
</li>
</ul>
</li>
</ol>
<h2 id="7-积分等式-amp-积分不等式"><a href="#7-积分等式-amp-积分不等式" class="headerlink" title="7.积分等式&amp;积分不等式*"></a>7.积分等式&amp;积分不等式*</h2><p>(2023&#x2F;8&#x2F;6 16:11 本节错题整理的时候没什么状态，估计还是得像微分不等式那一节刷完立马总结效果会比较好)</p>
<p>积分等式或积分不等式顾名思义就是显式含积分的等式或不等式（这与微分不等式略有不同）；</p>
<h3 id="7-1-积分等式"><a href="#7-1-积分等式" class="headerlink" title="7.1 积分等式"></a>7.1 积分等式</h3><p>该考点一般会作为应用大题考察，要么是让证明某个积分等式成立，要么是计算某个积分，这一节难度极大（涉及中值定理的都不会简单），本质还是需要在刷题过程中巩固；</p>
<h4 id="7-1-1-中值定理"><a href="#7-1-1-中值定理" class="headerlink" title="7.1.1 中值定理"></a>7.1.1 中值定理</h4><p>前面我们已经介绍过各种不同的<a href="#%E5%85%AD%E3%80%81%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86">中值定理</a>，涉及积分形式的有一个积分中值定理</p>
<p><img src="/images/image-20230226184810323-167876220376316.png" srcset="/img/loading.gif" lazyload alt="积分中值定理"></p>
<p>这里补充一个积分中值定理的推广形式，当g(x)为1的时候就是普通的积分中值定理</p>
<p><img src="/images/image-20230314104921098.png" srcset="/img/loading.gif" lazyload alt="积分中值定理推广"></p>
<h4 id="7-1-2-夹逼准则"><a href="#7-1-2-夹逼准则" class="headerlink" title="7.1.2 夹逼准则"></a>7.1.2 夹逼准则</h4><p>夹逼定理一般用于计算复杂积分，即被积函数不容易积分的时候进行放缩处理</p>
<ul>
<li>积分的夹逼最好直接夹在两个数或表达式而不是积分之间，因为夹在积分中间还需要额外计算积分；</li>
</ul>
<h4 id="7-1-3-积分法"><a href="#7-1-3-积分法" class="headerlink" title="7.1.3 积分法"></a>7.1.3 积分法</h4><p>积分法就是使用基本积分法来推导，一般会要求先使用基本积分法得到一个新的积分法，然后利用新的积分法来解决问题；</p>
<h3 id="7-2-积分不等式"><a href="#7-2-积分不等式" class="headerlink" title="7.2 积分不等式"></a>7.2 积分不等式</h3><h4 id="7-2-1-函数单调性"><a href="#7-2-1-函数单调性" class="headerlink" title="7.2.1 函数单调性"></a>7.2.1 函数单调性</h4><p>利用单调性证明不等式是主流方法，通常的做法是先让某一积分限（通常是上限）变量化为x，之后构造辅助函数，通过研究辅助函数的单调性来证明不等式；</p>
<p>一般适用于所给条件为<code>“f(x)在[a,b]上连续”</code>的情形，或者其上下限、被积函数及其复杂；</p>
<h4 id="7-2-2-拉格朗日中值定理"><a href="#7-2-2-拉格朗日中值定理" class="headerlink" title="7.2.2 拉格朗日中值定理"></a>7.2.2 拉格朗日中值定理</h4><p>该方法一般适用于所给条件为<code>“f(x)为一阶可导且某一端点的值较简单（通常为0）”</code>或出现<code>f与f&#39;之间的关系</code>；</p>
<h4 id="7-2-3-泰勒公式"><a href="#7-2-3-泰勒公式" class="headerlink" title="7.2.3 泰勒公式"></a>7.2.3 泰勒公式</h4><p>当题干出现<code>f(x)二阶可导且某端点值较简单（通常为0）</code>且一般要求解决二阶导数f’’(x)的问题；</p>
<h4 id="7-2-4-积分法"><a href="#7-2-4-积分法" class="headerlink" title="7.2.4 积分法"></a>7.2.4 积分法</h4><p>此方法是最基本也最核心的方法，即使用基本积分法来证明不等式。简单来说就是直接把要证明的积分计算出来（这要求一定的计算能力）</p>
<h1 id="八、一元函数积分学的几何应用"><a href="#八、一元函数积分学的几何应用" class="headerlink" title="八、一元函数积分学的几何应用"></a>八、一元函数积分学的几何应用</h1><blockquote>
<p>假设以下曲线都是连续的</p>
</blockquote>
<h2 id="1-平面图形面积"><a href="#1-平面图形面积" class="headerlink" title="1.平面图形面积"></a>1.平面图形面积</h2><h3 id="1-1-直角坐标系"><a href="#1-1-直角坐标系" class="headerlink" title="1.1 直角坐标系"></a>1.1 直角坐标系</h3><p><img src="/images/image-20230307220925835.png" srcset="/img/loading.gif" lazyload alt="直角坐标系"></p>
<p>仅靠上面的公式并不能解决所有问题，更常用的是将直角坐标系下的平面图形面积分为X型和Y型解题</p>
<p><img src="/images/image-20230307222042782.png" srcset="/img/loading.gif" lazyload alt="记忆公式"></p>
<blockquote>
<p>其实更推荐的方式是连X、Y型区域都不要背，解题时直接根据微元法手动推导计算公式；</p>
</blockquote>
<h3 id="1-2-极坐标系"><a href="#1-2-极坐标系" class="headerlink" title="1.2 极坐标系"></a>1.2 极坐标系</h3><p>因为扇形面积公式为S&#x3D;1&#x2F;2θR^2^，因此可以推出如下</p>
<p><img src="/images/image-20230307220954504.png" srcset="/img/loading.gif" lazyload alt="极坐标系"></p>
<p>极坐标方程的上下限确定方法与参数方程有区别。参数方程是严格按照原x的变化对应参数t的变化，但是极坐标方程的上下限是逆时针方向射线依次经过的两个夹角，其中r<del>2</del>(θ)是射线第一次经过的曲线，r<del>1</del>(θ)是射线第二次经过的曲线。</p>
<h3 id="1-3-参数方程"><a href="#1-3-参数方程" class="headerlink" title="1.3 参数方程"></a>1.3 参数方程</h3><p><img src="/images/image-20230313150933457.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注：参数方程很容易混淆的一点就是确定上下限，如椭圆的参数方程，当x&#x3D;0的时候参数实际是等于Π&#x2F;2的，当x&#x3D;a时参数等于0，这就意味着假如要使用参数方程进行面积的计算则dt的下限是Π&#x2F;2，上限是0（实际上就是上对上，下对下的定积分换元法）；一个简单的方法就是先利用直角坐标系写出求面积公式后再转换为参数方程代入求解；</p>
</blockquote>
<h2 id="2-旋转体体积"><a href="#2-旋转体体积" class="headerlink" title="2.旋转体体积"></a>2.旋转体体积</h2><h3 id="2-1-直角坐标系"><a href="#2-1-直角坐标系" class="headerlink" title="2.1 直角坐标系"></a>2.1 直角坐标系</h3><p>旋转体是指由某个二维平面图形绕x轴或y轴旋转得到的三维立体图形，其体积的基本求解方法就是将体积看作面积的微元求和，示意图如下</p>
<p><img src="/images/image-20230806154851103.png" srcset="/img/loading.gif" lazyload></p>
<p>下面直接给出不同情况下对应的计算公式（这里给出公式只是为了方便日常做题检验是否正确，不要硬背，利用上面这种思想主动利用微元法推导计算公式）</p>
<p><img src="/images/image-20230307221030046.png" srcset="/img/loading.gif" lazyload alt="绕x轴旋转_实心旋转体"></p>
<p><img src="/images/image-20230307221138135.png" srcset="/img/loading.gif" lazyload alt="绕x轴旋转_空心旋转体"></p>
<p><img src="/images/image-20230307221214805.png" srcset="/img/loading.gif" lazyload alt="绕y轴旋转_实心旋转体"></p>
<p><img src="/images/image-20230307221536349.png" srcset="/img/loading.gif" lazyload alt="绕y轴旋转_空心旋转体"></p>
<h3 id="2-2-参数方程"><a href="#2-2-参数方程" class="headerlink" title="2.2 参数方程"></a>2.2 参数方程</h3><p>参数方程没什么好说的（因为很简单），先直接利用直角坐标方程（因为参数方程和直角坐标方程都是在同一个直角坐标系下，这点注意和极坐标方程位于极坐标系区别）写出表达式，之后直接分别代入参数方程即可；</p>
<h2 id="3-平面曲线弧长"><a href="#3-平面曲线弧长" class="headerlink" title="3.平面曲线弧长"></a>3.平面曲线弧长</h2><blockquote>
<p>光滑曲线弧是可求弧长的</p>
</blockquote>
<p>假如曲线弧由参数方程<img src="/images/image-20230307222916543.png" srcset="/img/loading.gif" lazyload>表示，则所求弧长为<img src="/images/image-20230307222833540.png" srcset="/img/loading.gif" lazyload></p>
<p>假如曲线弧由直角坐标方程<img src="/images/image-20230307223026094.png" srcset="/img/loading.gif" lazyload>表示，则所求弧长为<img src="/images/image-20230307223045324.png" srcset="/img/loading.gif" lazyload></p>
<p>假如曲线弧由极坐标方程<img src="/images/image-20230307223122232.png" srcset="/img/loading.gif" lazyload>表示，则所求弧长为<img src="/images/image-20230307223145498.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-函数平均值"><a href="#4-函数平均值" class="headerlink" title="4.函数平均值"></a>4.函数平均值</h2><p><img src="/images/image-20230307221636017.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="九、多元函数微分学"><a href="#九、多元函数微分学" class="headerlink" title="九、多元函数微分学"></a>九、多元函数微分学</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-平面点集"><a href="#1-1-平面点集" class="headerlink" title="1.1 平面点集"></a>1.1 平面点集</h3><p>二元函数f(x,y)的定义域是平面上的点集，平面点集就是平面直角坐标系xOy上的点组成的集合，即以两个实数组成的有序数组(x,y)为元素的集合；</p>
<p>领域的概念：</p>
<p><img src="/images/image-20230315193933732.png" srcset="/img/loading.gif" lazyload alt="邻域"></p>
<p>给定平面上的一个点集E，可以使用领域的概念将平面上的点分为内点、外点和边界点</p>
<p><img src="/images/image-20230315200637054.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>聚点&#x3D;边界点+内点</p>
</blockquote>
<p>按照不同的标准可以将点集分类：</p>
<ul>
<li>设 E 为一个平面点集，若存在常数 δ&gt;0，使得 E包含于U(O，δ)（这里 O 是指坐标原点），则 E 为有界集.否则，E就是无界集；</li>
<li>若 E 中的每个点都是 E 的内点，则 E 为开集；若 E 的边界点都是 E 的点，则E 为闭集.显然，若一个点集是开集，其余集必是闭集；若一个点集是闭集，其余集必是开集；</li>
<li>设E为一个平面点集，若对于E中的任意两点，都可用一条完全属于E的折线（说成曲线亦可）将这两点连接起来，则这样的E为（道路）连通集；</li>
<li>连通的开集叫开区域（连通+开集），一个开区域和它的边界点集的并集叫闭区域（连通+闭集），开区域、闭区域统称为区域；</li>
<li>若E是一个平面区域，且E内的任一条简单闭曲线的内部还在E内，则这样的 E称为单连通区域（通俗一点单连通区域没有“洞”），否则就叫多连通区域；</li>
</ul>
<h3 id="1-2-二元函数的极限"><a href="#1-2-二元函数的极限" class="headerlink" title="1.2 二元函数的极限"></a>1.2 二元函数的极限</h3><p><img src="/images/image-20230315213208770.png" srcset="/img/loading.gif" lazyload alt="定义"></p>
<blockquote>
<p>结论1：通过找不同的趋近方式(可以是直线趋近也可以是曲线趋近)其函数值不同来证明二重极限不存在，不能通过穷举所有的趋近方式来证明二重极限存在；</p>
</blockquote>
<h3 id="1-3-二元函数的连续性"><a href="#1-3-二元函数的连续性" class="headerlink" title="1.3 二元函数的连续性"></a>1.3 二元函数的连续性</h3><p><img src="/images/image-20230315213439549.png" srcset="/img/loading.gif" lazyload alt="定义"></p>
<blockquote>
<p>对于不连续的情况，多元函数并不要求讨论间断点类型；</p>
</blockquote>
<p>二元函数的连续性比较容易判断，如何判断二元函数f(x,y)在(x<del>0</del>,y<del>0</del>)处的偏导数是否连续呢？主要步骤如下</p>
<p><img src="/images/image-20230315215934423.png" srcset="/img/loading.gif" lazyload></p>
<p>注意，定义法就是指类似<img src="/images/image-20230320214222562.png" srcset="/img/loading.gif" lazyload>的方式求解在(x<del>0</del>,y<del>0</del>)处的偏导数，该偏导数可以认为是精确值；</p>
<p>公式法指的是类似<img src="/images/image-20230320214344249.png" srcset="/img/loading.gif" lazyload>，也就是利用题干所给的公式求解在(x,y)的偏导数表达式，接着代入x-&gt;x<del>0</del>和y-&gt;y<del>0</del>得到逼近值；</p>
<h3 id="1-4-二元函数的偏导数"><a href="#1-4-二元函数的偏导数" class="headerlink" title="1.4 二元函数的偏导数"></a>1.4 二元函数的偏导数</h3><p><img src="/images/image-20230315213505725.png" srcset="/img/loading.gif" lazyload alt="定义"></p>
<ul>
<li>偏导数的几何含义是曲面与平面x&#x3D;x<del>0</del>或y&#x3D;y<del>0</del>相交得到的曲线在(x<del>0</del>,y<del>0</del>)处切线的斜率（下面的例子中，偏导数f<del>x</del>(x<del>0</del>,y<del>0</del>)是M<del>0</del>T<del>x</del>对x轴的斜率，偏导数f<del>y</del>(x<del>0</del>,y<del>0</del>)是M<del>0</del>T<del>y</del>对y轴的斜率）；</li>
</ul>
<p><img src="/images/image-20230315220927867.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>对于一元函数来说可导必定连续，但对于多元函数来说，偏导存在不一定在该点连续（因为偏导存在只能保证沿着坐标轴极限值趋于函数值）；</p>
</li>
<li><p>导数等同于微商，但偏导数的记号是一个整体，不能看作分子和分母的商；</p>
</li>
</ul>
<p>二阶偏导按照对变量求导的次序不同有如下形式（重点记忆第二和第三种形式，谁在前面就表示对谁先求导）</p>
<p><img src="/images/image-20230315215222289.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>对x求偏导的时候将y和其他无关变量视作常数，对y求偏导同理；</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A8%E5%AF%BC%E6%95%B0/7146883">全导数</a>是复合链式法则中的概念，与偏导数不是相对的概念。例如，z与x之间存在中间变量u和v，则z对x的导数就称为全导数；</li>
</ul>
<p>对于第二种和第三种形式的高阶偏导数又称为混合偏导数，具有如下定理</p>
<p><img src="/images/image-20230325101434248.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-5-全微分-不去心"><a href="#1-5-全微分-不去心" class="headerlink" title="1.5 全微分(不去心)"></a>1.5 全微分(不去心)</h3><p>由偏导数的定义可知，二元函数对某个自变量的偏导数表示当另一个自变量固定时，因变量相对于该自变量的变化率。类比一元函数微分学中的增量与微分之间的关系，可以得到二元函数的偏微分定义如下</p>
<p><img src="/images/image-20230315221546234.png" srcset="/img/loading.gif" lazyload></p>
<p>上面两个式子左端称为二元函数对x和y的偏增量，右端称为二元函数对x和y的偏微分。然而实际问题常常研究的是多元函数中多个自变量同时变化时对应的因变量变化，也就是全增量问题。类比一元函数，可以得到二元函数的全微分定义如下</p>
<p><img src="/images/image-20230315214146433.png" srcset="/img/loading.gif" lazyload alt="定义"></p>
<blockquote>
<ul>
<li><p>多元函数在某点可微分则在该点必定连续</p>
</li>
<li><p>在某点可微的<code>必要条件</code>是偏导数f’<del>x</del>和f’<del>y</del>都存在（这里偏导存在在前，可微在后，<code>可微可以推出偏导存在</code>）</p>
<p>在某点可微的<code>充分条件</code>是偏导数存在且连续（偏导存在且连续在前，可微在后，<code>偏导存在且连续可以推出可微，但是偏导存在不连续不能推出不可微</code>）</p>
</li>
<li><p>叠加原理：二元函数的全微分dz等于它的两个偏微分求和即f’<del>x</del>(x,y)dx+f’<del>y</del>(x,y)dy – 这里就是dz和dx以及dy，不要去考虑为什么不是偏导数的写法，因为偏导数并不类似于微商；</p>
</li>
</ul>
</blockquote>
<p>判断二元函数f(x,y)在点(x<del>0</del>,y<del>0</del>)是否可微的主要步骤如下</p>
<p><img src="/images/image-20230315215450852.png" srcset="/img/loading.gif" lazyload></p>
<p>利用叠加原理可以很容易求出dz，注意利用基本微分法则求微分是基本功</p>
<p>例如，对方程<img src="/images/image-20230325110709414.png" srcset="/img/loading.gif" lazyload>求微分有<img src="/images/image-20230325110744411.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-6-二元函数的方向导数"><a href="#1-6-二元函数的方向导数" class="headerlink" title="1.6 二元函数的方向导数"></a>1.6 二元函数的方向导数</h3><p><img src="/images/image-20230315214611377.png" srcset="/img/loading.gif" lazyload alt="定义"></p>
<p>其中l是xoy平面上以P<del>0</del>(x<del>0</del>,y<del>0</del>)为起点的一条射线，其与x轴的夹角为α，与y轴的夹角为β</p>
<p><img src="/images/image-20230320164903445.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>方向导数的结果是一个数，注意与梯度的结果是一个向量作区分；</li>
<li>函数f(x,y)在某点可微分，则函数在该点任意方向的方向导数都存在；</li>
<li>偏导数的几何含义是函数f(x,y)沿x轴或y轴方向函数的变化率，方向导数的几何含义是函数f(x,y)沿任意方向的变化率；</li>
<li>x轴方向的偏导数存在的充要条件是函数f(x,y)沿x轴正负方向的方向导数均存在且互为相反数，y轴同理；</li>
</ul>
</blockquote>
<p>上述定义式并不容易计算方向导数，计算方向导数的一般式如下</p>
<p><img src="/images/image-20230315214734834.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-7-二元函数的梯度"><a href="#1-7-二元函数的梯度" class="headerlink" title="1.7 二元函数的梯度"></a>1.7 二元函数的梯度</h3><p><img src="/images/image-20230315220043478.png" srcset="/img/loading.gif" lazyload alt="定义"></p>
<blockquote>
<ul>
<li>梯度是一个二维空间的向量，方向导数是三维空间的一个数；</li>
</ul>
</blockquote>
<p>这里论述一下梯度和方向导数的关系</p>
<p><img src="/images/image-20230320170233521.png" srcset="/img/loading.gif" lazyload></p>
<p>方向导数&#x3D;|梯度|*cosθ，这意味着当梯度的大小固定时，只有当梯度方向和方向导数同向时方向导数才能取得最大值，换句话说，<code>某点的梯度只有一个，但该点的方向导数有无数个，当方向导数与梯度的方向相同时，该方向导数最大</code>；</p>
<p>换一种方式理解梯度，即借助等值线（将等值线理解为z值不变，绕一圈映射在xoy平面上的路径）</p>
<ul>
<li>等值线是二维平面曲线而非立体曲线；</li>
<li>梯度方向&#x3D;等值线某点法线方向；</li>
</ul>
<p><img src="/images/image-20230320170001272.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-多元函数微分法则"><a href="#2-多元函数微分法则" class="headerlink" title="2.多元函数微分法则"></a>2.多元函数微分法则</h2><h3 id="2-1-链式求导法则"><a href="#2-1-链式求导法则" class="headerlink" title="2.1 链式求导法则"></a>2.1 链式求导法则</h3><ul>
<li>u和v都是中间变量，u和v都是一元函数<img src="/images/image-20230315222438960.png" srcset="/img/loading.gif" lazyload></li>
<li>u和v都是中间变量，u和v都是二元函数<img src="/images/image-20230315222551704.png" srcset="/img/loading.gif" lazyload></li>
<li>其他情形，作图写出对应链式即可</li>
</ul>
<p><img src="/images/image-20230315222648579.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230315222701164.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230315222856107.png" srcset="/img/loading.gif" lazyload></p>
<p>z对x的偏导数表示将y看作不变求x的偏导数(z&#x3D;z(x,y))，f对x的偏导数表示将u和y看作不变求x的偏导数(z&#x3D;f(u,x,y)) – 这句话很绕，简单理解，如果将f也写作z，会出现等式左边和等式右边都出现z对x求偏导，抵消之后就没有了…而实际上z对x求偏导和f对x求偏导的结果是不一样的，所以需要区分书写；</p>
<blockquote>
<p>小技巧：</p>
<ul>
<li>可以利用f’<del>i</del>表示f对第i个位置的变量的一阶偏导数，例如当f(u,v)则f’<del>1</del>表示f对u求偏导，f’<del>2</del>表示f对v求偏导；</li>
<li>可以利用f’’<del>ij</del>表示f对第i个位置的变量求一阶偏导数，然后对f’<del>1</del>的第j个位置的变量求二阶偏导数；</li>
<li>当已知函数的二阶偏导数连续时，f’’<del>12</del>&#x3D;f’’<del>21</del> – 二元函数的两个二阶混合偏导若连续则相等（参考[混合偏导数](#1.4 二元函数的偏导数)）；</li>
</ul>
</blockquote>
<h3 id="2-2-隐函数存在定理"><a href="#2-2-隐函数存在定理" class="headerlink" title="2.2 隐函数存在定理"></a>2.2 隐函数存在定理</h3><p>隐函数就是无法将表达式提取为y关于x的表达式，这并不意味着y和x无关，仅仅只是无法将y用x显式表示。</p>
<p>利用下面的隐函数存在定理，不仅可以判断一个二元方程F(x,y)&#x3D;0是否确定一个一元隐函数(最多可能确定两个一元隐函数)，一个三元方程是否确定一个二元隐函数(最多可能确定三个二元隐函数)，也可以直接求出对应的隐函数的导数。</p>
<p><img src="/images/image-20230315223926088.png" srcset="/img/loading.gif" lazyload alt="二元隐函数"></p>
<p><img src="/images/image-20230315224146196.png" srcset="/img/loading.gif" lazyload alt="三元隐函数"></p>
<blockquote>
<ul>
<li>隐函数存在定理一般只用来判断方程F能够确定几个具有连续偏导的隐函数，正常情况下题干让求解隐函数的偏导数直接左右同时求偏导即可；</li>
<li>公式中的F’<del>x</del>和F’<del>y</del>或F’<del>z</del>都表示F对x或y或z求一阶偏导数；</li>
<li>公式法既可以求解函数在(x<del>0</del>,y<del>0</del>)处偏导数的值，也可以求解函数的偏导数的表达式，区别就在于公式中的F’<del>x</del>、F’<del>y</del>和F’<del>z</del>是具体的值还是表达式；</li>
</ul>
</blockquote>
<h3 id="2-3-逆问题"><a href="#2-3-逆问题" class="headerlink" title="2.3 逆问题"></a>2.3 逆问题</h3><p>一般的偏导数问题都是给出函数表达式z&#x3D;z(x,y)，要求求解z对x或y的偏导。逆问题就是给出z对x或y的偏导，要求使用积分得到原函数表达式z&#x3D;z(x,y)</p>
<p>逆问题本身非常简单，需要注意的是如果已知的是混合偏导，在对y求不定积分时，得到的应该是<code>原函数+关于x的函数φ(x)</code>；而在进一步的对x求偏导时，对于φ(x)其原函数应当也是关于x的函数所以可以仍然用φ(x)表示，注意最后还应当再加上关于y的函数w(y)</p>
<h2 id="3-多元函数的极值和最值"><a href="#3-多元函数的极值和最值" class="headerlink" title="3.多元函数的极值和最值"></a>3.多元函数的极值和最值</h2><p>广义极值的定义</p>
<p><img src="/images/image-20230806190226274.png" srcset="/img/loading.gif" lazyload></p>
<p>广义最值的定义</p>
<p><img src="/images/image-20230806190122089.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>若题干未指明求解的极值(最值)是否广义，则按照广义求解；</li>
</ul>
<h3 id="3-1-无条件最值"><a href="#3-1-无条件最值" class="headerlink" title="3.1 无条件最值"></a>3.1 无条件最值</h3><p>多元函数的<code>无条件最值</code>问题非常简单，可能取得最值的点只可能是<code>驻点、偏导不存在的点、定义域端点</code>，只需要求解这三类点的函数值进行比较即可</p>
<h3 id="3-2-无条件极值"><a href="#3-2-无条件极值" class="headerlink" title="3.2 无条件极值"></a>3.2 无条件极值</h3><p>二元函数取极值的必要条件（表示二元函数取极值的时候能够推出什么结论）</p>
<p><img src="/images/image-20230315231308450.png" srcset="/img/loading.gif" lazyload></p>
<p>二元函数取极值的充分条件（表示满足什么条件的时候二元函数取极值，该充分条件不适用于三元及三元以上的函数）</p>
<p><img src="/images/image-20230315231348783.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Tips：上述充分条件只适用于判断偏导存在的点是否是极值点，对于偏导不存在的点只能用极值定义进行判断。比如函数z&#x3D;|x+y|其在(0,0)点的偏导数根本不存在，因此只能使用极值的定义，因为当(x,y)!&#x3D;(0,0)时总有z(x,y)&gt;&#x3D;0，所以(0,0)是z的极小值点（极值的定义）；</p>
</blockquote>
<p>一般的，求解函数的极值点的主要步骤如下（用必要条件求出可疑点，用充分条件判别可疑点是否是极值点）：</p>
<ol>
<li>解方程组f<del>x</del>(x,y)&#x3D;0和f<del>y</del>(x,y)&#x3D;0，得到驻点（即可疑点，也就是使得f<del>x</del>(x,y)&#x3D;0和f<del>y</del>(x,y)&#x3D;0同时成立的点(x<del>0</del>,y<del>0</del>)）</li>
<li>求解二阶偏导f<del>xx</del>、f<del>xy</del>和f<del>yy</del></li>
<li>判断AC-B^2^结果<ul>
<li>当AC-B^2^&#x3D;0时考虑用极值的定义来检查</li>
</ul>
</li>
<li>最后考虑函数偏导数不存在的点是否是极值点（用极值的定义）<ul>
<li>使用极值定义进行判断，即验证当点(x,y)沿着任意方向(一般选择y&#x3D;x、y&#x3D;-x或y&#x3D;0)趋近该点时的不等式关系是否满足极值定义；</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>Q：驻点和极值点的关系？</p>
</blockquote>
<p>A：无论对一元还是二元函数来说，驻点不一定是极值点(z&#x3D;x^3^)，极值点也不一定是驻点(z&#x3D;|x|)；</p>
<p>对于一元函数来说具有导数的函数的极值点一定是驻点，对于二元函数来说具有偏导数的函数的极值点一定是驻点；</p>
<hr>
<h3 id="3-3-条件极值"><a href="#3-3-条件极值" class="headerlink" title="3.3 条件极值"></a>3.3 条件极值</h3><p>条件极值的问题一般描述为“函数在约束条件下的最值”、“函数在区域D边界上的最大值和最小值”（在区域D内部是无条件极值问题）</p>
<p><img src="/images/image-20230315231418604.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>条件极值最难的地方就在于如何求解方程组，这里最推荐的方法还是采用消元，即消去未知数λ和μ(用x、y、z的表达式来表示它们)；换句话说，目的就是解出未知数x,y,z的值，不关系λ和μ是多少；</li>
<li>辅助函数的构造并不是看目标函数是几元的，而是看限定条件有几个就对应几个新加入的未知数；</li>
</ul>
<h3 id="3-4-闭区域最值"><a href="#3-4-闭区域最值" class="headerlink" title="3.4 闭区域最值"></a>3.4 闭区域最值</h3><p>闭区域最值问题，即求函数在某闭区域D上的最值（属于结合考察条件极值问题和无条件极值问题，在区域D的内部是无条件极值问题，在区域D的边界上是条件极值问题）</p>
<p>多元函数的条件最值的求解方法如下</p>
<p><img src="/images/image-20230723162407455.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="十、二重积分"><a href="#十、二重积分" class="headerlink" title="十、二重积分"></a>十、二重积分</h1><h2 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-二重积分的定义"><a href="#1-1-二重积分的定义" class="headerlink" title="1.1 二重积分的定义"></a>1.1 二重积分的定义</h3><p>一重积分的定义（一重积分也被称为定积分，是一元函数在平面上的积分）：</p>
<p><img src="/images/image-20230724150949197.png" srcset="/img/loading.gif" lazyload></p>
<p>二重积分的定义（二重积分就是二元函数在空间上的积分，大于等于二重积分的积分都称为多元积分）：</p>
<p><img src="/images/image-20230724151008947.png" srcset="/img/loading.gif" lazyload></p>
<p>三重积分的定义（其中f(x,y,z)认为是某点的密度，认为Δv<del>i</del>这部分的体积密度相同）</p>
<p><img src="/images/image-20230724151025154.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>一重积分的几何意义为曲边梯形面积(二维)，二重积分的几何意义为曲顶柱体的体积(三维)，三重积分的物理意义为三维不规则物体的质量(几何意义无法描述)；</li>
<li>二重积分与一重积分需要使用存在定理判断是否存在不同，当函数f(x,y)在闭区域D上连续时函数f(x,y)在D上的二重积分必定存在，一般情况下总认为二重积分在D上连续，即<code>总是认为二重积分存在</code>；</li>
</ul>
</blockquote>
<h3 id="1-2-二重积分的性质"><a href="#1-2-二重积分的性质" class="headerlink" title="1.2 二重积分的性质"></a>1.2 二重积分的性质</h3><p><img src="/images/image-20230401100614672.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-对称性"><a href="#1-3-对称性" class="headerlink" title="1.3 对称性"></a>1.3 对称性</h3><p>二重积分的几何背景是曲顶柱体的体积：“用底面积dσ乘以高f(x,y)，得到一个‘小竖条’的体积，再在区域D上把所有的”小竖条累加起来，就得到了整个曲顶柱体的体积”；</p>
<p>基于上述思路，就可以引出普通对称性和轮换对称性；</p>
<blockquote>
<ul>
<li>一般在计算二重积分之前都需要先考虑对称性，当区间D没有对称性的时候就只能硬算（轮转对换性对某些复杂函数积分可能有奇效）</li>
<li>无论是普通对称性还是轮转对称性都是讨论的积分区域的对称性，而不是被积函数的对称性。因此即使被积函数相同，针对不同的积分区域都可以尝试使用对称性化简；</li>
</ul>
</blockquote>
<h4 id="1-3-1-普通对称性"><a href="#1-3-1-普通对称性" class="headerlink" title="1.3.1 普通对称性"></a>1.3.1 普通对称性</h4><p>普通对称性很好理解，利用二重积分的几何意义将底面积拆分，以积分区域关于y轴对称为例，对称位置上的小竖条体积分别是f(x,y)dσ和f(-x,y)dσ，因此只需要考虑f(x,y)和f(-x,y)之间的关系</p>
<p><img src="/images/image-20230806192537605.png" srcset="/img/loading.gif" lazyload></p>
<p>利用上述思想可以得到如下结论（二重积分包括之后的三重积分、线面积分的对称性都不要背，结合其具体意义理解）</p>
<blockquote>
<p>(1)积分区域关于x轴对称</p>
</blockquote>
<p><img src="/images/image-20230401101355928.png" srcset="/img/loading.gif" lazyload alt="积分区域关于x轴对称"></p>
<blockquote>
<p>(2)积分区域关于y轴对称</p>
</blockquote>
<p><img src="/images/image-20230724155536568.png" srcset="/img/loading.gif" lazyload alt="积分区域关于y轴对称"></p>
<blockquote>
<p>(3)积分区域关于任意直线对称</p>
</blockquote>
<p><img src="/images/image-20230401101542622.png" srcset="/img/loading.gif" lazyload alt="积分区域关于坐标区域内任意直线对称"></p>
<p>关于上述定理主要有如下两个推论（主要记推论，关于任意直线对称这个式子太复杂了）</p>
<p><img src="/images/image-20230401101930045.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230401102001045.png" srcset="/img/loading.gif" lazyload></p>
<p>PS：</p>
<ul>
<li>推论1实际就是下面要介绍的轮转对称性；</li>
<li>当满足f(-x,-y)&#x3D;f(x,y)的时候，并不意味着这个二重积分不为0，将其积分区域化为D<del>1</del>然后在D<del>1</del>区域上进行对称性的分析；</li>
</ul>
<blockquote>
<p>(4)积分区域关于原点对称（大白话就是，将这个区域绕着原点旋转180度，它会和原来的区域完全重合，其结论与积分区域关于y&#x3D;-x对称相同）</p>
</blockquote>
<p><img src="/images/image-20230401101642598.png" srcset="/img/loading.gif" lazyload alt="积分区域关于原点对称"></p>
<h4 id="1-3-2-轮换对称性"><a href="#1-3-2-轮换对称性" class="headerlink" title="1.3.2 轮换对称性"></a>1.3.2 轮换对称性</h4><p>若将x和y对调后，积分区域D不变（即D关于y&#x3D;x对称），则有</p>
<p><img src="/images/image-20230401103117203.png" srcset="/img/loading.gif" lazyload></p>
<p>将这个性质称为轮换对称性，一般使用方法如下</p>
<p><img src="/images/image-20230403161532657.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-二重积分的计算"><a href="#2-二重积分的计算" class="headerlink" title="2.二重积分的计算"></a>2.二重积分的计算</h2><p>按照二重积分的定义来计算二重积分对少数简单的被积函数和积分区域来说是可行的，对于一般的函数和区域来说需要使用其他的方法进行计算（也就是常说的<code>将二重积分化为二次积分计算</code>）；</p>
<ul>
<li>在计算二次积分时，如果被积函数中既有x又有y，但此时是先积y再积x，在对y求积分时x可以视作常数用于凑微分等；</li>
</ul>
<h3 id="2-1-直角坐标系-1"><a href="#2-1-直角坐标系-1" class="headerlink" title="2.1 直角坐标系"></a>2.1 直角坐标系</h3><blockquote>
<p>口诀：“后积先定限，限内画条线，先交写下限，后交写上限”（该口诀同样适用于改变积分次序时的方法）</p>
</blockquote>
<p>在直角坐标系下，按照积分次序的不同，一般将二重积分的计算分为两种情况：</p>
<ul>
<li><p>图(a)表示的是X型区域：穿过D内部且平行y轴的直线与D的边界相交不多于两点；</p>
</li>
<li><p>图(b)表示的是Y型区域：穿过D内部且平行x轴的直线与D的边界相交不多于两点；</p>
</li>
</ul>
<p><img src="/images/image-20230401103535552.png" srcset="/img/loading.gif" lazyload></p>
<p>直角坐标系下的二重积分计算先画出xOy的积分区域，判断是X型区域还是Y型区域：</p>
<ul>
<li>X型区域作平行于y轴的直线与积分区域相交于两点，上面的函数放在积分上限，下面的函数放在积分下限（对应上图(a)，二次积分对应下面(1)）</li>
<li>Y型区域平行于x轴的直线与积分区域相交于两点，右边的函数放在积分上限，左边的函数放在积分下限（对应上图(b)，二次积分对应下面(2)）</li>
</ul>
<p><img src="/images/image-20230401103910822.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>无论是哪种情况，积分下限必须小于等于积分上限（后面会有反例）；</li>
<li>当D既不是X型区域也不是Y型区域时，将D分为多个部分，使得每个部分是X型区域或者是Y型区域；</li>
</ul>
</blockquote>
<h3 id="2-2-极坐标系"><a href="#2-2-极坐标系" class="headerlink" title="2.2 极坐标系"></a>2.2 极坐标系</h3><p>极坐标系下的二重积分计算有以下注意点：</p>
<ul>
<li>极坐标系下几乎所有的计算都是先积r再积θ，不讨论积分次序的交换问题；</li>
<li>一般积分区域是圆、圆环或扇形，或被积函数形如f(x^2^+y^2^)、f(x&#x2F;y)、f(y&#x2F;x)的情况下选择极坐标系；</li>
</ul>
<h4 id="2-2-1-极坐标系概述"><a href="#2-2-1-极坐标系概述" class="headerlink" title="2.2.1 极坐标系概述"></a>2.2.1 极坐标系概述</h4><p>极坐标系的定义如下</p>
<p><img src="/images/image-20230403160937752.png" srcset="/img/loading.gif" lazyload></p>
<p>下面展示一些常用的极坐标方程（基本思想就是先找θ再找ρ，其中ρ的表达式中线是等式，面是不等式；）</p>
<p><img src="/images/image-20230401110614014.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230401110641301.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-2-极坐标系计算"><a href="#2-2-2-极坐标系计算" class="headerlink" title="2.2.2 极坐标系计算"></a>2.2.2 极坐标系计算</h4><p>在极坐标系下，按照积分区域与极点位置关系的不同，一般将二重积分的计算分为三种情况：</p>
<p><img src="/images/image-20230401105155359.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>实际上述三种情况都可以用下面介绍的直角坐标系转极坐标系的方法来记忆，二重积分在极坐标系下的计算考察的重点实际就是直角坐标系转极坐标系；</p>
</blockquote>
<h3 id="2-3-坐标系转换"><a href="#2-3-坐标系转换" class="headerlink" title="2.3 坐标系转换"></a>2.3 坐标系转换</h3><p>二重积分坐标系转换主要分为两种情况，一种是给出极坐标系需要转换为直角坐标系计算如（因为这个积分在极坐标系下非常的难算）</p>
<p><img src="/images/image-20230403162652394.png" srcset="/img/loading.gif" lazyload></p>
<p>一种是给出直角坐标系需要转换为极坐标系下计算如</p>
<p><img src="/images/image-20230403162807611.png" srcset="/img/loading.gif" lazyload></p>
<p>实际上上述两道题在计算能力很强的情况下也可以头铁做出来，但是使用合适的转换方法能够达到事半功倍的效果；</p>
<h4 id="2-3-1-直角坐标系转极坐标系"><a href="#2-3-1-直角坐标系转极坐标系" class="headerlink" title="2.3.1 直角坐标系转极坐标系"></a>2.3.1 直角坐标系转极坐标系</h4><p>将直角坐标系下的二重积分转换为极坐标下的二重积分的主要步骤为：</p>
<ol>
<li>θ上下限：极轴按照逆时针旋转，确定θ的上下限分别是极轴先后经过的夹角；</li>
<li>ρ上下限：旋转极轴与积分区域D先相交的作为下限r<del>1</del>(θ)，后交的作为上限r<del>2</del>(θ)（极点O在积分区域D中则下限为0）；</li>
<li>将f(x,y)中的x和y分别用ρcosθ和ρsinθ代替，末尾额外增加ρdρdθ；</li>
</ol>
<h4 id="2-3-2-极坐标系转直角坐标系"><a href="#2-3-2-极坐标系转直角坐标系" class="headerlink" title="2.3.2 极坐标系转直角坐标系"></a>2.3.2 极坐标系转直角坐标系</h4><p>相对较简单</p>
<ol>
<li>按照对应关系将rsinθ和rcosθ分别转换为y和x，同时必须凑出rdrdθ的形式才能转换出dxdy；</li>
<li>画出积分区域D，按照直角坐标系下的二重积分计算法则将二重积分拆为二次积分计算；</li>
</ol>
<h4 id="2-3-3-交换积分次序"><a href="#2-3-3-交换积分次序" class="headerlink" title="2.3.3 交换积分次序"></a>2.3.3 交换积分次序</h4><p>除了上述转换坐标系的想法，适当的交换积分次序也可以达到简化计算二重积分的效果（针对某些被积函数对某个变量的原函数无法使用初等函数表示的情况）</p>
<p><img src="/images/image-20230725150354999.png" srcset="/img/loading.gif" lazyload alt="例题"></p>
<h1 id="十一、常微分方程"><a href="#十一、常微分方程" class="headerlink" title="十一、常微分方程"></a>十一、常微分方程</h1><h2 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>微分方程的定义：表示未知函数y及其导数（或微分）与自变量x之间关系的方程，简单来说只要含有微分或导数的方程，无论几阶都称为微分方程，n阶微分方程的形式为</p>
<p><img src="/images/image-20230403171431011-16805133404292.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>在n阶微分方程中，y^(n)^必须出现，其他变量如x,y,…,y^(n-1)^可有可无；</li>
<li>微分方程其实就是隐函数F或未知函数y求导的结果，求解微分方程目的就是反求出隐函数F或未知函数y；</li>
</ul>
</blockquote>
<p>常微分方程的定义：</p>
<p><img src="/images/image-20230403171752656.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>偏微分方程是指包含未知函数的偏导数&#x2F;偏微分的方程，在这一章中讨论的都是常微分方程，无需过多关注偏微分方程；</li>
<li>再次声明这个“常”并不是代表常数，而是表示未知函数y&#x3D;f(x)是一个一元函数；</li>
</ul>
</blockquote>
<p>若微分方程的解中含有的独立常数的个数等于微分方程的阶数，则该解称为微分方程的通解（微分方程的解是一个函数）</p>
<p><img src="/images/image-20230403172010112.png" srcset="/img/loading.gif" lazyload></p>
<p>当确定了通解中的常数后，通解就成了特解；</p>
<blockquote>
<ul>
<li>独立：指的是经过任何恒等变形都无法使得常数的个数减少，如y&#x3D;C<del>1</del>x+C<del>2</del>；</li>
</ul>
</blockquote>
<h2 id="2-一阶微分方程"><a href="#2-一阶微分方程" class="headerlink" title="2.一阶微分方程"></a>2.一阶微分方程</h2><h3 id="2-1-变量可分离型"><a href="#2-1-变量可分离型" class="headerlink" title="2.1 变量可分离型"></a>2.1 变量可分离型</h3><p>能把微分方程写成一端只含y的函数和dy，另一端只含x的函数和 dx，那么原方程就称为可分离变量的微分方程；</p>
<p>变量可分离型的微分方程解法非常简单，只需要两边同时求积分即可</p>
<p><img src="/images/image-20230403172219547.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>有时候将g(y)放在分母中即附加了条件g(y)!&#x3D;0，这可能导致最后的通解并不是全部解，一般情况下我们将g(y)&#x3D;0代入假如此时方程也成立，称之为奇解，考虑通解中C是否能够取得某个常数使得通解能够表示为奇解的形式，如果不能则直接写原本的通解即可，否则加上奇解；</p>
</blockquote>
<h3 id="2-2-可化为变量可分离型"><a href="#2-2-可化为变量可分离型" class="headerlink" title="2.2 可化为变量可分离型"></a>2.2 可化为变量可分离型</h3><h4 id="2-2-1-非齐次型微分方程"><a href="#2-2-1-非齐次型微分方程" class="headerlink" title="2.2.1 非齐次型微分方程"></a>2.2.1 非齐次型微分方程</h4><p>使用换元法，令u&#x3D;ax+by+c，化为可分离变量的形式</p>
<p><img src="/images/image-20230403172355343.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-2-齐次型微分方程"><a href="#2-2-2-齐次型微分方程" class="headerlink" title="2.2.2 齐次型微分方程"></a>2.2.2 齐次型微分方程</h4><p>同样使用换元法，令u&#x3D;y&#x2F;x化为可分离变量的形式</p>
<p><img src="/images/image-20230403172456102.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<blockquote>
<p>Q：如何判断一个方程是否齐次？齐次型方程和齐次方程有关系吗？</p>
</blockquote>
<p>A：齐次即x和y的次数对称（注意并不是相等），在微分方程的领域两次使用到齐次的叫法，分别是齐次型方程和齐次方程</p>
<ul>
<li>齐次型方程是指形如y’&#x3D;φ(y&#x2F;x)的方程，指的是方程中的每一项关于x和y的次数都是相等的，x^2^,xy,y^2^都是二次项，x,y,dy,dx都是一次项，dy&#x2F;dx,C(常数),y&#x2F;x都是零次项；</li>
<li>齐次方程是指形如y’’+py’+qy&#x3D;0的方程，指的是方程中每一项关于未知函数y及其导数y’,y’’…的次数都是相等的<ul>
<li>y’’+py’+qy&#x3D;0称为齐次方程，因为未知数y和它的导数次数相等，都是一次的；</li>
<li>y’’+py’+qy&#x3D;x称为非齐次方程，因为y及其导数的次数都是一次的，但是x不包含y及y的导数，即x是关于y及y的导数的0次项，因此称为非齐次方程；</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-一阶线性微分方程"><a href="#2-3-一阶线性微分方程" class="headerlink" title="2.3 一阶线性微分方程*"></a>2.3 一阶线性微分方程*</h3><p>该类型的考频最高，同时也是后续各种微分方程求解的基础，一般情况下使用公式法解决。一阶表示y的导数是y’，线性表示y’和y之间的关系都是一次线性的，假如q(x)是0则称为齐次方程，假如q(x)不是0则称为非齐次方程；</p>
<p><img src="/images/image-20230403172644332.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>某些时候题干所给的公式并不是已知类型（可分离变量、一阶线性），需要结合恒等变形和换元化为已知类型，比如y’+1&#x3D;e^-y^sinx就可以先恒等变形为(e^y^)’+e^y^&#x3D;sinx，再令e^y^&#x3D;u得到u’+u&#x3D;sinx；</p>
</blockquote>
<h3 id="2-4-伯努利方程"><a href="#2-4-伯努利方程" class="headerlink" title="2.4 伯努利方程"></a>2.4 伯努利方程</h3><p>伯努利方程的形式中要求n!&#x3D;0,1，因为n&#x3D;0时是一阶线性微分方程，n&#x3D;1时是可分离变量方程(注意不是n的阶乘等于而是n不等于)；</p>
<p>对其进行求解的方式很简单，直接同时除以y^n^然后换元将其化为一阶线性微分方程后使用公式法求解；</p>
<p><img src="/images/image-20230403172749812.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>常微分方程的自变量和因变量是相对的，有些时候需要根据具体的题干选择自变量和未知函数，不可盲目求解</p>
<ul>
<li><p>y’+p(x)y&#x3D;q(x)y^n^这是以x为自变量，y为未知函数的伯努利方程；</p>
</li>
<li><p>dx&#x2F;dy-x&#x2F;y&#x3D;(lny&#x2F;y)*x^2^这是以y为自变量，x为未知函数的伯努利方程，左右同时除以x^n^并且令z&#x3D;x^1-n^换元即可求解；</p>
</li>
</ul>
</blockquote>
<h2 id="3-二阶可降阶微分方程"><a href="#3-二阶可降阶微分方程" class="headerlink" title="3.二阶可降阶微分方程"></a>3.二阶可降阶微分方程</h2><h3 id="3-1-y’’-x3D-f-x-y’-型"><a href="#3-1-y’’-x3D-f-x-y’-型" class="headerlink" title="3.1 y’’&#x3D;f(x,y’)型"></a>3.1 y’’&#x3D;f(x,y’)型</h3><p>该形式方程中不显示含未知函数y</p>
<p><img src="/images/image-20230403172945195.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这种形式相对简单，因为缺少y所以要y’和y’’没用，直接用p将y’替换即可；</p>
</blockquote>
<h3 id="3-2-y’’-x3D-f-y-y’-型"><a href="#3-2-y’’-x3D-f-y-y’-型" class="headerlink" title="3.2 y’’&#x3D;f(y,y’)型"></a>3.2 y’’&#x3D;f(y,y’)型</h3><p>该方程中不显示含自变量x</p>
<p><img src="/images/image-20230403173026886.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这种形式相对第一种有一点难度，因为需要降阶所以还是需要令y’&#x3D;p，但是因为不能显式出现x，所以对于y’’的表示需要使用dy来代替；</p>
</blockquote>
<h2 id="3-高阶线性微分方程"><a href="#3-高阶线性微分方程" class="headerlink" title="3.高阶线性微分方程"></a>3.高阶线性微分方程</h2><h3 id="3-1-二阶微分方程"><a href="#3-1-二阶微分方程" class="headerlink" title="3.1 二阶微分方程"></a>3.1 二阶微分方程</h3><h4 id="3-1-1-基本概念"><a href="#3-1-1-基本概念" class="headerlink" title="3.1.1 基本概念"></a>3.1.1 基本概念</h4><p>前面介绍了二阶可降阶微分方程，此处主要介绍二阶不可降阶方程的求解，首先介绍几个概念：</p>
<ul>
<li>二阶变系数线性微分方程：<img src="/images/image-20230412230842786.png" srcset="/img/loading.gif" lazyload>其中p(x)和q(x)称为系数函数，f(x)称为自由项；</li>
<li>二阶常系数线性微分方程：<img src="/images/image-20230412230909865.png" srcset="/img/loading.gif" lazyload>其中p,q为常数，f(x)为自由项；</li>
</ul>
<p>当f(x)&#x3D;0时称为齐次方程，否则称为非齐次方程；考研基本都考察的是常系数微分方程，变系数只需了解即可（常系数作为变系数的特例更加简单，考研不对不可降阶的二阶变系数方程做要求）；</p>
<h4 id="3-1-2-解的结构"><a href="#3-1-2-解的结构" class="headerlink" title="3.1.2 解的结构"></a>3.1.2 解的结构</h4><p>二阶微分方程解的结构大致可分为以下三种形式（无论是针对变系数还是常系数都通用）：</p>
<ul>
<li>二阶齐次线性微分方程的通解：<img src="/images/image-20230412231248008.png" srcset="/img/loading.gif" lazyload></li>
<li>二阶非齐次线性微分方程的通解：<img src="/images/image-20230412231425456.png" srcset="/img/loading.gif" lazyload>即齐次线性的通解+非齐次线性的特解；</li>
<li>二阶非齐次线性微分方程的特解：<img src="/images/image-20230412231515330.png" srcset="/img/loading.gif" lazyload>其中y *<del>1</del>(x)和y *<del>2</del>(x)分别是<img src="/images/image-20230412231611284.png" srcset="/img/loading.gif" lazyload>和<img src="/images/image-20230412231635131.png" srcset="/img/loading.gif" lazyload>的特解（这种形式一般是解决自由项较复杂的时候将其拆分分别处理，最后再叠加)；</li>
</ul>
<h3 id="3-2-二阶常系数微分方程的解"><a href="#3-2-二阶常系数微分方程的解" class="headerlink" title="3.2 二阶常系数微分方程的解"></a>3.2 二阶常系数微分方程的解</h3><h4 id="3-2-1-二阶齐次微分方程的通解"><a href="#3-2-1-二阶齐次微分方程的通解" class="headerlink" title="3.2.1 二阶齐次微分方程的通解"></a>3.2.1 二阶齐次微分方程的通解</h4><p>前面介绍的解的结构只是二阶微分方程最终解的形式，这里给出具体解题过程中如何求通解和特解（根据考研大纲，只要求掌握常系数微分方程的求解即可）；</p>
<p>对于y’’+py’+qy&#x3D;0，其对应的特征方程为r^2^+pr+q&#x3D;0（如何得到的参见张宇视频，可以直接硬背），对特征方程求根，有以下三种情况分别对应了齐次微分方程的通解</p>
<p><img src="/images/image-20230412232241704.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-2-2-二阶非齐次微分方程的特解"><a href="#3-2-2-二阶非齐次微分方程的特解" class="headerlink" title="3.2.2 二阶非齐次微分方程的特解"></a>3.2.2 二阶非齐次微分方程的特解</h4><p>因为非齐次的通解&#x3D;齐次的通解+非齐次的特解，上面已经讨论过齐次的通解，因此这里只需要讨论非齐次的特解；</p>
<p>对于y’’+py’+q&#x3D;f(x)，最重要的是如何设置其特解y*，主要根据自由项的形式不同设置不同的特解，设置之后将特解反向代入非齐次方程得到特解的形式；</p>
<p><img src="/images/image-20230412233039921.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-3-n阶常系数微分方程的解"><a href="#3-3-n阶常系数微分方程的解" class="headerlink" title="3.3 n阶常系数微分方程的解"></a>3.3 n阶常系数微分方程的解</h3><p>称如下形式的微分方程为n阶常系数齐次线性微分方程</p>
<p><img src="/images/image-20230412233113129.png" srcset="/img/loading.gif" lazyload></p>
<p>其对应的特征方程为</p>
<p><img src="/images/image-20230412233153799.png" srcset="/img/loading.gif" lazyload></p>
<p>根据特征方程求出其特征根，根据特征根的情况可以得到微分方程的解的情况（注意这里列举出的特征根的情况更严谨的表达应该是，如果特征根中出现如下情况…）</p>
<p><img src="/images/image-20230412233332684.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>上面的解题笔记都是针对考研大纲要求整理的，对于考研不要求的其他形式不做介绍</p>
</blockquote>
<h1 id="十二、无穷级数"><a href="#十二、无穷级数" class="headerlink" title="十二、无穷级数"></a>十二、无穷级数</h1><p>级数是指一个有穷或无穷的序列的和，如果序列是有穷序列则其和称为有穷级数，否则称为无穷级数（一般简称为级数）。常见的简单有穷级数包括等差数列、等比数列，本章介绍的所有级数都是无穷级数。</p>
<p>无论是什么级数，研究其敛散性的过程中始终贯穿这样的方法：级数与其对应的部分和数列同时收敛或发散，因此判断级数的敛散性问题可转换为判断部分和数列极限是否存在的问题</p>
<ol>
<li>写出部分和数列{S<del>n</del>}</li>
<li>求S<del>n</del>的极限lim<del>n-&gt;∞</del>S<del>n</del><ul>
<li>若极限存在则称级数收敛；</li>
<li>若极限不唯一、不存在或无穷则称级数发散；</li>
</ul>
</li>
</ol>
<h2 id="1-常数项级数"><a href="#1-常数项级数" class="headerlink" title="1.常数项级数"></a>1.常数项级数</h2><h3 id="1-1-概念和性质"><a href="#1-1-概念和性质" class="headerlink" title="1.1 概念和性质"></a>1.1 概念和性质</h3><p>若无穷项级数形式如下</p>
<p><img src="/images/image-20230416160757940.png" srcset="/img/loading.gif" lazyload></p>
<p>其通项u<del>n</del>是常数而不是函数，则该级数称为常数项无穷级数。</p>
<p>常数项级数主要有如下性质：</p>
<p><img src="/images/image-20230416161308014.png" srcset="/img/loading.gif" lazyload alt="线性性质"></p>
<p><img src="/images/image-20230416161329285.png" srcset="/img/loading.gif" lazyload alt="级数敛散性与有限项的增减无关"></p>
<blockquote>
<p>Tips：这个性质可以简单说成是“改变级数的任意有限项，不会改变该级数的敛散性”（此处的有限项既指的数量有限，也指的大小有限，大小为无穷的数没有资格成为级数的项）</p>
</blockquote>
<p><img src="/images/image-20230416161452164.png" srcset="/img/loading.gif" lazyload alt="通项极限为0"></p>
<blockquote>
<p>Tips：该性质是级数收敛的必要条件但不是充分条件，这意味着当通项为0时级数不一定收敛，其逆否命题即“通项的极限不为0则级数发散”常用于判决级数发散；</p>
</blockquote>
<h3 id="1-2-级数审敛法"><a href="#1-2-级数审敛法" class="headerlink" title="1.2 级数审敛法"></a>1.2 级数审敛法</h3><p>下面直接给出正项级数、交错级数和一般级数的敛散性判别法，这里是简介版的汇总，紧接着会对每个判别法进行详细的说明</p>
<p><img src="/images/image-20230728150748787.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-2-1-正项级数"><a href="#1-2-1-正项级数" class="headerlink" title="1.2.1 正项级数"></a>1.2.1 正项级数</h4><p>若通项u<del>n</del>&gt;&#x3D;0则称级数为正项级数，主要有五种敛散性的判别方法（这意味着如下五种方法都只适用于正项级数）。</p>
<h5 id="1-收敛原则"><a href="#1-收敛原则" class="headerlink" title="(1)收敛原则"></a>(1)收敛原则</h5><p>收敛原则的证明非常简单，只需要抓住“正项级数的部分和数列{S<del>n</del>}是一个单调不减且下界为0的数列”这一性质即可。直接使用收敛原则的情形很少见，因为{S<del>n</del>}的有界性实际并不好证明，更常用的是后面四种正项级数的敛散性判别法</p>
<p><img src="/images/image-20230416162258841.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>此处的有界指的是既有上界又有下界，实际的收敛原则就是从级数敛散性的定义拓展得来；</li>
</ul>
<h5 id="2-比较判别法"><a href="#2-比较判别法" class="headerlink" title="(2)比较判别法"></a>(2)比较判别法</h5><p><img src="/images/image-20230416162406800.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>可以通俗的理解为“两个正项级数，大的收敛则小的必定收敛；小的发散则大的必定发散”；</li>
<li>使用比较判别法需要首先选择使用小于还是大于，这决定了如何进行放缩，一般情况下这是很难的一件事，所以一般情况下比较判别法使用的也比较少；</li>
</ul>
<h5 id="3-比较判别法的极限形式"><a href="#3-比较判别法的极限形式" class="headerlink" title="(3)比较判别法的极限形式"></a>(3)比较判别法的极限形式</h5><p>该判别法的证明直接用高阶无穷小、同阶无穷小以及低阶无穷小证明即可</p>
<p><img src="/images/image-20230416162546100.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>一般选择v<del>n</del>是已知敛散性的级数<img src="/images/image-20230416170544427.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>比较判别法的极限形式一定要注意失效条件</p>
<ul>
<li>若v<del>n</del>收敛但A&#x3D;+∞则失效；</li>
<li>若v<del>n</del>发散但A&#x3D;0则失效；</li>
</ul>
</li>
</ul>
<h5 id="4-比值判别法"><a href="#4-比值判别法" class="headerlink" title="(4)比值判别法"></a>(4)比值判别法</h5><p>也称为达朗贝尔判别法</p>
<p><img src="/images/image-20230416162620656.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>极限审敛法是和别人比较，需要选择比较对象，使用比值审敛法可以直接与自己的通项比较（适用于<code>通项中出现阶乘</code>）；</li>
<li>如果ρ&#x3D;1则不能使用此方法判别级数的敛散性(失效)，只能使用其他方法；</li>
</ul>
<h5 id="5-根值判别法"><a href="#5-根值判别法" class="headerlink" title="(5)根值判别法"></a>(5)根值判别法</h5><p>也称为柯西判别法</p>
<p><img src="/images/image-20230416162750669.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>根植审敛法甚至直接是基于自身进行敛散性的判别，一般情况下<code>通项有n次方</code>可以选择该方法；</li>
<li>同样的，如果ρ&#x3D;1则无法使用该方法判别级数敛散性(失效)，只能使用其他方法；</li>
</ul>
<h5 id="6-积分判别法"><a href="#6-积分判别法" class="headerlink" title="(6)积分判别法"></a>(6)积分判别法</h5><p>（该判别法是张宇额外补充的积分法，后续强化阶段还会深入）</p>
<p><img src="/images/image-20230806200814739.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-2-2-交错级数"><a href="#1-2-2-交错级数" class="headerlink" title="1.2.2 交错级数"></a>1.2.2 交错级数</h4><p>若级数的各项出现严格正负相间的情况，则称这样的级数为交错级数（若不严格则称为任意项级数），一般写为（这样可以使得各项的正负号明显的呈现）</p>
<p><img src="/images/image-20230416163057666.png" srcset="/img/loading.gif" lazyload></p>
<p>交错级数的判别法只有一个，被称为莱布尼茨判别法：</p>
<p><img src="/images/image-20230416163224766.png" srcset="/img/loading.gif" lazyload></p>
<p>更加形式化的判断条件如下，若满足如下两个条件则交错级数收敛</p>
<p><img src="/images/image-20230416171007244.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>交错级数的考点在于题干不会直接告知级数是交错级数，需要将通项化简为(-1)^n^相关的形式；</li>
<li>莱布尼兹判别法严格要求需要在整个定义域上u<del>n</del>均单调不减，但实际上因为前有限项求和并不会影响级数整体的敛散性，所以可以只研究当n-&gt;+∞时u<del>n</del>的单调性！！！</li>
</ul>
</blockquote>
<h4 id="1-2-3-任意项级数"><a href="#1-2-3-任意项级数" class="headerlink" title="1.2.3 任意项级数"></a>1.2.3 任意项级数</h4><p>若级数各项可正可负或为0，称这样的级数为任意项级数（一般级数），对于任意项级数的敛散性判别，主要是研究其绝对值级数的敛散性</p>
<p><img src="/images/image-20230416163505143.png" srcset="/img/loading.gif" lazyload></p>
<p>有以下简单的口诀可以判断部分任意级数的敛散性（关于任意级数本身的敛散性的判定的内容是超纲的）</p>
<p><img src="/images/image-20230416172002261.png" srcset="/img/loading.gif" lazyload></p>
<p>可以知道绝对值级数就是前面介绍的正项级数，因此可以使用正项级数的判别法，绝对值级数和原任意项级数的敛散性的关系如下：</p>
<p><img src="/images/image-20230416163637080.png" srcset="/img/loading.gif" lazyload></p>
<p>关于这个定理很好理解，因为如果u<del>n</del>是有正有负或者全部负数，而|u<del>n</del>|绝对值级数是绝对收敛的，那么u<del>n</del>求和要么是正负抵消要么是加负号，同样也是收敛的；</p>
<h4 id="1-2-4-抽象级数"><a href="#1-2-4-抽象级数" class="headerlink" title="1.2.4 抽象级数"></a>1.2.4 抽象级数</h4><p>一个非常典型的条件转换技巧为：将一个级数收敛或通项趋于0转换为当n充分大时，通项|u<del>n</del>|&lt;1；</p>
<p>额外的，有如下常见抽象数项级数的敛散性判别结论</p>
<p><img src="/images/image-20230806201605515.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-收敛级数的性质"><a href="#1-3-收敛级数的性质" class="headerlink" title="1.3 收敛级数的性质"></a>1.3 收敛级数的性质</h3><blockquote>
<p>性质1：收敛级数的项任意加括号后所得的新级数仍收敛，且其和不变；</p>
</blockquote>
<p>这个性质很容易证明得到，即根据收敛数列的子数列同样收敛；</p>
<p>可以根据性质1推出如下两个推论：</p>
<ul>
<li>若加括号后得到的新级数发散，则原级数必然发散（逆否命题）；</li>
<li>若加括号后得到的新级数收敛，不能断言原级数一定收敛；</li>
</ul>
<blockquote>
<p>性质2：若原级数绝对收敛，不论将其各项如何重新排列，所得的新级数也绝对收敛，且其和不变（换句话说，绝对收敛的级数具有可交换性）</p>
</blockquote>
<h3 id="1-4-常见常数项级数"><a href="#1-4-常见常数项级数" class="headerlink" title="1.4 常见常数项级数"></a>1.4 常见常数项级数</h3><p><img src="/images/image-20230416225507853.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-幂级数"><a href="#2-幂级数" class="headerlink" title="2.幂级数"></a>2.幂级数</h2><p>幂级数章节的基本考点分为两个：判断幂级数在哪个收敛域上收敛以及收敛时其和函数是什么，这一节将围绕这两个考点展开；</p>
<h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p>在介绍幂级数之前需要先介绍函数项级数，函数项级数的定义如下</p>
<p><img src="/images/image-20230416164147545.png" srcset="/img/loading.gif" lazyload></p>
<p>简单来说函数项级数就是级数的通项不是常数而是函数，函数项级数的特点就在于其通项不仅与n有关还与x有关；</p>
<p>若函数项级数的通项u<del>n</del>(x)是x的n次幂函数，则称该函数项级数为幂级数，其一般形式为</p>
<p><img src="/images/image-20230416164409412.png" srcset="/img/loading.gif" lazyload></p>
<p>其标准形式为（其中a<del>n</del>称为幂级数的系数）</p>
<p><img src="/images/image-20230416164431736.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>幂级数的下标究竟是从0开始还是从1开始不用纠结，每个地方的定义都不太一样</p>
</blockquote>
<h3 id="2-2-幂级数审敛法"><a href="#2-2-幂级数审敛法" class="headerlink" title="2.2 幂级数审敛法"></a>2.2 幂级数审敛法</h3><p>研究幂级数（一般研究的都是标准幂级数，也就是x<del>0</del>为0的情况），首要任务是判定其敛散性，只有在收敛情况下的幂级数才有继续讨论的意义（考研不会考察发散域上的幂级数，因为只有幂级数收敛其和函数才能被表示出来进而被进一步研究）</p>
<ul>
<li>收敛域：函数项级数的所有收敛点的集合</li>
<li>发散域：函数项级数的所有发散点的集合</li>
</ul>
<p>求解收敛域最直观的方式是代入某个具体的x使其成为常数项级数进而判别其是否收敛，但是一般来说收敛点或发散点是非常多的，使用这种代入方法逐个验证显然不现实，因此有如下的阿贝尔定理：</p>
<p><img src="/images/image-20230416165007885.png" srcset="/img/loading.gif" lazyload alt="阿贝尔定理"></p>
<h4 id="2-2-1-阿贝尔定理"><a href="#2-2-1-阿贝尔定理" class="headerlink" title="2.2.1 阿贝尔定理"></a>2.2.1 阿贝尔定理</h4><p>阿贝尔定理可以用下面更加标准化的语言来描述（标准幂级数在x&#x3D;0点必定收敛），这个推论也是解题常用的</p>
<p><img src="/images/image-20230416173835572.png" srcset="/img/loading.gif" lazyload></p>
<p>由阿贝尔定理推出求解收敛半径、收敛区间和收敛域（收敛域&#x3D;收敛区间+收敛端点）的方法如下</p>
<p><img src="/images/image-20230416165253738.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-2-幂级数的收敛域"><a href="#2-2-2-幂级数的收敛域" class="headerlink" title="2.2.2 幂级数的收敛域"></a>2.2.2 幂级数的收敛域</h4><p>使用阿贝尔的推论求解收敛半径需要保证级数的幂次是连续的且x<del>0</del>&#x3D;0，也就意味着针对通项为(x-1)^2n^这种类型的幂级数不能直接使用阿贝尔推论求解收敛域，下面介绍更常用的幂级数的收敛域的求解方法。</p>
<p>幂级数的收敛域问题主要分为具体型和抽象型，关于幂级数收敛有以下几个重要结论（均可由阿贝尔定理推导得到）</p>
<blockquote>
<ol>
<li>幂级数的田间收敛点只可能在收敛域的端点取得；</li>
<li>幂级数加绝对值与否只会影响其端点处的敛散性，不会影响其内部的敛散性；</li>
<li>幂级数的收敛域若包含端点则该端点一定条件收敛，而在区间内部一定绝对收敛；</li>
</ol>
</blockquote>
<h5 id="1-具体型"><a href="#1-具体型" class="headerlink" title="(1)具体型"></a>(1)具体型</h5><p>针对具体型的幂级数求解其收敛域的步骤如下</p>
<p><img src="/images/image-20230806202958902.png" srcset="/img/loading.gif" lazyload alt="具体型幂级数的收敛域"></p>
<h5 id="2-抽象型"><a href="#2-抽象型" class="headerlink" title="(2)抽象型"></a>(2)抽象型</h5><p>针对抽象性的幂级数的收敛域求解问题，需要掌握以下相关结论</p>
<p><img src="/images/image-20230806203728620.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-幂级数求和"><a href="#2-3-幂级数求和" class="headerlink" title="2.3 幂级数求和"></a>2.3 幂级数求和</h3><p>若幂级数收敛，那么所有的项求和的结果是多少（这个求和的结果是关于x的一个函数）？这就是幂级数求和的引出，幂级数的和函数与和函数展开是同一个问题的不同对立面。</p>
<p>幂级数求和的定义为（即使用一个函数S(x)来表示无穷项的级数）</p>
<p><img src="/images/image-20230416165554838.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>注意一定是在收敛域上讨论幂级数求和以及和函数展开，因为对于级数来说只有当其收敛时其和才能被表示出来，对于幂函数来说只有在其收敛域上才可能有和函数的概念；</li>
</ul>
</blockquote>
<h4 id="2-3-1-和函数的运算法则"><a href="#2-3-1-和函数的运算法则" class="headerlink" title="2.3.1 和函数的运算法则"></a>2.3.1 和函数的运算法则</h4><p>幂级数的和函数的有如下运算法则</p>
<p><img src="/images/image-20230416174613168.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>其中第二条法则非常重要，注意其使用条件是当系数下标和x的幂次相同，当不满足条件时需要进行处理，主要有以下三种处理方式</p>
<ul>
<li>通项、下标一起变（其中l为整数，可正可负可为0）</li>
</ul>
<p><img src="/images/image-20230416223841233.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>只变下标，不变通项（加减）</li>
</ul>
<p><img src="/images/image-20230416223933292.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>只变通项，不变下标（乘除）</li>
</ul>
<p><img src="/images/image-20230416224015514.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="2-3-2-和函数的性质"><a href="#2-3-2-和函数的性质" class="headerlink" title="2.3.2 和函数的性质"></a>2.3.2 和函数的性质</h4><p>幂级数的和函数有如下性质</p>
<p><img src="/images/image-20230729091653525.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-3-3-重要展开式"><a href="#2-3-3-重要展开式" class="headerlink" title="2.3.3 重要展开式"></a>2.3.3 重要展开式</h4><p>如下七个重要展开式都需要熟练记忆，无论是幂级数求和还是和函数展开都会用到</p>
<p><img src="/images/image-20230416224223282.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-3-4-方法总结"><a href="#2-3-4-方法总结" class="headerlink" title="2.3.4 方法总结"></a>2.3.4 方法总结</h4><p>当题干要求求解具体幂级数的和函数，主要按照如下步骤进行：</p>
<ol>
<li>首先求出收敛域（之后的积分或求导都有可能导致收敛域的改变，因此一开始就求解出收敛域可以保证结果不出错）</li>
<li>设和函数S(x)&#x3D;具体幂级数（这样写是有必要的！！！后续最终结果以及是否需要分类讨论均基于这一步的假设）</li>
<li>处理幂级数（目的是将幂级数转换为已知重要展开式）<ul>
<li>先求导再积分：当(an+b)^c^在分母上</li>
<li>先积分再求导：当(an+b)^c^在分子上</li>
<li>无论是先积分还是后积分，积分的上限都为x下限都为展开点&#x2F;中心点；并且针对先导后积的情况有<img src="/images/image-20230806205517296.png" srcset="/img/loading.gif" lazyload>，也就是说不要理所当然的认为S(x)和变限积分完全等价（先积后导没有这个问题)；</li>
</ul>
</li>
<li>基于第二步设的S(x)和第三步的结果，得到最终结论</li>
</ol>
<p>额外的，可以记忆以下两个常见幂级数的和函数，在求解某些问题时可以直接使用</p>
<p><img src="/images/image-20230806205616073.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-4-和函数展开"><a href="#2-4-和函数展开" class="headerlink" title="2.4 和函数展开"></a>2.4 和函数展开</h3><p>与幂级数求和的一个相对的概念是和函数展开，即将和函数用幂级数表示，实际的应用意义在于可用于近似表示某些问题。</p>
<p>函数展开成幂级数的概念如下</p>
<p><img src="/images/image-20230416224357448.png" srcset="/img/loading.gif" lazyload></p>
<p>无论是泰勒级数还是麦克劳林级数都称为和函数展开</p>
<blockquote>
<p>泰勒&#x2F;麦克劳林展开式与泰勒&#x2F;麦克劳林级数的区别在于，前者是有限个幂函数求和之后再加上一个余项，后者是无限个幂函数求和；</p>
<p>两者的共同点在于都使用多项式函数来逼近一个函数；</p>
<p>一个函数是否能够在区间内展开成幂级数的<code>充分必要条件</code>是其泰勒展开式的拉格朗日余项在该区间内是否趋于0；</p>
</blockquote>
<p>和函数展开主要有两种方式：</p>
<ul>
<li>直接展开法：直接逐个计算展开的各项<img src="/images/image-20230416224729827.png" srcset="/img/loading.gif" lazyload>，然后代入展开式，但是这种方法一般都不会使用；</li>
<li>间接展开法：利用已知的幂级数展开式，通过变量代换、四则运算、逐项求导、逐项积分和待定系数法等方法得到函数的展开式；</li>
</ul>
<h4 id="2-4-1-方法总结"><a href="#2-4-1-方法总结" class="headerlink" title="2.4.1 方法总结"></a>2.4.1 方法总结</h4><p>和函数展开成幂级数，而幂级数无非分为泰勒级数和麦克劳林级数，主要有直接展开法和间接展开法，这里只介绍简介展开法的基本解题流程：</p>
<ol>
<li>化简处理原表达式<ul>
<li>如题干要求将原函数展开为x-3的幂级数，或求原函数在x&#x3D;3处的幂级数展开，需要先构造出x-3的表达式</li>
<li>简单的化简处理就是恒等变形，高级的化简处理包括先导后积和先积后导（先导后积的积分上限为x下限为展开点，且注意f(x)与其定积分相差一个f(下限)）</li>
</ul>
</li>
<li>使用已知展开式替换并结合收敛域写出成立范围</li>
<li>分析级数在端点的敛散性，整理表达式得出最终结果</li>
</ol>
<h1 id="十三、数一专项"><a href="#十三、数一专项" class="headerlink" title="十三、数一专项"></a>十三、数一专项</h1><p>本章主要将前面几章中<code>未涉及</code>的数学一的专题内容做一个总结。下面是一些基本的物理公式需要记忆</p>
<table>
<thead>
<tr>
<th>物理量</th>
<th>计算公式</th>
</tr>
</thead>
<tbody><tr>
<td>重力</td>
<td>GMm&#x2F;R^2^</td>
</tr>
<tr>
<td>浮力</td>
<td>ρgV</td>
</tr>
<tr>
<td>压强</td>
<td>F&#x2F;S，ρgh</td>
</tr>
<tr>
<td>牛顿第二定律</td>
<td>F&#x3D;ma(物体加速度与外力成正比)</td>
</tr>
</tbody></table>
<h2 id="1-一元函数微分学应用"><a href="#1-一元函数微分学应用" class="headerlink" title="1.一元函数微分学应用"></a>1.一元函数微分学应用</h2><p>在介绍物理应用之前先介绍一个重要的概念 – 相关变化率，实际上就是将未知变化率的求解转换为已知变化率</p>
<p><img src="/images/image-20230515230411960.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-1-物理应用"><a href="#1-1-物理应用" class="headerlink" title="1.1 物理应用"></a>1.1 物理应用</h3><p>一元导数的物理意义非常简单，主要就是速度和加速度的计算公式</p>
<p><img src="/images/image-20230515230717158.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-2-几何应用"><a href="#1-2-几何应用" class="headerlink" title="1.2 几何应用"></a>1.2 几何应用</h3><p>一元导数的几何应用也非常简单，主要用于计算曲率和曲率半径，考察点在于公式的记忆和计算能力</p>
<p><img src="/images/image-20230515231050628.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-一元函数积分学应用"><a href="#2-一元函数积分学应用" class="headerlink" title="2.一元函数积分学应用"></a>2.一元函数积分学应用</h2><h3 id="2-1-物理应用"><a href="#2-1-物理应用" class="headerlink" title="2.1 物理应用"></a>2.1 物理应用</h3><p>这里的题型是对一类题型的总结，其解题方法具有参考意义，并不仅限于解答给出的题型</p>
<h4 id="2-1-1-变力沿直线做功"><a href="#2-1-1-变力沿直线做功" class="headerlink" title="2.1.1 变力沿直线做功"></a>2.1.1 变力沿直线做功</h4><p>此类题型题干一般都是“力F随着x改变而改变”，使用微元法解决</p>
<p><img src="/images/image-20230515231422192.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-1-2-抽水做功"><a href="#2-1-2-抽水做功" class="headerlink" title="2.1.2 抽水做功"></a>2.1.2 抽水做功</h4><p>这类题型与上一题的区别在于力不变，位移在改变，需要做合理的坐标系能够帮助解题（同样使用微元法）</p>
<p><img src="/images/image-20230515231630335.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-1-3-静水压力"><a href="#2-1-3-静水压力" class="headerlink" title="2.1.3 静水压力"></a>2.1.3 静水压力</h4><p>水压力问题的特点：压强随着水的深度改变而改变，使用微元法解题，同样的，合理的坐标系能够帮助解题</p>
<p><img src="/images/image-20230515232042905.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-2-几何应用"><a href="#2-2-几何应用" class="headerlink" title="2.2 几何应用"></a>2.2 几何应用</h3><p>一元积分的几何应用同样考察的是套公式+计算能力</p>
<h4 id="2-2-1-形心坐标"><a href="#2-2-1-形心坐标" class="headerlink" title="2.2.1 形心坐标"></a>2.2.1 形心坐标</h4><p>求解平面上的曲边梯形的形心坐标公式如下（这里是二维形心，后面还会介绍三维形心）</p>
<p><img src="/images/image-20230515232314844.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-2-平面曲线的弧长"><a href="#2-2-2-平面曲线的弧长" class="headerlink" title="2.2.2 平面曲线的弧长"></a>2.2.2 平面曲线的弧长</h4><p>平面曲线的弧长使用微元表示为 ds&#x3D;根号下(dx^2^+dy^2^)，将其应用在不同的坐标系下可以得到如下曲线弧长计算公式</p>
<p><img src="/images/image-20230515232544753.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-3-旋转曲面的面积"><a href="#2-2-3-旋转曲面的面积" class="headerlink" title="2.2.3 旋转曲面的面积"></a>2.2.3 旋转曲面的面积</h4><p>前面求解旋转曲面的体积使用的微元是dx，但是此处求解面积的微元必须是ds</p>
<p><img src="/images/image-20230515232837018.png" srcset="/img/loading.gif" lazyload></p>
<p>需要记忆的旋转曲面面积公式如下（一个是直角坐标方程一个是参数方程）</p>
<p><img src="/images/image-20230515232919039.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-4-立体体积"><a href="#2-2-4-立体体积" class="headerlink" title="2.2.4 立体体积"></a>2.2.4 立体体积</h4><p>这种题型非常简单，就是刚开始学习一元函数积分的时候“切土豆”的例子，使用微元法求解</p>
<p><img src="/images/image-20230515233111227.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-微分方程的应用"><a href="#3-微分方程的应用" class="headerlink" title="3.微分方程的应用"></a>3.微分方程的应用</h2><h3 id="3-1-物理应用"><a href="#3-1-物理应用" class="headerlink" title="3.1 物理应用"></a>3.1 物理应用</h3><p>微分方程的物理应用主要涉及牛顿第二定理和变化率问题（实际上牛二定律也属于这类问题），解题方式都是建立微分方程后求解</p>
<h4 id="3-1-牛顿第二定律"><a href="#3-1-牛顿第二定律" class="headerlink" title="3.1 牛顿第二定律"></a>3.1 牛顿第二定律</h4><blockquote>
<p>F&#x3D;ma</p>
</blockquote>
<p><img src="/images/image-20230515233427468.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-2-变化率问题"><a href="#3-2-变化率问题" class="headerlink" title="3.2 变化率问题"></a>3.2 变化率问题</h4><p>这种题型的题干一般为“t时刻某量y对t的变化率与t时刻某量成正比”，主要有两种模型，一种是正比模型一种是反比模型</p>
<p><img src="/images/image-20230515233829571.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-欧拉方程"><a href="#4-欧拉方程" class="headerlink" title="4.欧拉方程"></a>4.欧拉方程</h2><p>欧拉方程属于微分方程部分的内容，称如下形式的微分方程为欧拉方程（其中p与q是常数，f(x)是已知的连续函数）</p>
<p><img src="/images/image-20230515233955219.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到欧拉方程是一个二阶变系数微分方程，处理方式是通过换元将其变成二阶常系数方程，这里需要使用前面介绍过的相关变化率 dy&#x2F;dx&#x3D;(dy&#x2F;dt)*(dt&#x2F;dx)，不同的情况t值的取法不同</p>
<p><img src="/images/image-20230515234227034.png" srcset="/img/loading.gif" lazyload></p>
<p>上述换元的核心在下面这个导数的计算</p>
<p><img src="/images/image-20230807085135914.png" srcset="/img/loading.gif" lazyload></p>
<p>关于欧拉不要背结论，学会如何推导公式才是最重要的</p>
<h2 id="5-傅里叶级数"><a href="#5-傅里叶级数" class="headerlink" title="5.傅里叶级数"></a>5.傅里叶级数</h2><p>前面介绍泰勒级数的时候我们知道，如果f(x)满足任意阶可导的条件，则f(x)可以直接展开成泰勒级数。这里如果f(x)满足更苛刻的条件，则可以展开成傅里叶级数（也称为三角级数） – 根据考研试题的特点，如果题目确定要考察傅里叶级数相关的问题则一定会满足这个展开条件不用去证明；</p>
<blockquote>
<p>定义：</p>
<p><img src="/images/image-20230730165337326.png" srcset="/img/loading.gif" lazyload alt="傅里叶级数"></p>
<p>其中a<del>n</del>和b<del>n</del>分别如下</p>
<p><img src="/images/image-20230515234900387.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>考研数学中对傅里叶级数的要求主要就两方面：和函数展开为傅里叶级数、利用迪利克雷收敛求解傅里叶级数在某点的值S(x<del>0</del>)</p>
<h3 id="5-1-和函数展开"><a href="#5-1-和函数展开" class="headerlink" title="5.1 和函数展开"></a>5.1 和函数展开</h3><p>将已知和函数f(x)展开为傅里叶级数S(x)，主要分为三种情况</p>
<ul>
<li><p>当f(x)为普通函数（不具备奇偶性）则类似和函数展开那一节的直接展开法，将a<del>n</del>和b<del>n</del>算出来代入就可以得到其展开形式 – 这需要记住上述展开式（硬背）</p>
</li>
<li><p>当f(x)在区间上存在奇偶性的时候，傅里叶级数的展开可以进一步化简得到正弦级数和余弦级数</p>
</li>
</ul>
<p><img src="/images/image-20230515234955551.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>第三种情况是延拓。函数的奇偶性在对称区间上才有意义，如果要求将一个区间在[0,l]的函数f(x)展开成正弦级数或余弦级数，这就需要做一个称为延拓的操作（可视为定义域的补充），延拓主要分为奇延拓和偶延拓</li>
</ul>
<p><img src="/images/image-20230515235439569.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-2-迪利克雷收敛"><a href="#5-2-迪利克雷收敛" class="headerlink" title="5.2 迪利克雷收敛"></a>5.2 迪利克雷收敛</h3><p>迪利克雷收敛一般用于借助f(x)求解S(x)在某一点的值，即题干一般会要求求解S(x<del>0</del>)的值或当x&#x3D;x<del>0</del>时与S(x)相关的数项级数的值</p>
<blockquote>
<p>定义</p>
<p><img src="/images/image-20230730165303399.png" srcset="/img/loading.gif" lazyload alt="迪利克雷收敛定理"></p>
</blockquote>
<p>迪利克雷收敛简单来说就是，f(x)可以展开成傅里叶级数S(x)，但是f(x)并不是在每个点都等于S(x)（只有当f(x)在x为连续点的时候才一定等于S(x)）</p>
<hr>
<blockquote>
<p>Q：和函数f(x)展开为泰勒级数和傅里叶级数有什么区别？</p>
</blockquote>
<p>A：这里用一张图就可以解释两者之间的区别</p>
<p><img src="/images/image-20230730162919733.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h1 id="十四、多元函数积分学-预备"><a href="#十四、多元函数积分学-预备" class="headerlink" title="十四、多元函数积分学_预备"></a>十四、多元函数积分学_预备</h1><p>本章的内容主要都是一些零碎的知识点，主要服务于下一讲 – 多元函数积分学（除二重积分以外的其余多元函数的积分，可以说是整个高数最有挑战性的一部分知识点）</p>
<h2 id="1-向量代数"><a href="#1-向量代数" class="headerlink" title="1.向量代数"></a>1.向量代数</h2><h3 id="1-1-向量"><a href="#1-1-向量" class="headerlink" title="1.1 向量"></a>1.1 向量</h3><h4 id="1-1-1-基本概念"><a href="#1-1-1-基本概念" class="headerlink" title="1.1.1 基本概念"></a>1.1.1 基本概念</h4><blockquote>
<p>向量定义：既有大小又有方向的量称为向量</p>
</blockquote>
<ul>
<li>两个向量，只要其大小相等和方向相同，则这两个向量相同，与它们在空间中所处的位置无关 –这被称为向量的自由性；</li>
<li>单位向量是表示向量方向的向量，其模的大小固定为1；</li>
</ul>
<blockquote>
<p>向量的方向角和方向余弦</p>
</blockquote>
<p>注意此处的方向角和方向余弦需要与向量夹角区分：</p>
<p><img src="/images/image-20230525092039378.png" srcset="/img/loading.gif" lazyload alt="方向角"></p>
<ul>
<li>非零向量a与x轴、y轴和z轴正向的夹角α、β、γ称为a的方向角；</li>
<li>相应的，cosα、cosβ、cosγ称为a的方向余弦，且有计算公式<img src="/images/image-20230523194231647.png" srcset="/img/loading.gif" lazyload>。更加一般的，有如下结论</li>
</ul>
<p><img src="/images/image-20230523194522023.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-1-2-基本公式"><a href="#1-1-2-基本公式" class="headerlink" title="1.1.2 基本公式"></a>1.1.2 基本公式</h4><p><img src="/images/image-20230523193905666.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-1-3-基本性质"><a href="#1-1-3-基本性质" class="headerlink" title="1.1.3 基本性质"></a>1.1.3 基本性质</h4><p><img src="/images/image-20230807094815472.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-2-空间直角坐标系"><a href="#1-2-空间直角坐标系" class="headerlink" title="1.2 空间直角坐标系"></a>1.2 空间直角坐标系</h3><p>在空间取定一点O和三个两两垂直的单位向量i,j,k，就确定了三条都以O为原点的两两垂直的数轴，将这三条数轴统称为坐标轴</p>
<p><img src="/images/image-20230525090600110.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这三条坐标轴构成一个空间直角坐标系，称为Oxyz坐标系；</li>
<li>坐标轴的正向通常符合右手规则：即右手握住z轴，右手的四个手指从正向x轴以Π&#x2F;2角度转向正向y轴，大拇指的方向就是z轴的正向；</li>
</ul>
<hr>
<blockquote>
<p>Q：坐标轴和坐标系的区别？</p>
</blockquote>
<p>A：坐标轴是指一条带方向有刻度的直线，而坐标系则是指若干条坐标轴组成的若干维的空间；</p>
<blockquote>
<p>Q：向量r有几种表示方法？</p>
</blockquote>
<p>A：主要有两种表示方法，一种是坐标分解式xi+yj+zk，一种是坐标表示(x,y,z)。</p>
<p>额外的，向量r可以表示为(x,y,z)，点M也可以表示为(x,y,z)，此处的有序数x,y,z都称为向量r&#x2F;点M的坐标。</p>
<p>因为“一个点与该点的向径有相同的坐标”，因此记号(x,y,z)既可以表示点M，又可以表示向量OM。因为几何中点和向量是两个不同的概念，因此当看到坐标(x,y,z)时，需要根据上下文确认究竟表示点还是向量，不可混淆。</p>
<hr>
<h2 id="2-空间平面与直线"><a href="#2-空间平面与直线" class="headerlink" title="2.空间平面与直线*"></a>2.空间平面与直线*</h2><p>空间平面（常简称为平面）和空间直线分别是空间曲面（常简称为曲面）和空间曲线的特例，下面是一个简单的方程汇总</p>
<p><img src="/images/image-20230807095004389.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-1-空间平面方程"><a href="#2-1-空间平面方程" class="headerlink" title="2.1 空间平面方程"></a>2.1 空间平面方程</h3><blockquote>
<p>如果一非零向量垂直于一平面，该向量就被称为该平面的法线向量（简称法向量） – 平面上的任一向量均与该平面的法线向量垂直且法向量方向可前可后；</p>
</blockquote>
<p>假设已知平面的法向量n&#x3D;(A,B,C)</p>
<p><img src="/images/image-20230523195146894.png" srcset="/img/loading.gif" lazyload></p>
<p>平面的方程主要有一般式、点法式、三点式和截距式</p>
<p><img src="/images/image-20230523195307386.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>平面点法式可以看作是直线点斜式(y-y<del>0</del>&#x3D;k(x-x<del>0</del>))的推广；</li>
<li>平面的一般方程实际就是通过点法方程拆分得到，一般方程和点法方程同解 – 于是可以得到这样一个结论，<code>任何一个三元一次方程的图形总是一个平面</code>，其中(A,B,是该平面的一个法线向量的坐标；</li>
</ul>
<hr>
<blockquote>
<p>Q：垂线和法线的区别？</p>
</blockquote>
<p>A：垂线是两条互相垂直的直线其中的一条，法线是指任一垂直于某平面的直线；</p>
<hr>
<h3 id="2-2-空间直线方程"><a href="#2-2-空间直线方程" class="headerlink" title="2.2 空间直线方程"></a>2.2 空间直线方程</h3><blockquote>
<ul>
<li>如果一个非零向量平行于一条已知直线，那么这个向量就称为该直线的方向向量 – 方向向量可前可后；</li>
<li>直线任一方向的方向向量s的坐标m,n,p称为该直线的一组方向数，而向量s的方向余弦称为该直线的方向余弦；</li>
</ul>
</blockquote>
<p>假设已知空间直线的方向向量Γ&#x3D;(l,m,n)，空间直线的方程主要有一般式、点向式、参数式和两点式</p>
<p><img src="/images/image-20230523195537033.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-空间位置关系"><a href="#2-3-空间位置关系" class="headerlink" title="2.3 空间位置关系"></a>2.3 空间位置关系</h3><h4 id="2-3-1-点到平面的距离"><a href="#2-3-1-点到平面的距离" class="headerlink" title="2.3.1 点到平面的距离"></a>2.3.1 点到平面的距离</h4><p><img src="/images/image-20230523195626255.png" srcset="/img/loading.gif" lazyload></p>
<p>可类比平面上点到直线的距离</p>
<p><img src="/images/image-20230807095103639.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-3-2-空间直线间的关系"><a href="#2-3-2-空间直线间的关系" class="headerlink" title="2.3.2 空间直线间的关系"></a>2.3.2 空间直线间的关系</h4><blockquote>
<p>两直线的方向向量的夹角（通常是锐角或直角）称为两直线的夹角</p>
</blockquote>
<p><img src="/images/image-20230523195713274.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-3-3-空间平面间的关系"><a href="#2-3-3-空间平面间的关系" class="headerlink" title="2.3.3 空间平面间的关系"></a>2.3.3 空间平面间的关系</h4><blockquote>
<p>两平面的法线向量的夹角（通常是指锐角或直角）称为两平面的夹角</p>
</blockquote>
<p><img src="/images/image-20230523195757384.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-3-4-平面与直线的关系"><a href="#2-3-4-平面与直线的关系" class="headerlink" title="2.3.4 平面与直线的关系"></a>2.3.4 平面与直线的关系</h4><blockquote>
<p>当直线和平面不垂直时，直线和它在平面上的投影直线的夹角称为直线于平面的夹角；</p>
<p>当直线和平面垂直时，规定直线和平面的夹角为Π&#x2F;2；</p>
</blockquote>
<p><img src="/images/image-20230523195833646.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-空间曲线与曲面"><a href="#3-空间曲线与曲面" class="headerlink" title="3.空间曲线与曲面"></a>3.空间曲线与曲面</h2><p>类似空间直线与空间平面，下面是空间曲线与曲面的方程汇总</p>
<p><img src="/images/image-20230807095208395.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-1-空间曲线方程"><a href="#3-1-空间曲线方程" class="headerlink" title="3.1 空间曲线方程"></a>3.1 空间曲线方程</h3><p>空间直线可以理解为两个空间平面相交得到，空间曲线的几何背景为两个曲面的交线</p>
<blockquote>
<p>一般式（几何背景）</p>
</blockquote>
<p><img src="/images/image-20230523200036358.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>参数方程（可以理解为三维坐标(x,y,z)随着t的改变而改变，点动成线自然就形成了三维空间中的空间曲线）</p>
</blockquote>
<p><img src="/images/image-20230523200056374.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-1-1-曲线投影"><a href="#3-1-1-曲线投影" class="headerlink" title="3.1.1 曲线投影*"></a>3.1.1 曲线投影*</h4><p><img src="/images/image-20230523200210073.png" srcset="/img/loading.gif" lazyload></p>
<p>求曲线Γ在xOy坐标面上的投影曲线，则先将空间曲线方程<img src="/images/image-20230523200318954.png" srcset="/img/loading.gif" lazyload>中的参数z消去（方式就是将z用x和y表达出来，回代任意一个表达式)，得到φ(x,y)&#x3D;0，然后联立z&#x3D;0则得到曲线Γ在xOy坐标面上的投影曲线的方程为<img src="/images/image-20230523200619604.png" srcset="/img/loading.gif" lazyload></p>
<p>按照上述方法，不投谁则消去谁，联立平面方程，即可得到曲线Γ在其他平面上的投影曲线方程。</p>
<h3 id="3-2-空间曲面方程"><a href="#3-2-空间曲面方程" class="headerlink" title="3.2 空间曲面方程"></a>3.2 空间曲面方程</h3><blockquote>
<p>空间曲面的方程只有唯一一个：F(x,y,z)&#x3D;0</p>
</blockquote>
<h4 id="3-2-1-二次曲面"><a href="#3-2-1-二次曲面" class="headerlink" title="3.2.1 二次曲面"></a>3.2.1 二次曲面</h4><p>在空间解析几何中，将三元二次方程F(x,y,z)&#x3D;0表示的曲面称为二次空间曲面（平面几何中有一个类似的概念为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF">二次平面曲线</a>，其特点是二元二次方程）</p>
<p>下面给出常见的<code>二次曲面</code>，尽量记住（旋转曲面和柱面也属于二次曲面，但是比较特殊放在后面单独讲解）</p>
<p><img src="/images/image-20230807095930754.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>上述二次曲面所给的方程都是标准方程，考研基本也只会考察这些二次曲面的标准方程；</li>
<li>关于上述二次曲面的记忆方式，最简单直接的就是使用截痕法，还可以使用伸缩法、投影法等，方法不唯一，只要能记忆就行；</li>
</ul>
<h4 id="3-2-2-柱面方程"><a href="#3-2-2-柱面方程" class="headerlink" title="3.2.2 柱面方程"></a>3.2.2 柱面方程</h4><blockquote>
<p>柱面是指动直线沿着定曲线平行移动所形成的曲面（简单来说就是缺少x,y,z其中任意一个字母的空间曲面方程就是柱面方程） – 柱面不一定是闭合的</p>
</blockquote>
<p><img src="/images/image-20230523201358846.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>F(x,y)&#x3D;0表示母线(动直线)平行于z轴、准线(定曲线)是xOy平面上的曲线C:F(x,y)&#x3D;0形成的柱面</li>
</ul>
<h4 id="3-2-3-旋转曲面"><a href="#3-2-3-旋转曲面" class="headerlink" title="3.2.3 旋转曲面*"></a>3.2.3 旋转曲面*</h4><blockquote>
<p>旋转曲面是指曲线Γ绕一定直线旋转一周所形成的曲面</p>
</blockquote>
<p>旋转曲面主要分为绕坐标轴旋转和绕某定直线旋转，下面先介绍通用的求解旋转曲面方程的解法</p>
<p><img src="/images/image-20230731162549490.png" srcset="/img/loading.gif" lazyload></p>
<p>求解旋转曲面方程的核心就是联立上述三个条件，消去未知的x<del>1</del>,y<del>1</del>和z<del>1</del>即可得到H(x,y,z)&#x3D;0曲面方程。</p>
<p>特殊的，当母线在某<code>坐标面</code>上，且绕着<code>坐标轴</code>旋转时（必须同时满足这两个条件），形成的旋转曲面方程可以使用如下口诀快速得到：“绕着谁转谁不变，另一个字母写作另外两个字母的平方和开根号”。因此绕着坐标轴旋转一共有如下六种情况（别背，这里只是做一个展示，真正考的时候用口诀推就行）</p>
<p><img src="/images/image-20230525094851602.png" srcset="/img/loading.gif" lazyload></p>
<p>下面这个例子是标准化的旋转曲面的求解，有助于帮助理解</p>
<p><img src="/images/image-20230807101743874.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-多元函数微分学的几何应用"><a href="#4-多元函数微分学的几何应用" class="headerlink" title="4.多元函数微分学的几何应用*"></a>4.多元函数微分学的几何应用*</h2><p>尤其需要注意的是，对空间曲线讨论的是切线，对空间曲面讨论的是法线。下面的结论需要记忆的实际就是方向向量的形式，其余的结论都可以利用空间直线的点向方程和空间平面的点法方程推导得到。</p>
<h3 id="4-1-空间曲线的切线和法平面"><a href="#4-1-空间曲线的切线和法平面" class="headerlink" title="4.1 空间曲线的切线和法平面"></a>4.1 空间曲线的切线和法平面</h3><p><img src="/images/image-20230807101010596.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>关于上述第二种形式，如果实在记不住结论也没关系，因为题干已经给出两个隐函数方程，因此使用隐函数求导解出dy&#x2F;dx以及dz&#x2F;dx同样可行；</li>
</ul>
<h3 id="4-2-空间曲面的切平面与法线"><a href="#4-2-空间曲面的切平面与法线" class="headerlink" title="4.2 空间曲面的切平面与法线"></a>4.2 空间曲面的切平面与法线</h3><p>主要分为两种情况，即空间曲面的方程分别是隐式和显式</p>
<p><img src="/images/image-20230523205648547.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5-场论"><a href="#5-场论" class="headerlink" title="5.场论"></a>5.场论</h2><h3 id="5-1-方向导数"><a href="#5-1-方向导数" class="headerlink" title="5.1 方向导数"></a>5.1 方向导数</h3><p>推荐先看前面的笔记[二元函数的方向导数和梯度](# 1.6 方向导数)，其中介绍了二元函数f(x,y)的方向导数和梯度，三元函数f(x,y,z)的导数与梯度与之类似，理解了二元类后学习三元会简单的多。</p>
<p><img src="/images/image-20230801111843027.png" srcset="/img/loading.gif" lazyload alt="三元函数的方向导数的定义式"></p>
<p>一般计算方向导数使用的都是计算式而非定义式，三元函数的方向导数计算式如下</p>
<p><img src="/images/image-20230801112021693.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-2-梯度-amp-散度-amp-旋度"><a href="#5-2-梯度-amp-散度-amp-旋度" class="headerlink" title="5.2 梯度&amp;散度&amp;旋度"></a>5.2 梯度&amp;散度&amp;旋度</h3><p>与二元函数的梯度类似，三元函数的梯度定义如下</p>
<p><img src="/images/image-20230801112223303.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>方向导数和梯度的关系：无论函数是几元函数，其在某点的梯度是一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值</p>
</blockquote>
<p>梯度的定义是在数量场中，散度和旋度的定义都是在向量场（如引力场）中</p>
<p><img src="/images/image-20230523210246412.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="十五、多元函数积分学"><a href="#十五、多元函数积分学" class="headerlink" title="十五、多元函数积分学"></a>十五、多元函数积分学</h1><h2 id="1-三重积分"><a href="#1-三重积分" class="headerlink" title="1.三重积分"></a>1.三重积分</h2><h3 id="1-1-基本概念-1"><a href="#1-1-基本概念-1" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p>二重积分求体积是基于该物体的的密度是均匀的，但是三重积分考虑的是三维空间中非均匀密度的某物体的质量</p>
<h4 id="1-1-1-三重积分的定义"><a href="#1-1-1-三重积分的定义" class="headerlink" title="1.1.1 三重积分的定义"></a>1.1.1 三重积分的定义</h4><p>在[二重积分的定义](# 1.1 二重积分的定义)中已经介绍过三重积分的概念，这里再次将二重积分和三重积分做一个对比进行记忆</p>
<ul>
<li>三重积分从几何上来说非常抽象，表示的是四维空间图像的体积，无法画出图形；</li>
<li>三重积分的物理背景可以理解，就是以f(x,y,z)为点密度的空间物体的质量；</li>
<li>一般的，总是假设三重积分存在，即f(x,y,z)在Ω上可积；</li>
</ul>
<p><img src="/images/image-20230524092045727.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-1-2-三重积分的性质"><a href="#1-1-2-三重积分的性质" class="headerlink" title="1.1.2 三重积分的性质"></a>1.1.2 三重积分的性质</h4><p>三重积分的性质基本上和二重积分相同，这里仅列出，按照二重积分的理解方式进行理解即可</p>
<p><img src="/images/image-20230524094858261.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-1-3-对称性"><a href="#1-1-3-对称性" class="headerlink" title="1.1.3 对称性"></a>1.1.3 对称性</h4><p>三重积分的对称性的分析方法同样与二重积分的对称性方法相同，主要分为普通对称性和轮转对称性</p>
<p><img src="/images/image-20230524095249648.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-2-三重积分的计算"><a href="#1-2-三重积分的计算" class="headerlink" title="1.2 三重积分的计算"></a>1.2 三重积分的计算</h3><p>无论在什么坐标系下计算三重积分，都是从适用场合和计算方法两部分考虑。而无论是在什么坐标系下计算三重积分，其本质都是将其化为三次积分进行计算（与二重积分化为二次积分计算相同）</p>
<h4 id="1-2-1-基础方法"><a href="#1-2-1-基础方法" class="headerlink" title="1.2.1 基础方法"></a>1.2.1 基础方法</h4><h5 id="1-直角坐标系"><a href="#1-直角坐标系" class="headerlink" title="(1)直角坐标系"></a>(1)直角坐标系</h5><p>直角坐标系下的三重积分计算方法主要分为先一后二（先z后xy法、投影穿线法）和先二后一（先xy后z法、定限截面法）</p>
<p>(a)先一后二</p>
<p>适用场合：积分区域Ω（空间实心图形）分别有下曲面z&#x3D;z<del>1</del>(x,y)和上曲面z&#x3D;z<del>2</del>(x,y)，无侧面或侧面为柱面（也可以部分有柱面侧面、部分无侧面，当然平面也是特殊的曲面）</p>
<p><img src="/images/image-20230524100828272.png" srcset="/img/loading.gif" lazyload></p>
<p>计算方法：“后积先定限，限内画条线，先交为下限，后交为上限”</p>
<p><img src="/images/image-20230524101121707.png" srcset="/img/loading.gif" lazyload></p>
<p>(b)先二后一</p>
<p>适用场合（简单理解就是当被积函数只依赖一个变量且截面面积比较容易求解时使用先二后一）：</p>
<ol>
<li>积分区域Ω是一个旋转体，其旋转曲面方程（参考十四讲[旋转曲面](# 3.2.3 旋转曲面*)）为Σ:z&#x3D;z(x,y)（该旋转曲面方程题干可能给出也可能需要自行求解）；</li>
<li>被积函数f(x,y,z)仅仅只是关于z的函数g(z)（不绝对）</li>
</ol>
<p><img src="/images/image-20230524102102365.png" srcset="/img/loading.gif" lazyload></p>
<p>计算方法：“后积先定限，限内截个面”（因为是旋转体因此截面一定是圆形，即截面面积易于求解，当然这个截面一定是关于z的方程）</p>
<p><img src="/images/image-20230524102619209.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-柱面坐标系"><a href="#2-柱面坐标系" class="headerlink" title="(2)柱面坐标系"></a>(2)柱面坐标系</h5><p>直角坐标系的计算方法可以简单认为是“<code>定积分dz*二重积分dxdy</code>”，类似的，柱面坐标系下的计算方法也可以总结为“<code>定积分dz*极坐标系下的二重积分rdrdθ</code>”</p>
<p>适用场合(简单来说就是当直角坐标系下的二重积分适用极坐标系时，对应的三重积分适用柱面坐标系求解)：</p>
<ol>
<li>积分区域Ω在xOy平面上的投影是圆或圆的一部分；</li>
<li>被积函数形如f(x^2^+y^2^),f(x^2^-y^2^),f(xy),f(x&#x2F;y)之一与g(z)的复合</li>
</ol>
<p>计算方法：</p>
<p><img src="/images/image-20230524103602647.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>柱面坐标的三次积分顺序是固定的，即dθdrdz</li>
</ul>
<hr>
<blockquote>
<p>Q：柱面坐标是针对先一后二还是先二后一的极坐标化呢？</p>
</blockquote>
<p>A：先二后一作为一种简化手段无需额外极坐标化，所以一般情况下柱面坐标是针对先二后一的极坐标化；</p>
<hr>
<h5 id="3-球面坐标系"><a href="#3-球面坐标系" class="headerlink" title="(3)球面坐标系"></a>(3)球面坐标系</h5><p>适用场合：</p>
<ol>
<li>积分区域Ω为球体或球体的部分、锥体或锥体的部分；</li>
<li>被积函数中包含两个或三个字母的平方和，形如f(x^2^+y^2^+z^2^)或f(x^2^+y^2^)</li>
</ol>
<p>计算方法：计算球面坐标系下的三重积分需要记住两个重要前提条件</p>
<p><img src="/images/image-20230524104701560.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230524104719305.png" srcset="/img/loading.gif" lazyload></p>
<p>因此球面坐标系下的三重积分的计算公式可以写为（实在无法理解就硬背，后面有简单的推导感兴趣可以看看）</p>
<p><img src="/images/image-20230524105848461.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>球面坐标下的三次积分的积分次序不变，即dθdφdr</p>
</li>
<li><p>球面坐标的定限方法如下</p>
</li>
</ul>
<p><img src="/images/image-20230524105942800.png" srcset="/img/loading.gif" lazyload alt="定限原则"></p>
<p>上述定限原则可能比较生涩难以理解，下面给出更形象的记忆方法：</p>
<ol>
<li>拉开一扇门(定θ)：首先将积分区域投影到xOy平面，然后用x轴正向射线逆时针旋转，先接触的为下限，后接触的为上限（取值范围[0,2Π]）；</li>
<li>喇叭花开花(定φ)：使用z轴正向射线“左右同时”从上到下扫描，先接触为下限，后接触为上限（取值范围[0,Π]） – 更严谨的说法是极径绕z轴旋转，与积分区域接触和分离的φ面作为上下限；</li>
<li>射线穿出来(定r)：原点出发的射线先接触的面为下限后接触的面为上限（取值范围[0,+∞]）；</li>
</ol>
<p><img src="/images/image-20230802165628605.png" srcset="/img/loading.gif" lazyload alt="定限图示"></p>
<hr>
<blockquote>
<p>Q：球面坐标的三重积分计算式是如何推导出来的？</p>
</blockquote>
<p>A：首先需要了解球面坐标是什么，空间中的一个点既可以用直角坐标也可以用极坐标甚至可以用球面坐标表示，球面坐标定义为(θ,φ,r)</p>
<p><img src="/images/image-20230802165220902.png" srcset="/img/loading.gif" lazyload></p>
<p>其中r是原点到该点之间的距离，φ是射线与z轴正向形成的夹角，θ是该射线投影与x轴正向形成的夹角。</p>
<p>了解完球面坐标系后就可以介绍球面坐标系下三重积分计算式的推导。首先使用三个平面（简称三族面）将空间Ω切分为微元体，其中：</p>
<p><img src="/images/image-20230524105250429.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20230524110437620.png" srcset="/img/loading.gif" lazyload></p>
<p>上述微元体接近长方体，三组边界面分别为：以原点为圆心，半径为r与r+dr的球面；以z轴为中心轴，半顶角为φ与φ+dφ的圆锥面；过z轴且与xOz轴面正向夹角为θ与θ+dθ的半平面。因此体积微元的三个边长dr,rdφ与rsinφdθ的乘积，因此最终球面坐标系下的三重积分的计算公式可以写为</p>
<p><img src="/images/image-20230524105848461.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="1-2-2-技术方法"><a href="#1-2-2-技术方法" class="headerlink" title="1.2.2 技术方法"></a>1.2.2 技术方法</h4><p><img src="/images/image-20230524110519552.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>使用形心公式需要先了解[形心公式](# 4.2 重心与形心)，当被积区域Ω是一个规则图形，此时的V<del>Ω</del>容易计算求解，且其形心固定，可以逆用形心公式轻松求解需要求解的积分；</p>
</blockquote>
<h2 id="2-第一型曲线积分"><a href="#2-第一型曲线积分" class="headerlink" title="2.第一型曲线积分"></a>2.第一型曲线积分</h2><h3 id="2-1-基本概念-1"><a href="#2-1-基本概念-1" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h4><p>第一型曲线积分又称为对弧长的曲线积分</p>
<p><img src="/images/image-20230803144643304.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>被积函数f(x,y)定义在平面曲线上，被积函数f(x,y,z)定义在空间曲线上，之所以写作这种形式是为了表示变量之间不具备独立性，这是线面积分的特点</p>
</blockquote>
<p>第一型曲线积分可看作由一重定积分推广得到</p>
<p><img src="/images/image-20230524200347683.png" srcset="/img/loading.gif" lazyload alt="第一型曲线积分的几何意义"></p>
<p>其几何意义是空间曲面的面积，物理意义是质量不均匀的空间曲线的质量，f(x,y)是线密度，ds为弧长微元（需要注意的是<code>物理意义比几何意义低一个维度</code>，因此对物理意义来说，f(x,y)是xOy<code>平面曲线</code>的线密度，f(x,y,z)是xyz三维<code>空间中的曲线</code>的线密度；而无论是在几维的空间，积分区域只要是曲线则是一重积分）；</p>
<ul>
<li>考研数学中，总是假设第一型曲线积分是存在的（不存在也不会让你去计算）；</li>
</ul>
<h4 id="2-1-2-性质"><a href="#2-1-2-性质" class="headerlink" title="2.1.2 性质"></a>2.1.2 性质</h4><p>第一型曲线积分的性质与定积分几乎完全一致，这里仅给出，不再解释</p>
<p><img src="/images/image-20230524201740785.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-1-3-对称性"><a href="#2-1-3-对称性" class="headerlink" title="2.1.3 对称性"></a>2.1.3 对称性</h4><p>无论是普通对称性还是轮转对称性，分析方法与二、三重积分完全一致</p>
<p><img src="/images/image-20230524201904588.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-2-计算方法"><a href="#2-2-计算方法" class="headerlink" title="2.2 计算方法"></a>2.2 计算方法</h3><h4 id="2-2-1-基础方法"><a href="#2-2-1-基础方法" class="headerlink" title="2.2.1 基础方法"></a>2.2.1 基础方法</h4><blockquote>
<p>以下所有的曲线积分或者曲面积分的基本计算方法都可应用口诀“一投、二代、三计算”</p>
<ul>
<li>一投：将曲线投影到下来，确定积分的上下限（一定注意这个上下限并不是真正通过投影下来的线段确定的，这是由曲线本身的方程决定的，这里这样说只是方便理解）</li>
<li>二代：因为变量之间不具备独立性（这是线面积分的特点），因此需要将f(x,y)或f(x,y,z)中的字母代换为表达式</li>
<li>三计算：ds即前面介绍的弧微分计算</li>
</ul>
</blockquote>
<p>因为第一型曲线积分是由定积分推广得来，因此计算第一型曲线积分的基本方法就是将其转化为定积分。前面定义中介绍了两种物理意义的第一型曲线积分，即分别是空间曲线f(x,y,z)和平面曲线f(x,y)</p>
<p>对于空间曲线的情形</p>
<p><img src="/images/image-20230524202308203.png" srcset="/img/loading.gif" lazyload></p>
<p>对于平面的情形</p>
<p><img src="/images/image-20230524202415325.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意：</p>
<ul>
<li>定积分的下限α一定要小于上限β – 此处直接记忆“第一型线积分的下限为小上限为大”，与之后“第二型曲线积分的下限为起点，上限为终点”做区分；</li>
<li>之所以要求此处的下限一定小于上限是因为质量恒大于等于0；</li>
</ul>
</blockquote>
<h4 id="2-2-2-技术方法"><a href="#2-2-2-技术方法" class="headerlink" title="2.2.2 技术方法"></a>2.2.2 技术方法</h4><p><img src="/images/image-20230524202521589.png" srcset="/img/loading.gif" lazyload></p>
<p>关于上面第一点可不用管，因为在计算的过程中必须使用将边界方程代入被积函数才能正确求解</p>
<h2 id="3-第一型曲面积分"><a href="#3-第一型曲面积分" class="headerlink" title="3.第一型曲面积分"></a>3.第一型曲面积分</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><h4 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h4><p>第一型曲面积分又称为对面积的曲面积分</p>
<p><img src="/images/image-20230803144737742.png" srcset="/img/loading.gif" lazyload></p>
<p>是由二重积分推广得到</p>
<p><img src="/images/image-20230524200520596.png" srcset="/img/loading.gif" lazyload></p>
<p>其几何意义并没有说明，物理意义是空间非均匀曲面的质量，其中f(x,y,z)是面密度，dS是面积微元；</p>
<ul>
<li>考研数学中，总是假设第一型曲面积分是存在的；</li>
</ul>
<h4 id="3-1-2-性质"><a href="#3-1-2-性质" class="headerlink" title="3.1.2 性质"></a>3.1.2 性质</h4><p><img src="/images/image-20230524202946033.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-1-3-对称性"><a href="#3-1-3-对称性" class="headerlink" title="3.1.3 对称性"></a>3.1.3 对称性</h4><p><img src="/images/image-20230524203019842.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-计算方法"><a href="#3-2-计算方法" class="headerlink" title="3.2 计算方法"></a>3.2 计算方法</h3><h4 id="3-2-1-基本方法"><a href="#3-2-1-基本方法" class="headerlink" title="3.2.1 基本方法"></a>3.2.1 基本方法</h4><p>第一型曲面积分的计算方法是将其转换为二重积分计算，无论空间曲面Σ由显式z&#x3D;z(x,y)还是隐式F(x,y,z)&#x3D;0给出的，都需要遵照口诀进行如下三个步骤（没有逻辑上的先后，哪个步骤方便先求解哪个）</p>
<p><img src="/images/image-20230524203517573.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意，选择将曲面投影到哪个点是自行决定的，原则是投影之后的任何两个投影点不能重合</p>
<p><img src="/images/image-20230524203618745.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="3-2-2-技术方法"><a href="#3-2-2-技术方法" class="headerlink" title="3.2.2 技术方法"></a>3.2.2 技术方法</h4><p><img src="/images/image-20230524203640834.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-重积分与第一型线面积分的应用"><a href="#4-重积分与第一型线面积分的应用" class="headerlink" title="4.重积分与第一型线面积分的应用"></a>4.重积分与第一型线面积分的应用</h2><p>本小节是对之前的定积分、二重积分、三重积分以及第一型线面积分的应用的总结，常出现在应用题中，综合性较强。</p>
<h3 id="4-1-几何量"><a href="#4-1-几何量" class="headerlink" title="4.1 几何量"></a>4.1 几何量</h3><h4 id="4-1-1-面积-amp-体积"><a href="#4-1-1-面积-amp-体积" class="headerlink" title="4.1.1 面积&amp;体积"></a>4.1.1 面积&amp;体积</h4><p>平面区域（即xOy平面）的面积主要分为如下两种情况：</p>
<p><img src="/images/image-20230524212139625.png" srcset="/img/loading.gif" lazyload></p>
<p>对于空间区域（即xyz坐标轴）的体积主要分为如下两种情况：</p>
<p><img src="/images/image-20230524212331165.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-1-2-曲线弧长-amp-曲面面积"><a href="#4-1-2-曲线弧长-amp-曲面面积" class="headerlink" title="4.1.2 曲线弧长&amp;曲面面积*"></a>4.1.2 曲线弧长&amp;曲面面积*</h4><p>计算空间曲线的弧长公式如下</p>
<p><img src="/images/image-20230524212720880.png" srcset="/img/loading.gif" lazyload></p>
<p>计算空间曲面的面积公式如下（考研题如果考察几何测度几乎就考察曲面面积）</p>
<p><img src="/images/image-20230524212810702.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>在保证曲面方程由单值函数(即对定义域中的每个自变量其对应的函数值是唯一的)给出的情况下，可以向另外两个坐标面投影，进而分别得到曲面在yOz面投影区域的面积和zOx面投影区域面积；</li>
</ul>
<h3 id="4-2-重心与形心"><a href="#4-2-重心与形心" class="headerlink" title="4.2 重心与形心"></a>4.2 重心与形心</h3><p>在考研的范畴内，均认为物体的重心等于质心，而当密度ρ为常数时，重心又等于形心（三心合一），以下的公式直接记住其中一个即可任意推广。</p>
<h4 id="4-2-1-平面薄片"><a href="#4-2-1-平面薄片" class="headerlink" title="4.2.1 平面薄片"></a>4.2.1 平面薄片</h4><p><img src="/images/image-20230524213451655.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-2-2-空间物体"><a href="#4-2-2-空间物体" class="headerlink" title="4.2.2 空间物体*"></a>4.2.2 空间物体*</h4><p>（考重心、质心和形心就考空间物体）</p>
<p><img src="/images/image-20230524213543169.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-2-3-物质曲杆"><a href="#4-2-3-物质曲杆" class="headerlink" title="4.2.3 物质曲杆"></a>4.2.3 物质曲杆</h4><p><img src="/images/image-20230524213610399.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-2-4-物质曲面"><a href="#4-2-4-物质曲面" class="headerlink" title="4.2.4 物质曲面"></a>4.2.4 物质曲面</h4><p><img src="/images/image-20230524213640892.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-3-转动惯量"><a href="#4-3-转动惯量" class="headerlink" title="4.3 转动惯量"></a>4.3 转动惯量</h3><p>（至今为止转动惯量和引力还没有考察过，但是具有未来性，考前背公式即可）</p>
<blockquote>
<p>抓住点到旋转轴&#x2F;原点的距离r的平方（空间物体的转动惯量&#x3D;（距离r的平方*质量微元dm）在积分区域上的三重积分）</p>
</blockquote>
<p><img src="/images/image-20230524214011852.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-4-引力"><a href="#4-4-引力" class="headerlink" title="4.4 引力"></a>4.4 引力</h3><blockquote>
<p>抓住距离r的三次方（张宇的意思是这样背，而不是说万有引力公式与r^3^相关）</p>
</blockquote>
<p><img src="/images/image-20230524214136099.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<p>这里简单对三维空间中的物体引力公式做一个推导</p>
<p><img src="/images/image-20230803170517105.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="5-第二型曲线积分"><a href="#5-第二型曲线积分" class="headerlink" title="5.第二型曲线积分"></a>5.第二型曲线积分</h2><p>在介绍第二型曲线积分之前，先简单介绍一下场的概念，简单来说，场就是空间区域Ω上的一种对应法则：</p>
<ul>
<li>如果Ω上的每一点都对应一个数量u，则称为数量场（无方向，比如温度场，数量场也称为数量函数）；</li>
<li>如果Ω上的每一点都对应一个向量F，则称为向量场（有方向，比如引力场，向量场也称为向量函数）；</li>
</ul>
<p>除此之外，“第二型”的线面积分没有几何意义，只有物理意义！</p>
<h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><h4 id="5-1-1-定义"><a href="#5-1-1-定义" class="headerlink" title="5.1.1 定义"></a>5.1.1 定义</h4><p>第二型曲线积分也称为对坐标的积分，其定义如下</p>
<p><img src="/images/image-20230524233250465.png" srcset="/img/loading.gif" lazyload></p>
<p>对应的图示如下</p>
<p><img src="/images/image-20230524233319179.png" srcset="/img/loading.gif" lazyload></p>
<p>第二型曲线积分的物理意义为<code>非恒力</code>F沿<code>有向曲线</code>做的功|F|·|d|·cosθ</p>
<h4 id="5-1-2-性质"><a href="#5-1-2-性质" class="headerlink" title="5.1.2 性质"></a>5.1.2 性质</h4><p>第二型曲线积分不同于之前所学的定积分、二重积分、三重积分等，它是一个向量函数沿有向曲线的积分，因此其性质与前面所介绍的都有所不同，下面展示的是二型曲线的对称性</p>
<p><img src="/images/image-20230524233727166.png" srcset="/img/loading.gif" lazyload></p>
<p>第二型曲线积分的性质如下</p>
<p><img src="/images/image-20230524233820343.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-2-计算方法"><a href="#5-2-计算方法" class="headerlink" title="5.2 计算方法"></a>5.2 计算方法</h3><h4 id="5-2-1-基本方法"><a href="#5-2-1-基本方法" class="headerlink" title="5.2.1 基本方法"></a>5.2.1 基本方法</h4><p>基本方法就是化为定积分，仍然使用口诀“一投二代三计算”，需要注意的是此处的上下限是起点和终点，并没有严格的大小关系。</p>
<p><img src="/images/image-20230524234256024.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-2-2-格林公式"><a href="#5-2-2-格林公式" class="headerlink" title="5.2.2 格林公式*"></a>5.2.2 格林公式*</h4><p>格林公式的意义就在于将关于做功的二型曲线积分（边界积分）转换为区域内部的二重积分（该二重积分的被积函数是场论中的旋度）</p>
<p><img src="/images/image-20230524234427311.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>格林公式得使用条件，简单记忆就是，L为封闭曲线，L取得正向且P、Q具有一阶连续偏导(否则写不出旋度)；</li>
<li>所谓的“正向”是指沿着L的正向前进时，左手始终在L围成的区域D内；</li>
<li>旋度计算公式，简单记忆为“铅垂力对x求偏导，水平力对y求偏导”</li>
</ul>
</blockquote>
<p>考试的要点在于格林公式的三个条件被破坏</p>
<p><img src="/images/image-20230524234543255.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>挖去法和补线法都是有代价的，需要在计算结果上减去多余的功才是最终的计算结果</li>
<li>挖去法的理论原理如下，因为挖去的曲线C可以是任意形状的，因此一般选取方便计算的路径曲线（此处的方便计算可以简单认为令分母等于常数σ）</li>
</ul>
<p><img src="/images/image-20230807105328633.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="5-2-3-斯提克斯公式"><a href="#5-2-3-斯提克斯公式" class="headerlink" title="5.2.3 斯提克斯公式*"></a>5.2.3 斯提克斯公式*</h4><p>斯托克斯公式主要用于计算空间第二型曲线积分，该公式只需要会套公式使用即可</p>
<p><img src="/images/image-20230524235751321.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>右手系指的是右手四指绕着边界曲线的方向，大拇指的方向就是曲面Σ的法向量方向；</li>
<li>斯托克斯的取巧方法可以理解为是泡泡棒中，没有任何形变时的泡泡平面就是最简单的曲面；</li>
</ul>
</blockquote>
<h2 id="6-第二型曲面积分"><a href="#6-第二型曲面积分" class="headerlink" title="6.第二型曲面积分"></a>6.第二型曲面积分</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><h4 id="6-1-1-定义"><a href="#6-1-1-定义" class="headerlink" title="6.1.1 定义"></a>6.1.1 定义</h4><p>第二型曲面积分也称为对坐标的曲面积分，即对有方向的曲面（通过曲面上的法向量来指向曲面的侧&#x2F;方向）进行的曲面积分</p>
<p><img src="/images/image-20230524234644130.png" srcset="/img/loading.gif" lazyload></p>
<p>对应的图示如下</p>
<p><img src="/images/image-20230524234740644.png" srcset="/img/loading.gif" lazyload></p>
<p>第二型曲面积分的物理意义在于向量场中通过某曲面的通量</p>
<p><img src="/images/image-20230524234933819.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-1-2-性质"><a href="#6-1-2-性质" class="headerlink" title="6.1.2 性质"></a>6.1.2 性质</h4><p>同样的，第二型曲面积分的性质也与普通的定积分、二重积分等有所区别，下面是其对称性的分析</p>
<p><img src="/images/image-20230524235119770.png" srcset="/img/loading.gif" lazyload></p>
<p>第二型曲面积分的性质如下</p>
<p><img src="/images/image-20230524235144196.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-2-计算方法"><a href="#6-2-计算方法" class="headerlink" title="6.2 计算方法"></a>6.2 计算方法</h3><h4 id="6-2-1-基本方法"><a href="#6-2-1-基本方法" class="headerlink" title="6.2.1 基本方法"></a>6.2.1 基本方法</h4><p>基本方法是先拆分为三个曲面积分，然后分别化为二重积分（仍然使用口诀“一投二代三计算”）</p>
<p><img src="/images/image-20230524235307624.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>关于“一投”，需要将其投影到相应的坐标面而非无脑投影到xOy</p>
<p>关于“二代”，也需要根据投影的情况选择代入公式（比如投影到xOy平面则需要化为关于x和y的函数）</p>
<p>关于“三计算”的符号问题，非常好确定</p>
<ul>
<li>对dxdy来说，法向量向上取正，向下取负</li>
<li>对dydz来说，法向量向前取正，向后取负</li>
<li>对dxdz来说，法向量向右取正，向左取负</li>
</ul>
</blockquote>
<h4 id="6-2-2-高斯公式"><a href="#6-2-2-高斯公式" class="headerlink" title="6.2.2 高斯公式*"></a>6.2.2 高斯公式*</h4><p>高斯公式和格林公式如出一辙，将二型曲面积分转化为三重积分（该三重积分的被积函数为散度）</p>
<p><img src="/images/image-20230524235420543.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>挖去法所挖掉的曲面应当是向内的，这样才能保证整个积分闭曲面是向外的</li>
</ul>
</blockquote>
<hr>
<p>总结：</p>
<ul>
<li><p>牛莱公式将a-&gt;b区域上的一重定积分转换为a,b端点相关的原函数计算；</p>
</li>
<li><p>格林公式将平面闭区域D上的二重积分与其边界曲线上的曲线积分(二型线积分)相互转换；</p>
</li>
<li><p>高斯公式将空间闭区域Ω上的三重积分与其边界曲面上的曲面积分(二型面积分)相互转换；</p>
</li>
<li><p>斯托克斯公式将曲面Σ上的曲面积分(二型面积分)与沿着Σ的边界曲线的曲线积分(二型线积分)相互转换；</p>
</li>
</ul>
<hr>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%80%83%E7%A0%94/" class="category-chain-item">考研</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/">#高等数学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>考研_数学一_高数</div>
      <div>https://gintoki-jpg.github.io/2023/02/20/考研_数学一_高数/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>杨再俨</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月20日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/27/%E4%B8%93%E4%B8%9A_%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" title="知识图谱">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">知识图谱</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/10/%E8%AE%BA%E6%96%87_%E4%BC%9A%E8%AF%9D%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/" title="会话情感分析">
                        <span class="hidden-mobile">会话情感分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  

</div>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>







  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
