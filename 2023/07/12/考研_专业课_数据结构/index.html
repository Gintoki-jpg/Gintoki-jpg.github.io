

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/logo.png">
  <link rel="icon" href="/img/bg/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="杨再俨">
  <meta name="keywords" content="">
  
    <meta name="description" content="北邮809数据结构复习总结">
<meta property="og:type" content="article">
<meta property="og:title" content="考研_专业课_数据结构">
<meta property="og:url" content="https://gintoki-jpg.github.io/2023/07/12/%E8%80%83%E7%A0%94_%E4%B8%93%E4%B8%9A%E8%AF%BE_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Tintoki_blog">
<meta property="og:description" content="北邮809数据结构复习总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gintoki-jpg.github.io/img/bg/study.jpg">
<meta property="article:published_time" content="2023-07-12T13:28:00.000Z">
<meta property="article:modified_time" content="2023-08-29T09:00:10.272Z">
<meta property="article:author" content="YangZaiyan">
<meta property="article:tag" content="数据结构设计">
<meta property="article:tag" content="算法分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gintoki-jpg.github.io/img/bg/study.jpg">
  
  
  
  <title>考研_专业课_数据结构 - Tintoki_blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gintoki-jpg.github.io","root":"/","version":"1.9.1","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tintoki_blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">考研_专业课_数据结构</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-12 21:28" pubdate>
          2023年7月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          61k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          507 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">考研_专业课_数据结构</h1>
            
            <div class="markdown-body">
              
              <hr>
<p>2023&#x2F;7&#x2F;12 21:30 本来今天晚上是打算再看一会数学的，但是实在是看不下去了，数学这个科目一天看太久了真的会变得及其没有效率（当然晚上熬夜玩手机会导致第二天早晨也没有效率，这两个的原因不同但是造成的结果是相同的）；最近反正也没什么事情就打算开始把专业课拿起来复习一下，最好就是感觉自己没有效率的时候看一看，先过一遍知识点，其他的怎么复习相关的细节到时候再根据临时情况补充即可；其实在我之前的博客中是有写过很多有关数据结构或者算法相关的文章的，比如<a href="https://gintoki-jpg.github.io/2022/06/27/%E5%85%B6%E4%BB%96_%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/">力扣算法经典题目刷题</a>、<a href="https://gintoki-jpg.github.io/2022/09/07/%E9%80%9A%E8%AF%86_%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">北邮算法设计与分析</a>以及<a href="https://gintoki-jpg.github.io/2022/10/24/%E9%80%9A%E8%AF%86_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">大话数据结构笔记</a>，但是无论写过多少次，根据“不使用就会遗忘”定律，现在我基本上已经把数据结构的知识点都忘得差不多了；写这篇博客的目的就是结合之前学过的知识点(整理过的笔记)以及北邮官方的数据结构和算法教材，专门针对809数据结构考研进行一个模块化的学习（简单说就是为了应付考试所以才写这篇博客）；</p>
<p>2023&#x2F;7&#x2F;13 20:14 因为实际上北邮本身的教材就足够有参考意义，所以这里第一遍过知识点的之后我就尽量不参考其他的资料包括之前做的笔记，完全按照教材上的内容对知识结构进行总结，遇到实在很难理解或者比较超纲的知识点再选择其他资料参考；</p>
<p>2023&#x2F;7&#x2F;14 22:20 因为数据结构这门课程本身就有一定的不严谨，所以无论是北邮的教材还是大话数据结构其实有些概念会令人误解，所以在学习的时候不要过度去解读某些概念，只要能够按照自己的思维方式理解区分就行。另外，之前做的数据结构的笔记是真的垃，现在看来那个笔记中能够借鉴的东西非常少，可能也就ADT的定义可以借鉴，其他的具体存储结构实现代码什么的就完全按照北邮教材来就行（知识框架的结构也按照北邮教材来，之前笔记中的结构有问题，容易让人产生误解）；</p>
<p>2023&#x2F;7&#x2F;15 20:23 这个只能慢慢看，反正现在也不着急，最重要的是打好基础所以一定要书上的基本知识点掌握牢靠，宁愿多做一些笔记也是可以的。需要注意的是做笔记一定要做好目录知识结构的整理，这对形成整体的知识体系极其重要；</p>
<p>2023&#x2F;7&#x2F;16 21:30 数据结构第一遍过就是按照现在这样把书上的知识点整理到笔记上形成完整的知识结构即可。至于知识点会遗忘是肯定的毕竟高数你都不能全部记住别说数据结构才刚开始。数据结构因为有基础所以看起书来基本上没什么问题，第一遍过数据结构的目的就是把所有考纲规定的知识点整理在一起。整理完之后再集中精力刷题；</p>
<p>2023&#x2F;7&#x2F;17 22:27 并没有将书上的所有知识点都详尽的整理在笔记中，只是将最基础的知识点整理了出来。针对某些拓展性问题（比如课后思考题等）现在没有必要去思考该怎么解决，那是之后第二轮刷题的时候应该做的事（现在就算看懂了过段时间也可能会忘记）；</p>
<p>2023&#x2F;7&#x2F;20 12:47 这个书上有些答案是错的，比如说KMP那一节的next数组求解书上完全就是乱写的…所以也不要过度相信教材上的“金科玉律”，适当觉得看不懂的时候就上网寻找标准答案不要浪费时间在那里纠结是否是教材出错或者是否是教材太难理解（这两个没有本质区别，这个教材有些地方就喜欢把简单的讲的很难真服了…）。另一点就是卡尔的哪个前缀表的求法也是错的，也就是说教材和卡尔的方法都是错的（我也不知道为什么你运气这么好就刚好碰上），所以花了一个上午在那里不知道干什么，属于是被自己的定势思维坑了。反正现在第一遍做的笔记也不能全部认为是百分百正确的，之后还要在反复的刷题过程中不断验证；</p>
<p>2023&#x2F;7&#x2F;20 17:34 之所以前期花费很多功夫去琢磨一些字眼上的概念就是为了在重塑知识体系的时候能够更加清晰明了，加快后期的复习速度（这一点的优势其实已经体现出来，现在能够对书上那些编写有问题或者说不严谨的地方进行再整理）。数据结构的课程中穿插了一些算法相关的知识点，这些出现的知识点无疑是非常重要的考研肯定会考察的，但是我想放在之后学习完所有的数据结构之后再回头专攻算法，所以书上做了标记的地方表示跳过后期需要回头整理的知识点；</p>
<p>2023&#x2F;7&#x2F;20 22:52 感觉你被之前做过的无效笔记搞得很恼火啊，我再说一遍，像什么高数之类的你都全盘推翻了，更别说这个数据结构了，之前你做过的那些笔记说实话就没什么可以参考的意义（因为做的真的太简单了…完全就只是写了个大概的框架，另一点是有些知识点和教材上的知识点不兼容…甚至都是错的）。所以之后做笔记之前的那个参考笔记就真的只是用来看看就行，一切都以教材为主，其他的参考教材啊参考资料什么的都放一边不要扰乱自己的心态！！！（最近心态真的太容易受影响了，把这段时间作为一个考验熬过去吧…加油！！）</p>
<p>2023&#x2F;7&#x2F;22 22:11 截至目前，基本的数据结构已经复习完毕（剩下的算法相关放在之后刷题过程中进行）；接下来需要做的就是把教材上的题刷一遍巩固知识点，如果说第一遍仅仅只是快速的过知识点的话，第二遍就需要完全静下心来好好的理解消化；</p>
<p>2023&#x2F;7&#x2F;23 21:28 北邮教材上的习题给我一种不是特别全的感觉？？？…怎么办呢，初步先把北邮教材上的题刷一遍（毕竟整理的笔记就是按照北邮教材来整理的，刷题是为了进一步巩固知识点）；完了第二遍就可以找王道数据结构上的题来刷，进一步的加大题量，无论如何不要同时使用多种教材，这只会带来负面影响。另外北邮的那本参考答案上面有很多详细的讲解，暂时因为状态原因先不看，但个人认为是非常重要的考点，后期还是需要回过头来看（一句话概括就是北邮的两本教材是重中之重，吃透了这门专业课肯定不成问题，所以无论怎么安排这两本书一定要完整的看完并非常熟练）</p>
<p>2023&#x2F;7&#x2F;24 21:28 书上出现的每一道例题以及辅导教材上的相关文字都应当仔细阅读并理解，再次强调这两本书就是考研的致胜法典，因此说是逐字逐句或者咬文嚼字的阅读这两本教材都是没有任何夸大成分的。现在是第二轮的强化理解阶段，不要求你刷很多题，只需要静下心来好好看书慢慢理解吃透考纲上的每个数据结构以及算法即可；</p>
<p>2023&#x2F;7&#x2F;25 20:29 最近是真的大晚上的复习数据结构那是一个看不进去啊…感觉就像是强行往脑子里面塞东西似的，我不知道是不是因为白天做数学把精力耗费的太多的缘故，如果真的是这样的话可以适当调整把线代和概率论放在晚上（毕竟也已经过完一遍，不需要那么细致的磕知识点）。反正现在的状态就是强行让自己坚持学习，关于数据结构的复习策略我并没有完全按照网上推荐的来，反正如果什么时候觉得进度不合适或者方法不行的话就适当停下来在网上找找相关的复习建议，这里贴一个看到的比较好的文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67733473">数据结构考研如何120+</a>可适当参考（注意一定是适当，这文章里的东西不能按部就班）；</p>
<p>2023&#x2F;7&#x2F;27 22:00 之前数据结构复习的规划有问题，这里调整一下。静下心来把高分笔记和配套的练习题全部过一遍，最后北邮的教材和对应的习题可以稍微练一练。之前跟着北邮的教材进行复习真的很懵，看完一遍之后完全抓不住重点（另一方面很可能是因为你自己当时把重心放在了过知识点整理知识点而不是细心理解上，无论如何第二遍的复习必须将每一节的知识点都吃透）。因此这里暂时调整数据结构的复习重心全部放在高分笔记及其练习题上，其他的资料可以先不用看，保持复习资料的简洁；</p>
<p>2023&#x2F;7&#x2F;30 20:03 最近也是花了不少的时间在复习数据结构上，但是这门科目给我的感觉非常奇怪（与其他两门课的真的很不一样），没有复习的正反馈不说（最近开始手写代码才有一点点的满足感），我根本抓不住复习的重点啊…也不是说什么复习资料找的不够好还是怎么的，现阶段我基本上把市面上数据结构相关的复习资料全部整理完毕了，我选择的资料肯定是最适合复习的，但是仍然出现这样的问题就让我百思不得其解（就因为这门课我真的在很多时候莫名其妙的焦虑和烦躁，我甚至都不想复习这门课…有抵触情绪了属于）。刚刚突然有一点感想，选用的天勤数据结构，这本教材我们确实需要静下心来看，结合手写代码（选用天勤的代码是因为真的很好理解）能够把最基本的数据结构和基本算法操作完全掌握。这本书的槽点在于它经常给你一些例题啥的，这种例题的代码非常的长而且非常的综合，我真的很不喜欢这种感觉，为什么不能分门别类的将各个算法的基本操作介绍完毕之后再通过例题进行强化训练呢？是否本末倒置？（王道刚好与它相反，但是王道我们放在后面再用别混着用）因此在接下来的复习过程中，我们只需要将书上的重要知识点以及基本代码掌握（这里所说的掌握就是真的能够熟记于心的掌握而不是第一遍那种走马观花），对于那种大综合的例题什么倒置算法啊归并算法这种属于面试或者考察大题的算法题放在之后统一整理（卡尔的数据结构那种分类方式相当好，通过按照不同的数据结构来区分算法题，让我们知道不同的数据结构能够考出什么花样） – 说白了你现在觉得没有正反馈看的很难受就是因为这些教材的组织方式，相当于让你边学基本功边修炼高级功法，这对基础好的人来说可能很爽但是对于脚踏实地想要一步步打怪升级的复习者来说不是一个值得推荐的行为 – 漂亮！刚才无意间刷到了天勤数据结构的配套视频，然后发现这个视频上面的分类还挺好的（那个书的主要问题是有些介绍不够详细并且考点总结的不是很系统，刚好它的配套视频在一定程度上弥补了这两方面的缺陷），所以现在再次调整复习方案，在第二遍的基础复习的过程中结合天勤的视频(视频链接<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1C84y1q7LA?p=1&vd_source=276d55048634a5b508b1b53a1ecd56b3">哔哩哔哩_bilibili</a>（B站有字幕）)把书上的知识点好好的掌握；</p>
<p>2023&#x2F;8&#x2F;1 17:20 八月份如约而至，不管之前复习的咋样状态咋样，现在都应该按照原定计划加入专业课和政治课的复习。现在唯一有一点点复习问题的就是专业课，因为前期无脑乱冲导致从复习资料的选取一开始就犯下了错误，进而导致之后的半个多月的复习效果非常差，甚至打击到了本人的自尊心。好在经过不断地探索和试错之后总结出了一套适合我自己的数据结构专业课的复习方法，这里简单概述一下方便之后回顾。首先是参考书的选择，暂时选定的是王道、天勤以及北邮数据结构(包括拓展教材)一共四本，严的数据结构因为难度较大且暂时没有更多的时间去试错，所以在前期不考虑。之所以选择这四本作为参考资料而不是像其他学科一样只跟一本的原因是，这三本教材各有各自的优点但是又有对方不具备的缺点。王道和天勤的书作为第二轮的复习主力，天勤主要还是拿给我抄代码使用（毕竟天勤是真的简单易懂），王道主要指明有哪些要考的知识点，至于北邮的两本教材推荐放在最后使用，里面有一些非常牛的算法设计思路以及新题型是王道和天勤这种针对408统考而设计的辅导书不具备的，但是因为北邮的两本教材难度实在是有点大所以真的不推荐一上来就抱着啃（不管是算法思想还是代码风格都挺需要花时间去消化，这个在第一轮的时候已经领教过）。截止目前我已经把四本书的第一章也就是绪论全部攻克（这意味着之后没有必要再花时间在这四本书的第一章上面），接下来从线性表开始就属于是真正的考纲要求的内容，暂时定下来的复习方法是先看天勤的书然后手写重要代码跟着走一遍，完了看王道的书把要考的知识点和课后题刷一遍，最后将天勤和王道上面剩余的具有代表性但不是基础性的算法代码进行总结归纳（总结归纳还是得整理到笔记上，可以重新开一个专门的手写代码笔记模块，便于之后的复习回顾）；将王道和天勤对应章节的内容全部理解完毕之后就可以看北邮的两本教材，注意无论是看哪本书，如果出现超纲的内容就暂时放弃放在后面回顾的时候再来整理（相较于408数据结构就一门科目，所以这四本教材反复被翻阅其实也不是什么难事，后期反复总结是常有的事）。</p>
<p>2023&#x2F;8&#x2F;4 16:50 刚才刷完了王道线性表的例题，也标志着线性表的基础理论知识这部分已经全部完成（高级算法设计放在后续强化阶段进行），这里我简单总结一下最新的这种复习规划是否有效以及后续的安排。这一段时间的数据结构复习主要使用的就是两本书，《王道数据结构》和《天勤高分笔记》，至于北邮的那两本教材基础性的知识早就在“快速过一遍”那会总结到这篇blog上了，剩下的也都是具有创新意义和思考价值的高级算法设计题，针对我们现在第二阶段的“慢慢打基础”作用不大。我简单把数据结构的复习归为这几个阶段：快速过一遍、慢慢打基础、强化提高、极限冲刺。现在正是处于慢慢打基础的时候，需要做的主要就是把王道和天勤上面有关基本数据结构的代码和基本算法思想全部消化和吃透，而针对这两本书以及北邮两本书上的高级算法设计题专门放在强化提高的阶段来进行（因为很多设计题的思想其实并不是只适用于一种数据结构）。最后极限冲刺打算刷刷真题卷即可，数据结构这门课程急不得，更多的是需要去理解和背诵，所以我并没有按照网上说的那样假期就开始刷真题（其实和高数复习是一个道理，需要一遍又一遍的巩固，刷100道题还不如吃透同一种出题思想。）因为数据结构的复习参考确实不多所以一开始确实显得有点手忙脚乱，但是这段时间的磨合调整还是有一定的作用的，继续坚持下去，这样的复习规划确实可行。“慢慢打基础阶段”，针对每一章，先看天勤的书，总结算法代码并刷题，再看王道的书，拓展算法代码并刷题，<code>两本书上的知识点注意都需要总结到这篇blog上</code>。</p>
<hr>
<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><p>在开始全书的章节之前一定要先辨析“数据结构”和“算法”这两个概念是有区别的，也就是说实际上“数据结构与算法”是两门课程，分别是“数据结构设计”和“算法设计”，对应大学期间大一和大三学习的两门课程，这两门课程的侧重点是不同的。下面简单说明“数据结构”和“算法”之间的联系和区别。</p>
<p>现实世界中的所有问题都可以归类为两大类：</p>
<ul>
<li>数值计算问题：如概率统计、求极限、求面积，该类问题一般采用数学建模、公式推导来解决；</li>
<li>非数值计算问题：如图书管理问题、对弈问题、路由问题，该类问题一般使用数据结构与算法来解决；</li>
</ul>
<p>程序设计（也就是利用编程来解决现实生活中的非数据计算问题）主要关注两个方面：</p>
<ul>
<li>数据表示：考虑如何将待处理的数据存储到计算机中，其本质是<code>数据结构设计</code>（研究如何将现实生活中的复杂数据合理高效的存储在计算机中的方法）；</li>
<li>数据处理：使用何种逻辑来操作这些数据，其本质是<code>算法设计</code>（研究面对实际问题需要进行的操作如增加、删除、修改、查找某一本书的方法，简单来说算法主要研究如何进行高效稳定的查询、删除以及其他操作）；</li>
</ul>
<p>不同的数据结构设计会对应不同的算法设计，进而导致设计的程序具有不同的执行效率。</p>
<h2 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1.数据结构的基本概念"></a>1.数据结构的基本概念</h2><p><img src="/images/image-20230713203959692.png" srcset="/img/loading.gif" lazyload alt="数据结构各概念之间的关系"></p>
<ul>
<li>数据（data），是信息的载体，能够被计算机识别、存储和加工处理。在计算机领域中，人们通常将数据分为两大类：一类是数值型数据，如代数方程求解程序中所使用的整数或实数数据；另一类是非数值型数据，如音视频播放器程序播放的声音或视频、互联网络中的Web数据等。</li>
<li>数据元素（data element），是数据的基本单位，在计算机程序中通常作为一个整体进行处理。例如，学生成绩单中每个学生的信息就是一个数据元素。有些情况下，数据元素也称为元素、结点、顶点或记录。</li>
<li>数据项（data item），是构成数据元素的不可分割的最小单位。每个数据元素可以包含多个不同的数据项，每个数据项具有独立的含义。例如，学生成绩单中每个学生的信息可以包含学生的班级、学号、姓名、成绩等，这些都是数据项。有时也将数据项称为字段或域。</li>
<li>数据类型（data type），是<code>具有相同性质的计算机数据的集合</code>以及<code>在这个数据集合上的一组操作</code>。数据类型可以分为简单类型（或称为原子类型）和构造类型（或称为结构类型）。例如，C++语言中，整数、实数、字符等都是简单的数据类型，而数组、结构类型、类等都是构造类型。每种类型的数据都有各自的特点及相关运算。</li>
<li>数据结构（data structure），是指按照某种<code>逻辑关系</code>组织起来的一组数据，按一定的<code>存储方式</code>存储在计算机的存储器中，并在这些数据上定义了<code>一组运算</code>的集合。通常人们认为数据结构包含以下 3 个方面的内容<ul>
<li>数据元素之间的逻辑关系，也称为数据的逻辑结构（logical structure）</li>
<li>数据元素及其关系在计算机存储器内的存储形式，称为数据的存储结构（storage structure）或物理结构</li>
<li>对数据的基本操作或运算</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips：上述数据结构的定义出自北邮《数据结构与算法》，被认为是一种广义上的定义（严蔚敏的《数据结构》中有提到过，有关“数据结构”的定义至今没有一个统一的定论）。</p>
</blockquote>
<h3 id="1-1-逻辑结构"><a href="#1-1-逻辑结构" class="headerlink" title="1.1 逻辑结构"></a>1.1 逻辑结构</h3><p>数据的逻辑结构描述了数据相互间的关联形式或邻接形式，反映了数据内部的构成方式，定义了数据的本质特点，因此人们<code>常常将数据的逻辑结构直接称为数据结构</code>。数据的逻辑结构独立于计算机，与存储方式无关，可认为是从具体问题抽象出来的数学模型。数据元素之间不同的逻辑特点代表不同的逻辑结构，常见的逻辑结构有4种，分别是<code>集合、线性结构、树和图</code>。</p>
<p><img src="/images/image-20230713204847935.png" srcset="/img/loading.gif" lazyload alt="常见数据结构示意图"></p>
<ul>
<li>集合，其数据元素之间的逻辑特点是满足“共同属于一个集合”的关系。通常要求集合中的元素不可重复，不考虑元素之间的先后次序。</li>
<li>线性结构，其数据元素之间的逻辑特点是有且只有一个起始结点和一个终端结点，并且其他结点的前面有且只有一个结点（称为直接前驱），每个结点的后面有且只有一个结点（称为直接后继）。线性结构的数据元素之间在一维线性空间中有确定的先后次序。</li>
<li>非线性结构，这种结构区别于集合和线性结构<ul>
<li>树结构，其数据元素之间存在着一对多的层次关系。</li>
<li>图结构，数据元素之间存在着多对多的关系。</li>
</ul>
</li>
</ul>
<h3 id="1-2-存储结构"><a href="#1-2-存储结构" class="headerlink" title="1.2 存储结构"></a>1.2 存储结构</h3><p>数据的存储结构考虑的是如何在计算机的存储器中存储各个数据元素，并且同时反映数据元素间的逻辑关系。对于每种逻辑结构，都可以设计多种存储方法，基本的存储结构通常有两大类：顺序存储结构和链式存储结构。</p>
<p><img src="/images/image-20230713205138421.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>顺序存储结构，即用一组连续的存储单元依次存储各个数据元素。数据元素间的逻辑关系由存储单元的邻接关系来体现。通常顺序存储结构借助于程序设计语言的数组来描述。</li>
<li>链式存储结构，即用一组任意的存储单位存储各个数据元素，数据元素间的关系通常用指针来表示，例如，后一个元素的地址存储在前一个元素的某个特定数据项中。</li>
</ul>
<hr>
<blockquote>
<p>Q：数据的逻辑结构和存储结构之间有什么关系？</p>
</blockquote>
<p>A：数据的逻辑结构反映了数据内部的逻辑关系，是面向实际问题的；而存储结构是面向计算机具体实现的，其目标是将数据及其逻辑关系存储到计算机中。仅有逻辑结构，只能确定对数据有哪些操作，而如何实现这些操作是不得而知的。因此，只有确定了数据的存储结构，才能设计对数据的具体操作算法。而且对于相同逻辑结构的同一种操作，如果采用不同的存储结构进行存储，对数据处理的效率往往也是不同的。因此，需要根据对数据的操作来设计合理的存储方式，以提高处理效率。上述逻辑结构和存储结构以及算法之间的关系为接下来学习不同的数据结构提供了指导思想：</p>
<ol>
<li>首先分析其逻辑结构；</li>
<li>基于逻辑结构学习其各种常见的存储结构；</li>
<li>针对每种存储结构研究各种算法的实现；</li>
</ol>
<p>总的来说，数据结构课程重点之一就是研究各种逻辑结构的不同存储结构。</p>
<hr>
<h2 id="2-算法的基本概念"><a href="#2-算法的基本概念" class="headerlink" title="2.算法的基本概念"></a>2.算法的基本概念</h2><h3 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h3><p>算法的基本定义为“算法是指对数据的操作方法的描述，即解决一个问题的一系列步骤”。这部分内容参考<a href="https://gintoki-jpg.github.io/2022/09/07/%E9%80%9A%E8%AF%86_%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">北邮算法设计与分析</a>，个人认为讲的非常详细。</p>
<p>算法可以使用多种方法来描述，如自然语言、流程图、伪代码(也被称为算法语言)、程序设计语言(如C、Python)或其他约定的语言。能够使用程序设计语言描述最好，但对于初学者来说掌握基于C++语言的伪代码来描述算法即可。</p>
<p>算法是解决问题的方法，从计算机的角度来看算法是由若干条指令组成的有穷序列，通常一个问题可以有多种不同的算法，无论什么算法都必须满足以下5个准则：</p>
<ol>
<li>输入：具有 0个或多个输入的参数。</li>
<li>输出：算法执行要有输出结果，不同的输入通常对应不同的输出。</li>
<li>有穷性：算法中每条指令的执行次数必须是有限的，也就是说算法在执行了有穷步后能够结束（算法和程序的区别，程序可以不满足有穷性入操作系统）</li>
<li>确定性：每条指令必须有确切的含义，无二义性。</li>
<li>可行性：每条指令的执行时间都是有限的。</li>
</ol>
<h3 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h3><h4 id="2-2-1-时间复杂度"><a href="#2-2-1-时间复杂度" class="headerlink" title="2.2.1 时间复杂度"></a>2.2.1 时间复杂度</h4><p>算法的时间复杂度是对算法执行时间的度量。</p>
<ul>
<li>算法的<code>执行时间</code>往往与算法本身、计算工具以及问题的规模等因素相关。</li>
<li>在分析算法的时间复杂度时，可以忽略计算工具的因素。</li>
<li>问题规模通常是指算法处理的数据量的大小，例如对同一个排序算法，对10个数排序和对10000个数排序的执行时间是不同的。在分析时间的复杂度时要处理的数据量往往不能确定，因此通常将问题规模设为n作为参数分析。运行算法所需要的时间T可以看作是问题规模n的函数，记作T(n)。</li>
</ul>
<p>一个算法的执行时间，应该是该算法每条语句执行的时间之和。假定每条语句执行一次所需的时间是单位时间，则每条语句执行的时间正比于该语句执行的次数。通常将语句执行的次数称为该语句的频度（frequency count）。算法运行所需要的时间可认为是算法中所有语句的频度之和。</p>
<p>在分析时间复杂度时，也可以直接利用算法中的基本语句进行计算。所谓基本语句，是指其执行次数与算法的执行次数成正比的语句。</p>
<p>常见的时间复杂度有：常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n^2^)、立方阶O(n^3^)、k次方阶O(n^k^)、指数阶O(k^n^)等，通常认为具有指数阶量级的算法是不可计算的</p>
<p>随问题规模n的增大，上述时间复杂度的增长率依次增大</p>
<p><img src="/images/image-20230723221656465.png" srcset="/img/loading.gif" lazyload alt="不同时间复杂度和问题规模n的变化比较"></p>
<p>其大小关系如下<br>$$<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)<br>$$</p>
<blockquote>
<p>结论1：对于实现同样的功能，递归函数的执行效率往往比非递归算法的效率低得多（即时间复杂度更大）；</p>
</blockquote>
<h5 id="1-递归函数时间复杂度分析"><a href="#1-递归函数时间复杂度分析" class="headerlink" title="(1)递归函数时间复杂度分析"></a>(1)递归函数时间复杂度分析</h5><p>若算法调用递归函数，其时间复杂度分析较为复杂，通常将其时间复杂度的分析转化为一个递归方程的求解渐进阶的问题。递归方程的形式有多种多样，因此求解方法也有不同，比较常见的方法如：</p>
<p>（1）代入法（Substitution Method）：先推测递归方程的显式解，然后用数学归纳法来验证该解是否合理。<br>（2）迭代法（Iteration Method）：迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端即方程的解的估计。</p>
<p>（3）套用公式法（Master Method）：该方法针对形如“T（n）&#x3D;a*T（n&#x2F;b）+f（n）”的递归方程。这种递归方程是分治法的时间复杂性所满足的递归关系，即一个规模为n的问题被分成规模均为n&#x2F;b的a个子问题，递归地求解这a个子问题，然后通过对这a个子问题的解的综合，得到原问题的解。<br>（4）差分方程法（Difference Formula Method）：可以将某些递归方程看成差分方程(数三专有考点)，f通过解差分方程的方法来解递归方程，然后对解做出渐近阶估计。</p>
<p>理论知识点可以参看链接<a href="https://gintoki-jpg.github.io/2022/09/07/%E9%80%9A%E8%AF%86_%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/#1-4-%E9%80%92%E5%BD%92%E6%96%B9%E7%A8%8B%E6%B8%90%E8%BF%9B%E9%98%B6%E7%9A%84%E6%B1%82%E8%A7%A3">递归方程渐近阶的求解</a>，具体时间复杂度这一节还是应该落实到刷题+整理笔记上，建议自行总结常见时间复杂度的题型和求解方法。</p>
<h5 id="2-加法法则和乘法法则"><a href="#2-加法法则和乘法法则" class="headerlink" title="(2)加法法则和乘法法则"></a>(2)加法法则和乘法法则</h5><p>注意这里的加法法则和乘法法则与先前概率论中介绍的概念不同，此处</p>
<ul>
<li>加法法则指的是程序总时间复杂度&#x3D;量级最大的代码段的时间复杂度，即T(n)&#x3D;O(max(f(n),g(n)))</li>
<li>乘法法则指的是嵌套代码的复杂度等于嵌套内外代码复杂度的乘积，即T(n)&#x3D;O(f(n)*g(n))</li>
</ul>
<h4 id="2-2-2-空间复杂度"><a href="#2-2-2-空间复杂度" class="headerlink" title="2.2.2 空间复杂度"></a>2.2.2 空间复杂度</h4><p>算法的空间复杂度是指算法在执行过程中所耗费的存储空间。一般来说，算法的空间复杂度也是问题规模n的函数。早期的计算机系统内存较小，因此在设计算法时往往需要在很大程度上将注意力放在如何降低算法运行时占用的空间。随着计算机内存储器成本的降低及存储容量的不断增大，常常可以牺牲算法的空间效率来获得其更高的时间效率。当然，如果问题规模n很大，算法的空间效率也是非常重要的，此时也需要准确分析其空间复杂度，如海量数据处理问题。</p>
<h4 id="2-2-3-NP问题"><a href="#2-2-3-NP问题" class="headerlink" title="2.2.3 NP问题"></a>2.2.3 NP问题</h4><p>将以多项式时间解决为衡量标准的问题归为三大类：</p>
<ol>
<li>NP多项式复杂程度的非确定性问题；</li>
<li>NP完全问题；</li>
<li>NP难度问题；</li>
</ol>
<p>对于某个问题，若存在以问题规模 n为变量的多项式函数 p（n），解决该问题的算法的时间复杂度为O（p（n）），则称该问题为多项式时间问题（polynomial time problem），简称P问题，或者说，如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。其解决算法为多项式时间算法（polynomial time algorithm）。例如，时间复杂度为O(1)、O(3n^3^)等的算法均为多项式时间算法。</p>
<p><img src="/images/image-20230725191427297.png" srcset="/img/loading.gif" lazyload alt="多项式时间算法的时间复杂度"></p>
<p>另外一类算法，其任何时间复杂度函数都不能用多项式函数去界定，这类算法称为指数时间算法。例如时间复杂度为O(2^n^)、O(n^n^)的算法都可以认为是指数时间算法。如果问题规模n很大，显然多项式时间算法优于指数时间算法。</p>
<p>对于很多问题，可能不清楚是否存在一个能在多项式的时间里解决它的算法，但可以在多项式的时间里验证一个解，这种问题称为非确定性多项式时间问题（non-deterministic polynomial time problem），简称NP问题，显然 P包含于NP。</p>
<p>例如，大的合数分解质因数的问题，没有一个公式，把合数代进去，就直接可以算出它的因子。这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这就是非确定性问题。而这些问题通常有个算法，它不能直接告知答案是什么，但可以告知，某个可能的结果是正确的还是错误的。这个可以告知“猜算”的答案正确与否的算法，假如可以在多项式时间内算出来，就称作NP问题。而如果这个问题的所有可能答案，都是可以在多项式时间内进行正确与否的验算的话，就称作NP完全问题，也称作NPC问题。例如，教学安排中的排课算法就是一个 NPC问题。</p>
<p>NP 问题通俗来说是其解的正确性能够被“很容易检查”的问题，这里“很容易检查”指的是存在一个多项式检查算法。若 NP 中所有问题到某一个问题是图灵可归约的，则该问题为 NP-hard问题。NP-hard问题不一定是一个NP问题，但所有的 NP问题都可以约化到该问题。例如，售货员旅行问题即 TSP（Traveling Salesman Problem）问题，是最具有代表性的 NP 问题之一。</p>
<p>（其实上面讲的已经足够直观了…但对于初学者来说可能真的很难理解，可以再去网上找一找相关的资料辅助理解）</p>
<h2 id="3-抽象数据类型"><a href="#3-抽象数据类型" class="headerlink" title="3.抽象数据类型"></a>3.抽象数据类型</h2><p>数据类型是指一组性质相同的值的集合以及定义在此集合上的一些操作的总称，因为不同的数据类型有不同隐藏的细节，进而引出了抽象数据类型ADT的概念</p>
<p>抽象数据类型（ADT）：是指一个数学模型以及定义在该模型上的一组操作。一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系以及对数据元素的操作。ADT体现了程序设计中对问题的分解、抽象和信息隐藏的特性</p>
<p>为了便于在之后的学习中对抽象数据类型进行规范的描述，给出如下抽象数据类型的标准格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 抽象数据类型名<br>Data （数据集合和数据关系集合）<br>    数据元素之间逻辑关系的定义<br>Operation（操作集合）<br>    操作<span class="hljs-number">1</span><br>    操作<span class="hljs-number">2</span><br>    操作<span class="hljs-number">3</span><br>    ......<br>endADT<br></code></pre></td></tr></table></figure>

<p>举例说明</p>
<ul>
<li>栈的抽象数据类型可以描述为：插入和删除只能在一端进行的线性表；<ul>
<li>数据对象集合是存储在栈内的数据元素</li>
<li>操作集合为元素进栈、元素出栈、判断栈空等操作</li>
<li>数据关系集合为一对一（线性表是一对一，树是一对多，图是多对多）</li>
</ul>
</li>
<li>队列的抽象数据类型可以描述为：插入元素只能在一端进行，删除元素只能在另一端进行的线性表；<ul>
<li>数据对象集合是存储在队列内的数据元素</li>
<li>操作集合为元素进队、元素出队、判断队空等操作</li>
<li>数据关系集合为一对一</li>
</ul>
</li>
</ul>
<p>设计ADT的题目需要注意以下几点：</p>
<p>1）注意 ADT 的结构格式，类似于 C 语言的结构体的写法<br>2）ADT 大括号内用数据对象集、数据关系集和操作集分开（或者参考上述代码块中用Data和Operation分开）<br>3）考研中出现的题目，一般必有数据对象集。<br>4）如果数据对象之间有很强的关联性，则应写出合适的数据关系集。如果遇到树形结构或图结构的数据关系，则用类似的边集表示方法写出。考研中最可能出现的 4 种关系：没关系、顺序关系、树形关系和图关系。<br>5）若有操作集，则写出。<br>6）不同的数据对象类型，自上而下依次列出<br>7）相同类型的数据对象，用集合表示法写出，一般考研中涉及的题目用集合的列举法表示即可<br>8）不同的操作自上而下依次列出</p>
<hr>
<blockquote>
<p>Q：抽象数据类型和逻辑结构之间有什么关系？</p>
</blockquote>
<p>A：参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/Ricol_xu/article/details/120924436">(5条消息) 数据结构、数据类型、抽象数据类型之间的关系_抽象数据类型和数据结构的关系_Xu Ricol的博客-CSDN博客</a>；</p>
<p>不妨从抽象数据类型和逻辑结构之间的形式定义上入手</p>
<ul>
<li>逻辑结构的形式定义为一个二元组(D,S)，其中D是数据元素的有限集，S是D上关系的有限集；</li>
<li>抽象数据类型的形式定义为一个三元组(D,S,P)，其中P是对D的基本操作集合；</li>
</ul>
<p>抽象数据类型描述了数据的逻辑结构和抽象运算，通常用(数据对象，数据关系，基本操作集)三元组表示，从而构成一个完整的数据结构定义；</p>
<hr>
<h2 id="4-STL概述"><a href="#4-STL概述" class="headerlink" title="4.STL概述"></a>4.STL概述</h2><p>关于STL在另外两篇博客中有非常详细的介绍，分别是<a href="https://gintoki-jpg.github.io/2022/07/08/CPP_STL%E5%88%9D%E7%BA%A7/">STL初级</a>和<a href="https://gintoki-jpg.github.io/2022/07/30/CPP_STL%E4%B8%AD%E7%BA%A7/">STL中级</a>。STL并不是这门课程考纲要求内容，但是在做课后题以及在某些章节有使用STL进行相关的拓展介绍，所以我会在这篇博客中适当补充书上与STL相关的重要内容。</p>
<p>STL（Standard Template Library，标准模板类）是 C++语言提供的一个基础模板集合，包含了各种常用的存储数据的模板类及相应的操作函数，为开发者提供了一种快速有效的访问机制。</p>
<p>通常认为STL由空间管理器、迭代器、泛函、适配器、容器和算法 6 部分构成，其中前面4部分服务于后面两部分</p>
<ul>
<li><p>空间管理器为容器类模板提供用户自定义的内存申请和释放功能。默认情况下STL仍然采用C&#x2F;C++的内存管理函数或操作符来完成动态内存的申请和释放。用户也可以不使用这些方法，而采用自己重新定义的新策略来实现内存管理，但这往往只有高级用户才有改变内存分配策略的需求，因此空间管理器对于一般用户来说并不常用。</p>
</li>
<li><p>迭代器（iterator）类似于指针，存储某个对象的地址或者说指向某个对象，有时也被称为广义指针。迭代器可以为STL中的算法提供数据输入，也可以用来遍历容器类或流中的对象。指针本身也可以认为是一个迭代器，用户也可以自定义迭代器。</p>
</li>
<li><p>在STL中，如果某个类重载了函数调用运算符“（）”，则称该类为泛函类，并称其对象为泛函。通过引入泛函，可以为算法提供某种策略。例如，同一个排序算法，可以利用泛函完成对不同关键字进行升序或降序等各种排序策略。</p>
</li>
<li><p>适配器对象将自己与另外一个对象绑定，使对适配器对象的操作转换为对被绑定对象的操作。STL中适配器应用较广，有容器适配器，如栈（stack）、队列（queue）、优先队列（priority queue），以及迭代器适配器和泛函适配器等。</p>
</li>
<li><p>所谓容器，是指可以包含若干对象的数据结构，并提供少量操作接口。STL 提供3 类标准容器，即顺序容器、排序容器和哈希容器，后两类容器有时也统称为关联容器。</p>
<ul>
<li>顺序容器，包括向量（vector）、列表（list）、双端队列（deque）。顺序容器将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。</li>
<li>排序容器，包括集合（set）、多重集合（multiset）、映射（map）以及多重映射（multimap）。排序容器中的元素位置一般通过元素键值的大小关系来确定，可以通过键值高效地查找和读取元素。</li>
<li>哈希容器，包括哈希集合（hash_set）、哈希多重集合（hash_multiset）、哈希映射（hash map）和哈希多重映射（hash_multimap）。哈希容器中的元素位置直接通过元素的键值确定，通过键值将会更加高效地查找和读取元素。</li>
</ul>
</li>
<li><p>算法可以认为是STL的精髓，所有算法都是采用函数模板的形式提供的。STL 提供的算法大致分为 4 类：日常事务类算法、查找类算法、排序类算法、工作类算法。</p>
</li>
</ul>
<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="1-线性表概述"><a href="#1-线性表概述" class="headerlink" title="1.线性表概述"></a>1.线性表概述</h2><p>线性表是一种最简单、最常用的数据结构，也是最典型的线性结构。</p>
<h3 id="1-1-线性表定义"><a href="#1-1-线性表定义" class="headerlink" title="1.1 线性表定义"></a>1.1 线性表定义</h3><p>线性表是具有相同特性的数据元素的一个有限序列：</p>
<ul>
<li>线性表可以是有序也可以是无序的；</li>
<li>线性表强调有限，即元素的个数有限；</li>
</ul>
<p><img src="/./images/image-20230714215948128.png" srcset="/img/loading.gif" lazyload alt="线性表示例"></p>
<p>线性表的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 线性表/List<br>Data<br>    线性表的数据对象集合为&#123;a1,a2,a3...&#125;，每个元素类型均为DataType。数据元素之间的关系是一对一的关系<br>Operation<br>    <span class="hljs-title function_">InitList</span><span class="hljs-params">(*L)</span>:初始化线性表，建立一个空的线性表L（即线性表元素个数为0，空表）<br>    <span class="hljs-title function_">ListEmpty</span><span class="hljs-params">(L)</span>:若线性表为空返回1，否则返回0<br>    <span class="hljs-title function_">ClearList</span><span class="hljs-params">(*L)</span>:将线性表清空<br>    <span class="hljs-title function_">GetElem</span><span class="hljs-params">(L,i,*e)</span>:将线性表中的第i个位置元素值返回给e<br>    <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(L,e)</span>:在线性表L中查找值为e的元素，查找成功则返回给元素在表中的序号，否则返回0<br>    <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(*L,i,e)</span>:在线性表L中的第i个位置插入新元素e<br>    <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(*L,I,*e)</span>:删除线性表L中第i个位置的元素并用e返回该值<br>    <span class="hljs-title function_">ListLength</span><span class="hljs-params">(L)</span>:返回线性表L的元素个数<br>endADT<br></code></pre></td></tr></table></figure>

<p>关于线性表更复杂的操作，可以由上述基本操作的组合来实现</p>
<h3 id="1-2-线性表的存储结构"><a href="#1-2-线性表的存储结构" class="headerlink" title="1.2 线性表的存储结构"></a>1.2 线性表的存储结构</h3><p>常用的线性表的存储结构包括顺序存储结构（顺序表）和链式存储结构如单链表、循环链表、双向链表、静态链表等。</p>
<p>不同于顺序表，链表用一组任意的存储单元存放线性表中的各个元素。这组存储单元可以是连续的，也可以是不连续的，甚至零散地分布在内存的某些位置。因此，链表中数据元素的逻辑次序和物理次序不一定相同，为了正确表示结点间的逻辑关系，在存储每个元素值的同时，还要存储该元素的直接后继元素的位置信息，这个信息称为指针（pointer）或链（link），这两部分信息构成了实际的存储结构，称为结点（node），然后各个结点通过指针链接起来形成一个完整的链式结构，称为链表。</p>
<p>为了方便的表示链表的存储结构，这里以单链表为例，通常采用如下形式</p>
<p><img src="/images/image-20230714220827310.png" srcset="/img/loading.gif" lazyload alt="单链表示意图"></p>
<p>用箭头来表示存储后继结点地址的指针域。其中指向第一个结点的指针，我们称为头指针；最后一个结点，由于其没有后继结点，设置为空指针，即NULL（一般在图中用lambda示意）。</p>
<p>根据链表结构或者结点结构的不同，可以把链表分为单链表、循环链表和双链表三种。</p>
<h4 id="1-2-1-顺序表"><a href="#1-2-1-顺序表" class="headerlink" title="1.2.1 顺序表"></a>1.2.1 顺序表</h4><p>顺序表是最简单的线性表存储方式，即把线性表中的数据元素按逻辑次序依次存放在一组地址连续的存储空间中。通常认为线性表中的所有数据元素具有相同的数据类型，占用相同的存储空间。</p>
<p><img src="/images/image-20230714220253052.png" srcset="/img/loading.gif" lazyload alt="顺序表示意图"></p>
<p>在C++中可以使用数组来顺序存储顺序表中的所有元素。需要注意的是，C++中数组的下标是从0开始的，因此通常将顺序表中第i个元素存储在数组中下标为i-1的位置。</p>
<h4 id="1-2-2-单链表"><a href="#1-2-2-单链表" class="headerlink" title="1.2.2 单链表"></a>1.2.2 单链表</h4><p>单链表是指链表中的每个结点只包含一个指向直接后继的指针的链表。</p>
<p>若链表为空，则头指针值为NULL；如果链表不空，头指针存储第一个结点的地址。</p>
<p>有时，单链表第一个结点不存放数据，仅作为表头使用，则称其为带头结点的单链表；否则称其为不带头结点的单链表。下图所示为两种单链表，front为指向头结点的指针。</p>
<p><img src="/images/image-20230714221153523.png" srcset="/img/loading.gif" lazyload alt="两种单链表"></p>
<blockquote>
<p>单链表的长度不包括头结点</p>
</blockquote>
<h4 id="1-2-3-单循环链表"><a href="#1-2-3-单循环链表" class="headerlink" title="1.2.3 单循环链表"></a>1.2.3 单循环链表</h4><p>如果将单链表最后一个结点的指针域指向头结点，则整个链表构成一个环，这种首尾相接的单链表被称为单循环链表</p>
<p><img src="/images/image-20230714221355738.png" srcset="/img/loading.gif" lazyload alt="单循环链表"></p>
<p>上述形式的单循环链表查找最后一个元素很慢（时间复杂度为O(1)），因此增加一个指向链表最后结点的尾指针rear（此时可以只保留尾指针不保留头指针），可以很方便的访问链表首尾两端的元素</p>
<p><img src="/images/image-20230714221538701.png" srcset="/img/loading.gif" lazyload alt="带尾指针的单循环链表"></p>
<h4 id="1-2-4-双循环链表"><a href="#1-2-4-双循环链表" class="headerlink" title="1.2.4 双循环链表"></a>1.2.4 双循环链表</h4><p>对于单链表，由于前一个结点已经存储了直接后继结点的地址，因此可以直接得到直接后继结点。而如果查找当前结点的直接前驱结点，则需要从第一个元素开始遍历，操作比较烦琐。为此，可在每个结点中再加入一个指针域，用于存储前一个元素的地址，这样便可以方便地得到直接前驱元素。这种链表中有两条方向相反的链，因此称为双向链表（doublelinked list），简称双链表（下图展示的是双向循环链表，因为实际应用中使用循环链表便于直接访问尾结点）</p>
<p><img src="/images/image-20230714221652744.png" srcset="/img/loading.gif" lazyload alt="双循环链表"></p>
<blockquote>
<p>无论是循环单链表还是循环双链表都没有空指针域（带头结点的情况下），因此单循环链表判空的条件是头结点的next指针是否等于头指针，双循环链表的判空条件是头结点的prior和next都等于头指针；</p>
</blockquote>
<h3 id="1-3-顺序表VS-链表"><a href="#1-3-顺序表VS-链表" class="headerlink" title="1.3 顺序表VS.链表"></a>1.3 顺序表VS.链表</h3><table>
<thead>
<tr>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>既随机存取也可以顺序存取</td>
<td>只能顺序存取</td>
</tr>
<tr>
<td>插入操作需要移动多个元素（接近一半）</td>
<td>插入操作无需移动元素</td>
</tr>
<tr>
<td>静态分配（一次性分配，占用连续的存储空间）</td>
<td>动态分配（多次分配）</td>
</tr>
<tr>
<td>结点空间利用率较高（存储密度&#x3D;1）</td>
<td>结点空间利用率较低（存储密度&lt;1）</td>
</tr>
</tbody></table>
<p>$$<br>存储密度&#x3D;（结点数据域所占空间）&#x2F;结点结构所占空间<br>$$</p>
<p>线性表的两种常用存储结构：顺序表和链表（单链表、单循环链表、双链表、双向循环链表），下面主要关注其时间性能和空间性能</p>
<h4 id="1-3-1-时间性能"><a href="#1-3-1-时间性能" class="headerlink" title="1.3.1 时间性能"></a>1.3.1 时间性能</h4><p>顺序表是由C++实现的，因此是一种随机存取结构，对表中任意结点进行存取操作的时间复杂度为O（1）。而查找链表中的结点，需要从头指针起顺着链扫描，平均时间复杂度为O（n）。因此，若线性表的主要操作是进行查找，而很少进行插入或删除操作，则采用顺序表比较合适。</p>
<p>对于链表，在某个位置上进行插入和删除操作，只需要修改指针即可，无须移动大量元素，操作的时间复杂度为0（1）。而在顺序表中进行插入和删除操作，往往要移动大量元素，平均移动元素的数目为表长的一半，平均时间复杂度为0（n）。因此，若对线性表进行频繁的插入和删除操作时，采用链表相对合适。若插入和删除主要发生在表头和表尾，则采用循环链表更为方便。</p>
<h4 id="1-3-2-空间性能"><a href="#1-3-2-空间性能" class="headerlink" title="1.3.2 空间性能"></a>1.3.2 空间性能</h4><p>顺序表的存储空间是静态分配的，因此必须提前确定其存储大小。若线性表的长度变化较大，则存储规模应按最大长度来确定，否则会出现溢出的情况。但如果大量空间只是偶尔才会使用到，则势必会造成空间的浪费。因此顺序表常常用于存储规模比较容易确定的线性表。</p>
<p>动态链表的存储空间是动态分配的，因此只要内存空间还有空闲就不会出现溢出的情况。因此，对于长度变化较大或长度难以估计的线性表，应采用动态链表作为存储结构。</p>
<p>另外，顺序表在存储时，利用了数组元素之间的相对位置来表示结点间的逻辑次序，因此没有使用额外的存储空间。而对于链表，除了存储当前结点的数据外，还需要额外的存储空间保存下一个结点的位置，以维护结点间的逻辑关系。换句话说，顺序表的存储密度(为1)大于链表的存储密度(小于1)</p>
<h2 id="2-顺序表详解"><a href="#2-顺序表详解" class="headerlink" title="2.顺序表详解"></a>2.顺序表详解</h2><h3 id="2-1-类声明"><a href="#2-1-类声明" class="headerlink" title="2.1 类声明"></a>2.1 类声明</h3><p>顺序表中的数据元素可以是任意类型的，因此使用C++的<a href="https://gintoki-jpg.github.io/2022/07/08/CPP_STL%E5%88%9D%E7%BA%A7/#1-%E6%A8%A1%E6%9D%BF">模板机制</a>来定义顺序表。下面给出C++描述的顺序表模板类声明（可以根据实际的需要进行修改和补充）</p>
<p><img src="/images/image-20230715192422003.png" srcset="/img/loading.gif" lazyload alt="顺序表模板类"></p>
<hr>
<blockquote>
<p>Q：类模板和类的区别是什么？</p>
</blockquote>
<p>A：类是一种具体的对象定义，而类模板是一种通用的类定义，可以通过提供类型参数来特化为具体的类。类模板提供了更高的灵活性和代码复用性，但使用时需要指定类型参数。类和类模板的区别主要可以从如下几方面入手</p>
<ul>
<li><p>定义和使用方式</p>
<ul>
<li><p>类是一种定义对象行为和属性的蓝图，可以用来创建具体的对象实例。类通过定义成员变量和成员函数来描述对象的状态和行为。</p>
</li>
<li><p>类模板是一种通用的类定义，它允许使用占位符类型参数来定义类的成员变量和成员函数。</p>
</li>
</ul>
</li>
<li><p>泛化和特化</p>
<ul>
<li><p>类是一种具体的数据类型，用于创建特定类型的对象。类定义是具体的，不包含占位符类型。</p>
</li>
<li><p>类模板是一种泛化的定义，它可以通过提供实际类型参数来特化为具体的类。</p>
</li>
</ul>
</li>
<li><p>参数化</p>
<ul>
<li><p>类模板允许通过提供类型参数来参数化模板，从而在使用时指定类的实际类型。这样可以在编译时为每个类型参数生成对应的类定义，以适应不同类型的对象。</p>
</li>
<li><p>类没有这种参数化的能力，它是针对特定类型的定义。</p>
</li>
</ul>
</li>
<li><p>代码复用</p>
<ul>
<li>类模板可以在不同的上下文中重复使用，以适应不同的类型需求。通过提供不同的类型参数，可以使用相同的类模板定义来创建多个不同类型的类。</li>
<li>类没有这种重用性，每个类的定义是独立的，不支持基于参数的复用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-成员函数实现"><a href="#2-2-成员函数实现" class="headerlink" title="2.2 成员函数实现"></a>2.2 成员函数实现</h3><p>定义了顺序表的存储结构之后，就可以实现相应的各种基本运算（即实现SeqList类中声明的成员函数，类的成员函数的定义通常在类的外部进行）</p>
<h4 id="2-2-1-构造函数"><a href="#2-2-1-构造函数" class="headerlink" title="2.2.1 构造函数"></a>2.2.1 构造函数</h4><p>顺序表模板类中含有两个构造函数，其中无参构造函数用于建立空顺序表，实现比较简单，只需设置顺序表当前的长度为零，在类的定义中已经给出具体实现。</p>
<p>有参构造函数SeqList(const T a[]，int n)创建一个长度为n的顺序表，其数据元素依次来自参数数组a的各个元素，其长度为传入的参数n。需要注意的是，如果n超出了顺序表的最大长度，则应该抛出异常，终止操作。</p>
<p>有参构造函数实现如下</p>
<p><img src="/images/image-20230715193800924.png" srcset="/img/loading.gif" lazyload alt="有参构造函数"></p>
<h4 id="2-2-2-遍历顺序表"><a href="#2-2-2-遍历顺序表" class="headerlink" title="2.2.2 遍历顺序表"></a>2.2.2 遍历顺序表</h4><p>遍历顺序表是指按下标依次访问顺序表中的各个数据元素（这里的访问一般指的是显示数据元素data[i]的值）。因为数据元素的类型是不确定的，因此显示数据元素的值的操作可能不同，比如简单数据类型可以直接显示其数值，而对于一些构造类型则需要调用其相应的显示函数。</p>
<p>简单数据类型的遍历操作如下</p>
<p><img src="/./images/image-20230715195122732.png" srcset="/img/loading.gif" lazyload alt="简单数据类型遍历"></p>
<p>如果数据元素为构造类型如结构类型或类等复杂数据类型，则不能直接使用cout，需要调用相应的显示函数。</p>
<h4 id="2-2-3-插入操作"><a href="#2-2-3-插入操作" class="headerlink" title="2.2.3 插入操作"></a>2.2.3 插入操作</h4><p>插入操作是指在顺序表的第i（1≤i≤n+1）个位置上插入值为 x 的新元素。若在表尾追加，则不涉及表中已有元素的移动；如果在表头或中间某个位置i插入，则顺序表中原来序号从i到n的元素都要后移一个位置。最终顺序表的长度由n变为n+1</p>
<p><img src="/images/image-20230715195338981.png" srcset="/img/loading.gif" lazyload alt="在顺序表第i个位置上插入新元素x"></p>
<p>需要注意的是，数据元素在后移时，必须从最后一个元素开始移动，即先移动a<del>n</del>，到n+1位置，再移动a<del>n-1</del>到n位置，依次类推，直到将a<del>i</del>移动到i+1位置。</p>
<p>另外，对于一些操作不成功的特殊情况，需要抛出异常或返回错误号。例如，如果在插入之前顺序表已满，则抛出上溢异常；如果插入的位置不合理，则抛出位置异常。</p>
<p>(1)算法伪代码</p>
<p>插入操作的算法伪代码描述如下</p>
<p><img src="/images/image-20230715195926319.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)代码实现</p>
<p>插入操作的C++实现如下</p>
<p><img src="/images/image-20230715200000429.png" srcset="/img/loading.gif" lazyload alt="顺序表插入操作"></p>
<p>(3)复杂度分析</p>
<p>插入算法的问题规模是顺序表的长度 n，基本语句是for循环中元素后移的语句。</p>
<p>当插入的位置在表尾，即i&#x3D;n+1时，不执行元素后移操作，这是最好的情况，时间复杂度为0（1）；当插入的位置在表头，即i&#x3D;1时，所有元素都要进行后移操作，这是最坏的情况，时间复杂度为O（n）；当插入的位置在表的中间某一位置时，则要分析算法的平均时间复杂度。</p>
<p>设T(n)表示元素移动的平均次数，插入位置为i（1≤i≤n+1），元素的移动次数为n-i+1。因此有</p>
<p><img src="/images/image-20230715200342818.png" srcset="/img/loading.gif" lazyload></p>
<p>其中p<del>i</del>表示在顺序表第i个位置插入新元素的概率。假如在任意位置进行插入操作的概率相同都是1&#x2F;(n+1)，因此有</p>
<p><img src="/images/image-20230715200530247.png" srcset="/img/loading.gif" lazyload></p>
<p>上述式子的意义为，对顺序表进行插入操作，在等概率的情况下平均要移动表中一半的元素，算法的平均复杂度为O(n)</p>
<h4 id="2-2-4-删除操作"><a href="#2-2-4-删除操作" class="headerlink" title="2.2.4 删除操作"></a>2.2.4 删除操作</h4><p>删除操作是指把顺序表的第i（1≤i≤n）个位置上的元素删除，<code>并把删除的元素返回</code>。若删除表尾元素，则不涉及原来元素的移动；如果要删除表头或中间某个位置i上的元素，则顺序表中原来序号从 i+1 到 n 的元素都要向前移动一个位置。最终顺序表的长度由 n 变为 n-1</p>
<p><img src="/images/image-20230715200908271.png" srcset="/img/loading.gif" lazyload alt="删除顺序表第i个位置上的元素"></p>
<p>与插入操作相反，数据元素在前移时，必须从第i+1 个位置开始移动，即先移动a<del>i+1</del>到i位置，再移动a<del>i+2</del>到i+1位置，依次类推，直到将最后一个元素a<del>n</del>，移动到n-1位置。类似于插入运算，对于操作不成功的特殊情况需要抛出异常或返回错误号。例如，如果在删除操作之前顺序表已经为空表，则抛出下溢异常；如果删除的位置不合理，则抛出位置异常。</p>
<p>(1)算法伪代码</p>
<p><img src="/images/image-20230715201105507.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)代码实现</p>
<p>删除操作的C++实现代码如下</p>
<p><img src="/images/image-20230715201229204.png" srcset="/img/loading.gif" lazyload></p>
<p>(3)复杂度分析</p>
<p>算法的问题规模是顺序表的长度n，基本语句是for循环中元素前移的语句。</p>
<p>当删除的位置在表尾，即i&#x3D;n时，不执行元素前移操作，这是最好的情况，时间复杂度为O（1）；当删除的位置在表头，即 i&#x3D;1时，其余所有 n-1 个元素都要进行前移操作，这是最坏的情况，时间复杂度为O（n）；当删除的位置在表的中间某一位置时，则要分析算法的平均时间复杂度。设T（n）表示元素移动的平均次数，删除位置为i（l≤i≤n），元素的移动次数为 n-i，因此有</p>
<p><img src="/images/image-20230715201445311.png" srcset="/img/loading.gif" lazyload></p>
<p>其中p<del>i</del>表示删除表中第i个位置上的元素的概率，假定各位置被删除的概率相同则对于任意的i有p<del>i</del>&#x3D;1&#x2F;n，因此有</p>
<p><img src="/images/image-20230715201554376.png" srcset="/img/loading.gif" lazyload></p>
<p>在顺序表上进行删除操作的等概率情况下，平均要移动表中一半的元素，算法的平均复杂度为O（n）。</p>
<h4 id="2-2-5-查找操作"><a href="#2-2-5-查找操作" class="headerlink" title="2.2.5 查找操作"></a>2.2.5 查找操作</h4><h5 id="1-按位查找"><a href="#1-按位查找" class="headerlink" title="(1)按位查找"></a>(1)按位查找</h5><p>按位查找是指查找顺序表中指定位置的数据元素。由于顺序表中采用数组存储数据元素，第i个数据元素对应的数组下标为i-1，所以其算法实现比较简单。</p>
<p><img src="/images/image-20230715201704732.png" srcset="/img/loading.gif" lazyload alt="按位查找"></p>
<p>按位查找的时间复杂度为O(1)</p>
<h5 id="2-按值查找"><a href="#2-按值查找" class="headerlink" title="(2)按值查找"></a>(2)按值查找</h5><p>按值查找是指查找顺序表中指定数值的数据元素。在实现时需要依次比较顺序表中的每个数据元素，直到找到指定数值的数据元素或遍历完整顺序表都没有找到。如果没有找到，称为查找不成功，返回查找失败错误号，如“0”。算法实现如下。</p>
<p><img src="/images/image-20230715202120590.png" srcset="/img/loading.gif" lazyload alt="按值查找"></p>
<p>该算法需要注意的是进行值比较的语句<code>data[i]==x</code>，由于比较的数据类型是参数化类型T，具体类型不确定，对于简单类型，可以直接进行比较；对于复杂类型，如自定义类，则需要在自定义类中对“&#x3D;&#x3D;”进行运算符重载。</p>
<p>该算法的时间复杂度分析方法同前面的插入操作或删除操作</p>
<ul>
<li><p>对于查找成功的情况，最好的情况是比较第一个数据元素时就找到，时间复杂度为O（1）。最坏的情况是遍历到最后一个数据元素时才找到，此时的时间复杂度为O（n）。而平均情况下，假定要查找的元素存在，且其位置是等概率分布的，则平均要比较（n+1）&#x2F;2个元素。因此，按值查找算法查找成功的平均时间复杂度为O（n）。</p>
</li>
<li><p>对于查找不成功的情况，需要循环n次，因此按值查找算法查找不成功的最好、最坏和平均时间复杂度均为O（n）。</p>
</li>
</ul>
<h3 id="2-3-顺序表的优缺点"><a href="#2-3-顺序表的优缺点" class="headerlink" title="2.3 顺序表的优缺点"></a>2.3 顺序表的优缺点</h3><p>顺序表利用物理位置上的相邻关系来表示数据元素之间的逻辑关系，这一特点导致顺序表这种存储结构具有如下优缺点，顺序表的优点是：</p>
<ul>
<li>不需要为表示元素之间的逻辑关系而增加额外的存储空间。</li>
<li>可以方便地随机访问顺序表中任一位置的元素。</li>
</ul>
<p>顺序表的缺点如下：</p>
<ul>
<li>插入和删除操作需移动大量的数据元素，效率较低。在等概率条件下，两种操作平均需要移动顺序表中约一半的元素。</li>
<li>顺序表难以选择合适的存储容量。顺序表要求占用连续的存储空间，存储分配只能预先进行，因此属于静态存储分配方式。若开始时分配的空间过小，则插入操作很容易引起顺序表的溢出；若分配的空间过大，则可能造成一部分空间长期闲置，不能被充分利用。</li>
</ul>
<h2 id="3-单链表详解"><a href="#3-单链表详解" class="headerlink" title="3.单链表详解"></a>3.单链表详解</h2><p>为了克服顺序表的缺点，可以采用链式（或称为链接）存储方式存储线性表。最简单的链式存储方式就是单链表（single linked list），这种方法采用动态存储分配方式，即程序在运行时根据实际需要随时申请内存，在不需要时将申请的内存释放。</p>
<h3 id="3-1-类声明"><a href="#3-1-类声明" class="headerlink" title="3.1 类声明"></a>3.1 类声明</h3><p>单链表由一个一个结点通过结点的指针（pointer）或链（link）按照元素逻辑顺序链接而成，因此，单链表的每一个结点（node）都由数据域（data）和指针域（next）两部分构成。data域用于存储元素的值；next域用来存储直接后继的地址或位置。</p>
<p><img src="/images/image-20230716204106948.png" srcset="/img/loading.gif" lazyload alt="结点结构"></p>
<p>因为节点的数据类型是不确定的，所以采用C++的模板机制使用结构类型或类描述单链表的节点，下面是使用结构类型的定义</p>
<p><img src="/images/image-20230716204216279.png" srcset="/img/loading.gif" lazyload alt="单链表结点结构"></p>
<p>单链表除第一个结点外，其他每个结点的地址都存储在前一个结点的next域中，因此，只要取得第一个结点的地址，就可以顺序遍历单链表的所有结点，因此头指针具有标识一个单链表的作用。</p>
<p>带头结点的链表可以统一处理对非空单链表中的任意结点的操作（尤其是开始结点结点，注意开始结点和头结点是不同的），使得单链表的很多操作实现起来更加方便。因此之后再不特殊说明的情况下都默认链表带头结点，头结点的地址保存在头指针中</p>
<p><img src="/images/image-20230716204929370.png" srcset="/img/loading.gif" lazyload alt="带头结点的单链表"></p>
<p>下面给出使用C++描述的单链表模板类。在单链表的模板类中节点类型Node在上面已经用结构类型给出，私有成员为front头指针，用于存储头结点的地址</p>
<p><img src="/images/image-20230716205043279.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<blockquote>
<p>Q：关于头指针，头结点和开始结点概念辨析</p>
</blockquote>
<p>A：</p>
<ul>
<li>带头结点的单链表中有一个结点不存储信息(或只存储一些描述链表属性的信息如表长)，不带头结点的单链表中的所有结点都存储信息；</li>
<li>头指针是标识一个链表是否存在的标志，这意味着无论链表是否为空只要存在头指针就一定存在；</li>
<li>无论链表是否带头结点，头指针指向的都是链表中的第一个结点（要么是头结点(带头结点的链表)要么是开始节点(不带头结点的链表)）</li>
</ul>
<hr>
<h3 id="3-2-成员函数实现"><a href="#3-2-成员函数实现" class="headerlink" title="3.2 成员函数实现"></a>3.2 成员函数实现</h3><h4 id="3-2-1-构造函数"><a href="#3-2-1-构造函数" class="headerlink" title="3.2.1 构造函数"></a>3.2.1 构造函数</h4><p>如果建立空单链表，则只需建立头结点，在单链表模板类中已经给出了无参构造函数的实现。有参构造函数LinkList（T a[]，int n）使用长度为 n的数组a 来初始化单链表，一般来说建立单链表的方法有两种，分别为头插法和尾插法。</p>
<h5 id="1-头插法"><a href="#1-头插法" class="headerlink" title="(1)头插法"></a>(1)头插法</h5><p>采用头插法建立单链表是指每次插入元素都从单链表的开始结点位置(如果从头结点开始插的话会导致头结点移动而不再是头结点)插入，先前插入的结点随着新结点的插入而不断后移。因此，若希望数组a中的各个元素插入后在单链表后的次序依然为a[0]，a[1]，…，a[n-1]，则插入时应先插入a[n-1]，再插入a[n-2]，依次类推最后插入a[0]。</p>
<p>头插法的执行过程如下所示（a是插入第一个结点，b表示插入其他结点，而无论是哪种情况操作的步骤都是一样的，体现了带头结点的单链表的简便性）</p>
<p><img src="/images/image-20230716205535933.png" srcset="/img/loading.gif" lazyload alt="头插法示意图"></p>
<p>对应上述图像有如下执行流程，需要注意的是步骤3必须在步骤4之前执行</p>
<p><img src="/images/image-20230716205642359.png" srcset="/img/loading.gif" lazyload alt="头插法执行流程"></p>
<p>下面给出利用头插法建立单链表的算法，算法的时间复杂度为O(n)</p>
<p><img src="/images/image-20230716205911958.png" srcset="/img/loading.gif" lazyload alt="头插法建立单链表"></p>
<h5 id="2-尾插法"><a href="#2-尾插法" class="headerlink" title="(2)尾插法"></a>(2)尾插法</h5><p>尾插法是指每次新插入的元素都在单链表的表尾。通常尾插法需要一个指针变量保存终端结点的地址，称为尾指针，设为r。每插入一个结点后，r指向新插入的终端结点。</p>
<p>尾插法的执行流程如下所示</p>
<p><img src="/images/image-20230716210020178.png" srcset="/img/loading.gif" lazyload></p>
<p>对应上述图像有如下执行流程，每个新结点的插入都可以分为四个步骤</p>
<p><img src="/images/image-20230716210123334.png" srcset="/img/loading.gif" lazyload></p>
<p>利用尾插法建立单链表的算法如下所示，算法的时间复杂度为O(n)</p>
<p><img src="/images/image-20230716210304424.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-2-2-析构函数"><a href="#3-2-2-析构函数" class="headerlink" title="3.2.2 析构函数"></a>3.2.2 析构函数</h4><p>单链表的各个结点都是采用操作符new动态申请的，在单链表对象生命期结束时，需要将这些结点释放，这就是析构函数要做的事情。下面给出具体算法。</p>
<p><img src="/images/image-20230716211655967.png" srcset="/img/loading.gif" lazyload alt="析构函数"></p>
<p>若链表长度为n，则包括头结点在内需要进行n+1次循环释放结点空间，所以析构函数的时间复杂度为O（n）。</p>
<h4 id="3-2-3-查找算法"><a href="#3-2-3-查找算法" class="headerlink" title="3.2.3 查找算法"></a>3.2.3 查找算法</h4><h5 id="1-按位查找-1"><a href="#1-按位查找-1" class="headerlink" title="(1)按位查找"></a>(1)按位查找</h5><p>顺序表采用数组存储，是一种随机存取的存储方式，即通过索引可以快速访问表中的任意元素。而链表是一种顺序存储方式，只能从链表的表头出发，顺着每个结点的指针域往后依次搜索访问每个结点。</p>
<p>设单链表的长度为 n，要查找表中的第i个元素，则i应满足1≤&lt;n。设工作指针为p，当开始查找时 p 指向第一个结点，用整型变量j作计数器，初始时 j&#x3D;1。p 每指向下一个结点，j进行加1操作，直到j等于i，此时p指向的结点（有时简称p结点）就是所要找的结点；或者j不等于i但p已经为空，此时说明i是不合法的，算法可抛出异常或返回错误标识。</p>
<p>在实现时，可直接返回p，因为若p 为空，说明第i个元素不存在，返回空地址；否则，p 指向的元素就是所查找的元素，即返回元素地址。</p>
<p><img src="/images/image-20230716212259739.png" srcset="/img/loading.gif" lazyload alt="按位查找示意图"></p>
<p>(1)算法伪代码</p>
<p>按位查找的算法伪代码如下</p>
<p><img src="/images/image-20230716212339096.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)代码实现</p>
<p>根据上述伪代码，可以给出C++描述的具体算法如下</p>
<p><img src="/images/image-20230716212533799.png" srcset="/img/loading.gif" lazyload alt="按位查找"></p>
<p>(3)复杂度分析</p>
<p>算法中 p&#x3D;p-&gt;next是其中一条基本语句，该语句执行次数与被查找结点在单链表中的位置有关。在查找成功的情况下，查找位置i满足1≤i≤n，则基本语句执行次数为i-1，假定查找每个结点的概率相等（p<del>i</del>&#x3D;1&#x2F;n），则查找成功的平均时间复杂度为</p>
<p><img src="/images/image-20230716212635289.png" srcset="/img/loading.gif" lazyload></p>
<p>若查找不成功则需要执行基本语句n次，因此查找不成功的时间复杂度为</p>
<p><img src="/images/image-20230716212705925.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-按值查找-1"><a href="#2-按值查找-1" class="headerlink" title="(2)按值查找"></a>(2)按值查找</h5><p>按值查找是指在单链表中查找给定值的结点，找到后返回元素地址或序号。相对于按位查找，按值查找算法比较简单，下面直接给出按值查找算法的C++描述，在这里算法返回的是元素的序号。</p>
<p><img src="/images/image-20230716213514726.png" srcset="/img/loading.gif" lazyload alt="按值查找"></p>
<h4 id="3-2-4-插入操作"><a href="#3-2-4-插入操作" class="headerlink" title="3.2.4 插入操作"></a>3.2.4 插入操作</h4><blockquote>
<p>单链表的插入操作必须先找到其前驱结点的位置</p>
</blockquote>
<p>单链表的插入操作在这里定义为在单链表的第i个位置上插入值为 x 的元素。该操作可分为两个阶段，首先进行按位查找操作，即找到第i-1个位置的元素，然后在该元素后插入新元素。查找操作可直接调用按位查找Get函数，插入新元素的步骤在构造函数中已经进行了分析（即分别修改前后指针）。下面直接给出插入操作的C++算法。</p>
<p><img src="/images/image-20230716213822577.png" srcset="/img/loading.gif" lazyload alt="插入操作"></p>
<p>上述插入操作首先查找插入位置i的前一个元素，因此平均时间复杂度与按位查找的时间复杂度相同，为O（n）。</p>
<p>另外一种插入操作是在指定的元素之前或者之后进行插入，相应的插入函数并没有写入LinkList类中，可根据需要自行加入。因为操作比较简单故此处不再赘述。</p>
<h4 id="3-2-5-删除操作"><a href="#3-2-5-删除操作" class="headerlink" title="3.2.5 删除操作"></a>3.2.5 删除操作</h4><blockquote>
<p>与插入操作相同，单链表的删除操作必须知道其前驱结点的位置，对应的，要在某一结点后插入一个结点则必须知道这个结点的地址；</p>
</blockquote>
<p>删除操作是指删除线性表中的第i个元素，并将该元素的值返回。与插入操作类似，删除操作首先进行查找操作，找到第 i-1个元素，然后再将第i个元素删除。</p>
<p><img src="/images/image-20230716214123898.png" srcset="/img/loading.gif" lazyload alt="删除操作示意图"></p>
<p>对应的删除操作过程可以分为如下五个步骤</p>
<p><img src="/images/image-20230716214200391.png" srcset="/img/loading.gif" lazyload></p>
<p>对应的C++算法描述如下</p>
<p><img src="/images/image-20230716214240791.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-单循环链表详解"><a href="#4-单循环链表详解" class="headerlink" title="4.单循环链表详解"></a>4.单循环链表详解</h2><p>循环链表就是将链表首尾相连的链表，下面是两种不同的单循环链表</p>
<p><img src="/images/image-20230717211407781.png" srcset="/img/loading.gif" lazyload></p>
<p>用头指针 front 表示的单循环链表中，如果查找第一个元素，其地址为 front-&gt; next，时间复杂度显然为O（1），但如果查找最后一个元素，则时间复杂度为O（n）。但若是使用尾指针rear指向单循环链表的最后一个结点，如图（b）所示，这样，无论查找第一个元素（地址为 rear-&gt;next-&gt; next）还是最后一个元素（地址为 rear），时间复杂度都为O（1），从而简化操作。</p>
<p>带尾指针的单循环链表相对于单链表，存储结构并没有太多变化，只是改用指向终端结点的尾指针，并且尾结点&#x2F;最后一个结点的指针域指向头结点。其基本操作的实现与单链表类似，不同之处主要在于以下两点。</p>
<ul>
<li>头指针的表示：单链表使用 front 标识头指针，单循环链表使用 rear-&gt;next 标识头指针；</li>
<li>判断 p 指向的某结点是否为尾结点的方法：单链表中若 <code>p-&gt;next==NULL</code>，则 p 指向尾结点，而单循环链表中的判别条件应为<code>p==rear</code>；</li>
</ul>
<h3 id="4-1-类声明"><a href="#4-1-类声明" class="headerlink" title="4.1 类声明"></a>4.1 类声明</h3><p>下面仅给出单循环链表的类声明，具体各个成员函数的实现与单链表类似这里不再赘述</p>
<p><img src="/images/image-20230717212037348.png" srcset="/img/loading.gif" lazyload alt="单循环链表类声明"></p>
<h2 id="5-双循环链表详解"><a href="#5-双循环链表详解" class="headerlink" title="5.双循环链表详解"></a>5.双循环链表详解</h2><p>在[线性表的存储结构–双循环链表](# 1.2.4 双循环链表)中已经说明一般所使用的不是双向链表而是双循环链表，无论是双向链表还是双循环链表使用的结点结构如下</p>
<p><img src="/images/image-20230717213033636.png" srcset="/img/loading.gif" lazyload alt="双循环链表&amp;结点结构示意图"></p>
<p>有时候其结点结构中的两个指针域分别定义为left和right（一般地定义为prior和next）</p>
<p><img src="/images/image-20230717213148074.png" srcset="/img/loading.gif" lazyload alt="双向链表结点结构"></p>
<h3 id="5-1-基本操作"><a href="#5-1-基本操作" class="headerlink" title="5.1 基本操作"></a>5.1 基本操作</h3><p>关于双循环链表的类声明以及具体的成员函数实现这里不赘述。</p>
<p>对于双链表结构，通过当前结点可以方便地查找直接前驱和直接后继。设p指向当前结点，则 p-&gt;prior指向直接前驱，p-&gt;next指向直接后继，而p-&gt;prior-&gt;next&#x3D;p-&gt;next-&gt;prior&#x3D;p。下面仅讨论双向链表的插入和删除操作。</p>
<h4 id="5-1-1-插入操作"><a href="#5-1-1-插入操作" class="headerlink" title="5.1.1 插入操作"></a>5.1.1 插入操作</h4><p>在p结点后面插入一个新结点s示意图如下</p>
<p><img src="/images/image-20230717214132262.png" srcset="/img/loading.gif" lazyload alt="双链表的插入操作"></p>
<p>主要分为如下四个步骤，注意步骤2和3必须在步骤4前面</p>
<p><img src="/images/image-20230717214014961.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-1-2-删除操作"><a href="#5-1-2-删除操作" class="headerlink" title="5.1.2 删除操作"></a>5.1.2 删除操作</h4><p>将p结点的直接后继删除，操作过程如下</p>
<p><img src="/images/image-20230717214232599.png" srcset="/img/loading.gif" lazyload alt="双链表的删除操作"></p>
<p>需要注意的是，被删除结点必须在摘链前保存地址（即步骤1必须在步骤3之前），以备释放结点时使用。具体操作步骤如下</p>
<p><img src="/images/image-20230717214524540.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h2><p>前面介绍的链表都是利用C++指针来存储结点的地址，结点空间的分配和收回都是由操作符new和delete动态执行的，因此称之为动态链表（dynamic linked list）。对于某些高级语言，如BASIC、Java等，没有提供“指针”数据类型，因此多采用数组来描述单链表，用数组元素的下标来模拟链表的指针，一般称之为“游标”。这种用数组存储的链表结构，称为静态链表（static linked list）。</p>
<p>静态链表的每个数组元素同样由两个域构成：data 域存储数据元素，next 域存储直接后继元素的下标。整个链表元素通过 next 域链接起来，定义起始下标为 front，指向起始结点。对于数组中未使用的元素，为了便于将来分配给链表使用，也使用next域链接起来，定义起始下标为 tail。因此，静态链表实际上有两个链表，一个用于存储链表的各个元素，另一个存储所有未分配的数组元素，在这里称之为空闲链表。两个链表的终点结点的 next域都设为-1，表示链表结束。</p>
<p><img src="/images/image-20230717220003645.png" srcset="/img/loading.gif" lazyload alt="静态链表示意图"></p>
<blockquote>
<p>考点：</p>
<ul>
<li>一般链表结点的空间来自内存，而静态链表的结点空间来自一个结构体数组；</li>
<li>静态链表中的指针并不是C语言中的用来存储内存地址的指针型变量，而是一个存储数组下标的整型变量。因为通过它可以找到后继节点在数组中的位置，其功能类似真实的指针因此将其也称为指针；</li>
<li>静态链表中指针指示的是链表中下一元素在数组中的地址<ul>
<li>静态链表结点的指针域存储的是数组下标，指示的是下一个结点的位置，而非指示的数组下标；</li>
<li>静态链表中的指针表示的是下一个元素在数组中的位置，而不是下一个元素的地址；</li>
</ul>
</li>
<li>静态链表用数组表示因此需要分配较大的连续空间，而静态链表具有一般链表的优点即插入删除操作不需要移动元素</li>
</ul>
</blockquote>
<h3 id="6-1-类声明"><a href="#6-1-类声明" class="headerlink" title="6.1 类声明"></a>6.1 类声明</h3><p>下面直接给出静态链表的类声明</p>
<p><img src="/images/image-20230717220143427.png" srcset="/img/loading.gif" lazyload alt="静态链表类声明"></p>
<h3 id="6-2-成员函数实现"><a href="#6-2-成员函数实现" class="headerlink" title="6.2 成员函数实现"></a>6.2 成员函数实现</h3><p>下图是一个完整的静态链表操作示意图</p>
<p><img src="/images/image-20230717222349332.png" srcset="/img/loading.gif" lazyload></p>
<p>初始化时链表为空，front&#x3D;-1，tail指向空闲链的第一个元素，如图 2-26（a）所示。插入5 个元素后，front指向链表表头，链表最后一个元素的指针域设置为-1，tail指向空闲链新的起始元素，如图2-26（b）所示。图2-26（c）为删除元素as的示意图，下标为2的数组元素被回收到空闲链中，成为空闲链表的第一个空闲元素，其指针域指向原来的空闲链表头，tail指向新的空闲链表头。图2-26（d）为删除静态链表表头元素a的示意图，被删元素被回收为空闲链的第一个元素，同时 front 需要修改为指向静态链表新的表头元素。</p>
<p>下面仅介绍部分静态链表的算法。</p>
<h4 id="6-2-1-无参构造函数"><a href="#6-2-1-无参构造函数" class="headerlink" title="6.2.1 无参构造函数"></a>6.2.1 无参构造函数</h4><p>无参构造函数用于建立空静态链表。空静态链表的所有数组元素都没有分配，令tail为0，即存储第一个元素的下标，除最后一个数组元素外，空闲链中每个元素的next域存储下一个数值元素的下标，这样所有未分配空间就链接起来。同时令front 等于-1，表示为空静态链表。下图是建立空静态链表的示意图</p>
<p><img src="/images/image-20230717221635262.png" srcset="/img/loading.gif" lazyload alt="建立空静态链表"></p>
<p>对应的C++算法描述如下</p>
<p><img src="/images/image-20230717221735523.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-2-2-有参构造函数"><a href="#6-2-2-有参构造函数" class="headerlink" title="6.2.2 有参构造函数"></a>6.2.2 有参构造函数</h4><p>有参构造函数使用数组初始化静态链表。待所有数组元素添加到静态链表后，链表的最后一个元素的 next 域应设置为-1，同时 front 指向第一个数组元素，tail 指向第一个未分配的数组元素。</p>
<p><img src="/images/image-20230717221851278.png" srcset="/img/loading.gif" lazyload alt="初始化静态链表"></p>
<p>对应的C++算法描述如下</p>
<p><img src="/images/image-20230717221937404.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-2-3-申请结点"><a href="#6-2-3-申请结点" class="headerlink" title="6.2.3 申请结点"></a>6.2.3 申请结点</h4><p>由于静态链表采用下标来模拟指针，因此空间的申请和释放不能再使用new或delete这样的操作符来实现，而是要由程序员自己编写函数实现。</p>
<p>申请结点空间时，若还有未分配的数组元素，则将未分配数组元素链表中的第一个结点分配，同时 tail指向数组的下一个未分配元素。操作过程如下</p>
<p><img src="/images/image-20230717222053402.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-2-4-释放结点"><a href="#6-2-4-释放结点" class="headerlink" title="6.2.4 释放结点"></a>6.2.4 释放结点</h4><p>静态链表的结点若不再使用，则需要回收到未分配元素构成的空闲链表中。在具体实现时可直接将其作为表头插入空闲链表的起始位置。需要注意的是，如果要释放静态链表的第一个结点，则 front 需要重新指向下一个元素。算法描述如下</p>
<p><img src="/images/image-20230717222203137.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="第三章-线性表拓展"><a href="#第三章-线性表拓展" class="headerlink" title="第三章 线性表拓展"></a>第三章 线性表拓展</h1><p>第二章介绍了基本的线性表结构(逻辑结构)，本章将学习几种特殊类型的线性表 – 栈、队列、串以及多维数组（注意这几个概念同样也是逻辑结构）</p>
<ul>
<li>栈的插入和删除操作只能在表尾进行；队列的插入操作只能在表尾进行，删除操作只能在表头进行。因此，栈和队列被认为是操作受限的线性表。因而不是任何对线性表的操作都可以作为栈和队列的操作，比如不可以随便读取栈或队列中间的某个数据。</li>
<li>串是一种以字符作为数据元素的线性表，也称为字符串，是重要的非数值处理对象，在各种程序设计语言中，一般都有“串”的概念。</li>
<li>数组是有限个类型相同的变量的集合，而多维数组则是数组的扩展，多维数组在不同的程序设计语言中的实现方式各有不同。</li>
</ul>
<h2 id="1-拓展线性表概述"><a href="#1-拓展线性表概述" class="headerlink" title="1.拓展线性表概述"></a>1.拓展线性表概述</h2><h3 id="1-1-栈"><a href="#1-1-栈" class="headerlink" title="1.1 栈"></a>1.1 栈</h3><p>栈是限定仅在表尾进行插入和删除操作的线性表，主要有以下性质：</p>
<ul>
<li>把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何元素的栈称为空栈</li>
<li>栈对线性表的插入和删除的位置进行了限制，但是没有对元素进出的时间进行限制，即出栈可以随时进行，只要保证式栈顶元素出栈</li>
</ul>
<p><img src="/images/image-20230718200410287.png" srcset="/img/loading.gif" lazyload alt="栈示意图"></p>
<p>将元素插入栈中的操作称为入栈（或进栈）操作，元素入栈后就变成新的栈顶。将元素从栈中删除的操作称为出栈（或退栈）操作，出栈时被删除的总是原来的栈顶元素。因此，每次出栈的元素总是当前栈中“最新”的元素，即最后入栈的元素，而最先插入的元素被放到了栈底，待其他元素都已出栈，栈底元素才能被删除。栈的操作是按后进先出（LIFO，Last In First Out）原则进行的。</p>
<p>栈的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 栈（<span class="hljs-built_in">stack</span>）<br>Data <br>    元素具有相同类型，相邻元素具有前驱和后继的关系<br>Operation<br>    <span class="hljs-title function_">InitStack</span><span class="hljs-params">(*S)</span>:初始化栈，即建立一个空栈S<br>    <span class="hljs-title function_">DestroyStack</span><span class="hljs-params">(*S)</span>:若栈存在则销毁它<br>    <span class="hljs-title function_">ClearStack</span><span class="hljs-params">(*S)</span>:将栈清空<br>    <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(*S)</span>:若栈为空则返回1，否则返回0<br>    <span class="hljs-title function_">GetTop</span><span class="hljs-params">(S,*e)</span>:若栈存在且非空则用e返回S的栈顶元素<br>    <span class="hljs-title function_">Push</span><span class="hljs-params">(*S,e)</span>:若S存在，插入新元素e到S中使其成为栈顶元素<br>    <span class="hljs-title function_">Pop</span><span class="hljs-params">(*S,*e)</span>:删除S中的栈顶元素并用e返回它的值<br>    <span class="hljs-title function_">StackLength</span><span class="hljs-params">(S)</span>:返回栈S的元素个数<br>endADT<br></code></pre></td></tr></table></figure>

<h3 id="1-2-队列"><a href="#1-2-队列" class="headerlink" title="1.2 队列"></a>1.2 队列</h3><p>队列是指只允许在一端进行插入操作，而在另一端进行删除的线性表，主要有以下性质：</p>
<ul>
<li>队列是一种先进先出的线性表，允许插入的一端称为队尾，允许删除的一端称为队头</li>
</ul>
<p><img src="/images/image-20230718201605645.png" srcset="/img/loading.gif" lazyload alt="队列示意图"></p>
<p>队列是先进先出（FIFO，First In First Out）的线性表。无论入队操作或出队操作的先后时间如何，元素的入队序列和出队序列必然相同。</p>
<p>队列的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 队列（Queue）<br>Data <br>    元素具有相同类型，相邻元素具有前驱和后继关系<br>Operation<br>    <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(*Q)</span>:初始化操作，建立一个空队列<br>    <span class="hljs-title function_">DestroyQueue</span><span class="hljs-params">(*Q)</span>:若队列Q存在则销毁它<br>    <span class="hljs-title function_">ClearQueue</span><span class="hljs-params">(*Q)</span>:将队列Q清空<br>    <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(*Q)</span>:若队列为空则返回1否则返回0<br>    <span class="hljs-title function_">GetHead</span><span class="hljs-params">(Q,*e)</span>:若队列存在且非空，用e返回队列Q的队头元素<br>    <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(*Q,e)</span>:若队列Q存在，插入新元素e到队列Q中并使其成为队尾元素<br>    <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(*Q,*e)</span>:删除队列Q中的队头元素，并用e返回其值<br>    <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(Q)</span>:返回队列Q的元素个数<br>endADT<br></code></pre></td></tr></table></figure>

<blockquote>
<p>栈和队列的共同点是都只允许在端点处插入和删除元素，即都是限制存取点的线性结构</p>
</blockquote>
<h3 id="1-3-串"><a href="#1-3-串" class="headerlink" title="1.3 串"></a>1.3 串</h3><p>串是由零个和多个字符组成的有限序列，又称为字符串：</p>
<ul>
<li>一般将串记为s&#x3D;”a1a2a3…an”(n&gt;&#x3D;0)，其中s是串的名称，双引号括起来的字符序列是串的值，值可以是字母、数字或其他字符，i就是该字符在串中的位置，n称为串的长度</li>
<li>串的逻辑结构和线性表很相似，但是串中的元素都是字符（结点元素仅由一个字符构成的特殊线性表）。线性表更关注的是单个元素的操作，而串中更多的是针对子串（而不是单个字符）的操作</li>
<li>空格串（只包含空格的串）和空串（长度为0的串，不包含任何字符）不同</li>
</ul>
<p><img src="/images/image-20230718202015850.png" srcset="/img/loading.gif" lazyload alt="串的例子"></p>
<p>串的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 串（<span class="hljs-built_in">string</span>）<br>Data <br>    串中的元素仅由一个字符组成，相邻元素之间具有前驱和后继的关系<br>Operation<br>    <span class="hljs-title function_">StrAssign</span><span class="hljs-params">(T,*chars)</span>:生成一个值等于字符串常量chars的串T——这个地方指针的使用我不是很理解<br>    <span class="hljs-title function_">StrCopy</span><span class="hljs-params">(T,S)</span>:若串S存在，则将串S复制得到串T<br>    <span class="hljs-title function_">ClearString</span><span class="hljs-params">(S)</span>：若串S存在，则将S清空<br>    <span class="hljs-title function_">StringEmpty</span><span class="hljs-params">(S)</span>:若串S为空则返回1，否则返回0<br>    <span class="hljs-title function_">StrLength</span><span class="hljs-params">(S)</span>:返回串S的元素个数，即串的长度<br>    <span class="hljs-title function_">StrCompare</span><span class="hljs-params">(S,T)</span>:比较两个串的大小<br>    <span class="hljs-title function_">Concat</span><span class="hljs-params">(T,S1,S2)</span>：用T返回由S1和S2联接得到的新串<br>    <span class="hljs-title function_">SubString</span><span class="hljs-params">(Sub,S,pos,len)</span>:Sub返回串S的第pos个字符起长度为len的子串<br>    <span class="hljs-title function_">Index</span><span class="hljs-params">(S,T,pos)</span>:若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符后第一次出现的位置<br>    <span class="hljs-title function_">Replace</span><span class="hljs-params">(S,T,V)</span>:用V替换主串S中出现的所有与T相等的不重叠的子串<br>    <span class="hljs-title function_">StrInsert</span><span class="hljs-params">(S,pos,T)</span>:在串S的第pos个字符之前插入串T<br>    <span class="hljs-title function_">StrDelete</span><span class="hljs-params">(S,pos,len)</span>:从串S中删除第pos个字符起长度为len的子串<br>endADT<br></code></pre></td></tr></table></figure>

<h3 id="1-4-多维数组"><a href="#1-4-多维数组" class="headerlink" title="1.4 多维数组"></a>1.4 多维数组</h3><p>数组array是由n(n&gt;&#x3D;1)个类型相同的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。（注意这里的数组是一个逻辑结构，并不是前面C++程序设计语言中的数组基本数据类型）：</p>
<ul>
<li>一维数组是有序的元素序列，二维数组可以理解为数组元素是一维数组的数组，类推可以得到n维数组是每个元素均为n-1维数组的一维数组</li>
<li>多维数组通常用来存储结构比较复杂的相关联数据</li>
</ul>
<p><img src="/images/image-20230718202257394.png" srcset="/img/loading.gif" lazyload alt="一个m行n列的二维数组示意图"></p>
<p>数组一旦被定义，其维数和维界就不再改变，因此除了结构体的初始化和销毁外，数组只会进行存取元素和修改元素的操作（最常见的两种操作是查找和修改）。</p>
<p>一个基本的数组的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 数组（Array）<br>Data<br>    数组的元素类型定义为ElementType，假设数组元素的下标范围为[<span class="hljs-number">0</span>, MaxSize<span class="hljs-number">-1</span>]<br>    数组的实际长度定义为Length（表示数组中已存储的元素个数）<br>Operation<br>    <span class="hljs-title function_">InitArray</span><span class="hljs-params">(&amp;arr)</span>: 初始化一个空数组<br>    <span class="hljs-title function_">DestroyArray</span><span class="hljs-params">(&amp;arr)</span>: 销毁数组，释放相关内存空间<br>    <span class="hljs-title function_">GetLength</span><span class="hljs-params">(arr)</span>: 返回数组的实际长度<br>    <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">(arr)</span>: 判断数组是否为空，若为空则返回1，否则返回0<br>    <span class="hljs-title function_">ClearArray</span><span class="hljs-params">(&amp;arr)</span>: 将数组清空，将长度设置为0<br>    <span class="hljs-title function_">GetElement</span><span class="hljs-params">(arr, i)</span>: 返回数组中第i个元素的值<br>    <span class="hljs-title function_">SetElement</span><span class="hljs-params">(&amp;arr, i, e)</span>: 设置数组中第i个元素的值为e<br>    <span class="hljs-title function_">InsertElement</span><span class="hljs-params">(&amp;arr, i, e)</span>: 在数组的第i个位置插入元素e<br>    <span class="hljs-title function_">DeleteElement</span><span class="hljs-params">(&amp;arr, i)</span>: 删除数组中第i个位置的元素<br>    <span class="hljs-title function_">Traverse</span><span class="hljs-params">(arr, visit)</span>: 遍历数组的所有元素，依次调用visit函数进行访问<br>endADT<br></code></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>Q：前面不是说采用数组基本数据类型作为顺序表存储结构的底层实现，怎么这里又来了一个数组数据结构？这是否是”鸡生蛋，蛋生鸡“？</p>
</blockquote>
<p>A：这里的数组是一个逻辑结构，而不是数组基本数据类型，参考<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/181.html">什么是数组（数据结构），数组及其定义详解 </a>。之所以会产生上述混淆是因为大部分编程语言默认将数组作为基本数据类型直接实现了，所以会有人认为数组只是一个基本数据类型。换句话说，如果C++直接内置了队列、栈等基本数据类型，那么当需要使用C++实现一个队列或者栈的时候就不需要再像前面一样自定义类，而是直接使用即可。</p>
<p>数组和其他线性结构不同。顺序表、链表、栈和队列存储的都是不可再分的数据元素（如数字 5、字符 ‘a’ 等），而数组既可以用来存储不可再分的数据元素，也可以用来存储像顺序表、链表这样的数据结构。比如说，数组可以直接存储多个顺序表。我们知道，顺序表的底层实现还是数组，因此等价于数组中继续存储数组，这与平时使用的二维数组类似。</p>
<p>最重要的一点是，无论数组的维数是多少，数组中的数据类型都必须一致。</p>
<p>综上，可以认为一维数组是线性表(特指顺序表)的基本表现形式，n维数组是对线性表数据结构的一种拓展。</p>
<blockquote>
<p>Q：数组与线性表的关系？</p>
</blockquote>
<p>A：数组是线性表的推广，一维数组可以视为一个线性表，二维数组可以视为其数据元素为线性表的线性表。</p>
<hr>
<h3 id="1-5-广义表"><a href="#1-5-广义表" class="headerlink" title="1.5 广义表"></a>1.5 广义表</h3><p>广义表是指，表元素可以是原子或广义表的一种线性表的拓展结构。下面是一些广义表的例子</p>
<p><img src="/images/image-20230818153311764.png" srcset="/img/loading.gif" lazyload></p>
<p>考研题型中最常考察的是广义表的长度和深度求法，总结如下：</p>
<ul>
<li><p>广义表的长度：为表中最上层元素的个数，如广义表 C 的长度为 2，注意不是 3。</p>
</li>
<li><p>广义表的深度：为表中括号的<code>最大层数</code>。注意，求深度时需要将子表展开，如广义表D应该展开为（（d，e），（b，（c，d））），深度为 3。</p>
</li>
</ul>
<p>表头（Head）和表尾（Tail）：当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾。</p>
<h4 id="1-5-1-头尾链表存储结构"><a href="#1-5-1-头尾链表存储结构" class="headerlink" title="1.5.1 头尾链表存储结构"></a>1.5.1 头尾链表存储结构</h4><p>下图展示了例子中广义表的<code>头尾链表存储结构</code>的存储情况，其中有两种结点：原子结点和广义表结点。其中原子结点有两个域：标记域和数据域；广义表结点有三个域：标记域、头指针域和尾指针域。</p>
<p><img src="/images/image-20230818153730008.png" srcset="/img/loading.gif" lazyload></p>
<p>标记域用于区分当前节点是原子(0标记)还是广义表(1标记)，头指针域指向原子或广义表结点，尾指针域为空或指向本层中的下一个广义表结点</p>
<h4 id="1-5-2-拓展线性表存储结构"><a href="#1-5-2-拓展线性表存储结构" class="headerlink" title="1.5.2 拓展线性表存储结构"></a>1.5.2 拓展线性表存储结构</h4><p>下图展示了例子中广义表的<code>拓展线性表存储结构</code>的存储情况，其中也有两种结点，即原子结点和广义表结点，不同的是原子结点有3个域：标记域、数据域和尾指针域；广义表结点也有3个域：标记域、头指针域与尾指针域。</p>
<p><img src="/images/image-20230818154416559.png" srcset="/img/loading.gif" lazyload></p>
<p>其中，标记域用于区分当前结点是原子（用0来表示），还是广义表（用1来表示）。这种存储结构类似于带头结点的单链表存储结构（而上一种类似于不带头结点的单链表存储结构），每一个子表都有一个不存储信息的头结点来标记其存在。</p>
<h2 id="2-栈详解"><a href="#2-栈详解" class="headerlink" title="2.栈详解"></a>2.栈详解</h2><p>栈的数学性质：当n个不同的元素进栈，出栈元素不同的排列个数为</p>
<p><img src="/images/image-20230813200318538.png" srcset="/img/loading.gif" lazyload></p>
<p>上述公式称为卡特兰数，使用数学归纳法可证明，此处不再赘述</p>
<h3 id="2-1-顺序栈"><a href="#2-1-顺序栈" class="headerlink" title="2.1 顺序栈"></a>2.1 顺序栈</h3><p>栈的顺序存储结构简称为顺序栈。类似于顺序表，顺序栈也可以用C++数组来实现。由于栈底位置固定不变，因此可将栈底设置在数组两端的任意一端，通常把数组下标为0的一端作为栈底。同时设置栈顶指针top表示栈顶位置，当进行入栈操作时，top加1，当进行出栈操作时，top减1，栈的高度为top+1。当栈为空时，top&#x3D;-1。设数组的大小为StackSize，则当栈满时，top&#x3D;StackSize-1。下图说明了在顺序栈中进行入栈和出栈时，栈中元素和栈顶指针的变化。</p>
<p><img src="/images/image-20230718203435185.png" srcset="/img/loading.gif" lazyload alt="顺序栈操作示意图"></p>
<h4 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1 类声明"></a>2.1.1 类声明</h4><p>直接给出顺序栈的C++类声明</p>
<p><img src="/images/image-20230718203534373.png" srcset="/img/loading.gif" lazyload alt="顺序栈"></p>
<h4 id="2-1-2-成员函数实现"><a href="#2-1-2-成员函数实现" class="headerlink" title="2.1.2 成员函数实现"></a>2.1.2 成员函数实现</h4><p>顺序栈的基本操作相对简单，下面直接给出具体的C++实现，这些算法的时间复杂度均为O(1)</p>
<p><img src="/images/image-20230718203733743.png" srcset="/img/loading.gif" lazyload alt="顺序栈基本成员函数"></p>
<h3 id="2-2-链式栈"><a href="#2-2-链式栈" class="headerlink" title="2.2 链式栈"></a>2.2 链式栈</h3><p>栈的链式存储结构称为链栈，其实现原理类似于单链表，结点结构与单链表相同。由于插入和删除操作都在表头进行，因此链栈在实现时直接将栈顶指针指向栈顶元素，无须像单链表一样增加表头结点（头结点的存在本身是为了统一开始结点和其他结点上的操作的不同，但因为栈只会操作开始结点所以头结点失去存在的意义）。</p>
<p><img src="/images/image-20230718203910757.png" srcset="/img/loading.gif" lazyload alt="链式栈示意图"></p>
<blockquote>
<p>因为链栈在链表的头部进行操作，而链表插入和删除都需要找到开始结点的前驱节点，因此在没有头结点的情况下，只有表头指针没有表尾指针的循环单链表是不能快速找到开始结点的前驱结点的（时间复杂度为O(n)），因此不适合做链栈</p>
</blockquote>
<h4 id="2-2-1-类声明"><a href="#2-2-1-类声明" class="headerlink" title="2.2.1 类声明"></a>2.2.1 类声明</h4><p>下面给出链栈的C++模板类声明</p>
<p><img src="/images/image-20230718204107061.png" srcset="/img/loading.gif" lazyload alt="链栈"></p>
<h4 id="2-2-2-成员函数实现"><a href="#2-2-2-成员函数实现" class="headerlink" title="2.2.2 成员函数实现"></a>2.2.2 成员函数实现</h4><h5 id="1-入栈和出栈"><a href="#1-入栈和出栈" class="headerlink" title="(1)入栈和出栈"></a>(1)入栈和出栈</h5><p>由于栈是操作受限的线性表，因此链栈的基本操作可以看成是单链表操作的简化。链栈的入和出操作如下所示</p>
<p><img src="/images/image-20230718204153598.png" srcset="/img/loading.gif" lazyload alt="链栈的入栈和出栈"></p>
<p>下面直接给出链栈的入栈和出栈成员函数的C++实现</p>
<p><img src="/images/image-20230718204300653.png" srcset="/img/loading.gif" lazyload alt="入栈和出栈"></p>
<p>链栈的入栈和出栈操作时间复杂度均为O（1）</p>
<h5 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="(2)析构函数"></a>(2)析构函数</h5><p>链栈类的实例在生命期结束时，需要利用析构函数将所有链表中的结点释放</p>
<p><img src="/images/image-20230718204348787.png" srcset="/img/loading.gif" lazyload alt="析构函数"></p>
<p>析构函数的时间复杂度为O（n）</p>
<h3 id="2-3-共享栈"><a href="#2-3-共享栈" class="headerlink" title="2.3 共享栈"></a>2.3 共享栈</h3><p>利用栈底位置相对不变的特性，可让两个<code>顺序栈</code>共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图所示</p>
<p><img src="/images/image-20230813193717634.png" srcset="/img/loading.gif" lazyload></p>
<p>两个栈的栈顶指针都指向栈顶元素，top0&#x3D;-1时0号栈为空，top1&#x3D;MaxSize时1号栈为空；仅当两个栈顶指针相邻（top1-top0&#x3D;1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1 号栈进栈时 top1 先减 1 再赋值；出栈时则刚好相反。</p>
<p>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为 0（1），所以对存取效率没有什么影响。</p>
<h3 id="2-4-栈的应用"><a href="#2-4-栈的应用" class="headerlink" title="2.4 栈的应用"></a>2.4 栈的应用</h3><p>因为栈具有记忆当前状态的功能，因此栈常用于递归调用（调用自己）、子程序调用（调用其他函数）、表达式求值以及括号匹配等</p>
<h4 id="2-4-1-表达式转换-amp-求值"><a href="#2-4-1-表达式转换-amp-求值" class="headerlink" title="2.4.1 表达式转换&amp;求值"></a>2.4.1 表达式转换&amp;求值</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Amentos/article/details/127182926">《数据结构》：中缀表达式转后缀表达式 + 后缀表达式的计算_Amentos的博客-CSDN博客</a>；</p>
<ul>
<li><p>中缀表达式：操作符以中缀形式位于运算数中间（如：3+2），是我们日常通用的算术和逻辑公式表示方法。</p>
</li>
<li><p>后缀表达式：又称逆波兰式（Reverse Polish Notation - RPN），操作符以后缀形式位于两个运算数后（如：3+2的后缀表达形式就是3 2 +）。</p>
</li>
<li><p>前缀表达式：又称波兰式（Polish Notation），操作符以前缀形式位于两个运算数前（如：3+2的前缀表达形式就是+ 3 2）。</p>
</li>
</ul>
<p>中缀表达式往往需要使用括号将操作符和对应的操作数括起来，用于指示运算的次序。中缀表达式适合于人类的思维结构和运算习惯，但并不适用于计算机。尤其是包含括号的中缀表达式，对计算机而言是非常复杂的结构。与中缀表达式不同，后缀表达式不需要使用括号来标识操作符的优先级。后缀表达式的计算按操作符从左到右出现的顺序依次执行(不考虑运算符之间的优先级)，对于计算机而言是比较简单的结构。</p>
<p>下面介绍借助字符栈完成中缀表达式到后缀表达式的转换：从左至右依次遍历中缀表达式各个字符</p>
<ol>
<li>若字符为运算数：直接送入后缀表达式</li>
<li>若字符为左括号：直接入栈（左括号优先级最低）</li>
<li>若字符为右括号：直接出栈（不送入后缀表达式），并将出栈字符依次送入后缀表达式，直到栈顶字符为左括号（左括号也要出栈，但不送入后缀表达式）</li>
<li>若字符为操作符<ul>
<li>若栈空，直接入栈</li>
<li>若栈非空，判断栈顶操作符，若栈顶操作符优先级低于该操作符，该操作符入栈；否则一直出栈，并将出栈字符依次送入后缀表达式，直到栈空或栈顶操作符优先级低于该操作符，该操作符再入栈</li>
<li>总结：只要满足<code>栈空</code>或者<code>优先级高于栈顶操作符</code>即可将该操作符入栈，否则出栈直到满足条件之一</li>
</ul>
</li>
<li>重复以上步骤直至遍历完成中缀表达式，接着判断字符栈是否为空，非空则直接出栈，并将出栈字符依次送入后缀表达式</li>
</ol>
<p>而实际上我们在解题的时候这样进行会非常缓慢，下面举一个例子快速得到后缀表达式（作图法，依次根据运算顺序进行转换，该方法同样适用于得到前缀表达式，把每个部分的符号放在最前即可）</p>
<p><img src="/images/image-20230814201057711.png" srcset="/img/loading.gif" lazyload></p>
<p>得到后缀表达式之后，同样可以借助一个运算数栈来对其进行计算：从左至右依次遍历后缀表达式各个字符</p>
<ol>
<li>若字符为运算数：直接入栈</li>
<li>若字符为操作符：连续出栈两次，使用出栈的两个数据进行相应计算，并将计算结果入栈<ul>
<li>第一个出栈的运算数为 a ，第二个出栈的运算数为 b ，此时的操作符为 - ，则计算 <em>b-a</em> （注：a和b顺序不能反），并将结果入栈</li>
<li>运算先后顺序为：第二次出栈运算数  操作符  第一次出栈运算数</li>
</ul>
</li>
<li>重复以上步骤直至遍历完成后缀表达式，最后栈中的数据就是中缀表达式的计算结果</li>
</ol>
<p>关于表达式转换，其实不仅与栈相关，与树也密切关联（因此既可以使用上述作图也可以使用二叉树转换）</p>
<ul>
<li>中缀表达式实际是一棵以运算符为双分支结点，操作数为叶子叶子的二叉树中序遍历对应序列；</li>
<li>后缀表达式是对上述二叉树后序遍历的结果；</li>
<li>前缀表达式是对上述二叉树前序遍历的结果；</li>
</ul>
<blockquote>
<p>仅由中缀表达式并不能得出唯一的后缀表达式或前缀表达式！！！因为中缀表达式不能唯一确定一棵二叉树</p>
</blockquote>
<h2 id="3-队列详解"><a href="#3-队列详解" class="headerlink" title="3.队列详解"></a>3.队列详解</h2><h3 id="3-1-循环队列"><a href="#3-1-循环队列" class="headerlink" title="3.1 循环队列"></a>3.1 循环队列</h3><p>类似于顺序表，队列也可以采用顺序存储结构进行存储，即使用数组存储队列元素。由于队列的操作是在队列两端进行的，因此一般需要设置队头和队尾两个指针。对于空队列，队头和队尾均为-1，随着元素的入队，队尾不断后移。假定队头位置固定，不难发现当队头元素出队时，队列中的其他每个元素都需要向前移动一个单元，因此出队操作的时间复杂度为O（n）</p>
<p><img src="/images/image-20230718210251506.png" srcset="/img/loading.gif" lazyload alt="队头固定的队列的出队操作"></p>
<p>为了简化出队操作，可以允许队头指针改变，当队头元素出队时，其他元素不需要移动，而只需要将队头指针后移。但这也带来一个问题，由于元素出队时队头指针后移，出队元素所占用的空间就不能再使用了，这势必会导致存储队列的空间越来越小，直到无法使用。为了解决这个问题，通常采用循环队列实现顺序存储结构。</p>
<p><img src="/images/image-20230718210430257.png" srcset="/img/loading.gif" lazyload alt="队头可移动的队列的出队操作"></p>
<p>若将存储队列的数组看成是头尾相接的循环结构，则称之为循环队列。当队尾指针移动到数组最后时，数组前端的空间可能已经空闲。因此，如果再有元素进行入队操作，队尾指针可移动到数组最前面。</p>
<p><img src="/images/image-20230718210548153.png" srcset="/img/loading.gif" lazyload alt="循环队列操作示意图"></p>
<p>不难发现，上述循环队列中的队头指针位置的下一个元素才是真正的队头元素，队头指针指向的数组元素并非队列中的元素，因此没有意义。在此<code>规定队头指针所指位置永不存储队列元素</code>（通过不存储元素的位置来区分队列为空和队列为满）。当队列满时，其长度实际为数组长度减 1。下图展示了队列满时的几种情况。当队头和队尾指针指向同一位置时，队列为空队列。</p>
<p><img src="/images/image-20230718210742792.png" srcset="/img/loading.gif" lazyload alt="满队列示意图"></p>
<h4 id="3-1-1-类声明"><a href="#3-1-1-类声明" class="headerlink" title="3.1.1 类声明"></a>3.1.1 类声明</h4><p>下面给出循环队列的C++模板类声明</p>
<p><img src="/images/image-20230718211020289.png" srcset="/img/loading.gif" lazyload></p>
<p>在循环队列的模板类中，定义 data 数组作为存储空间，定义 front 和 rear 分别代表队列的队头指针和队尾指针。队列的头元素在队头指针的“下”一个位置，即（front+1）%QueueSize。队尾指针指向的就是队列的队尾元素。队列在初始化时为空队列，只要front和rear指向数组中任意的同一位置即可，在类的构造函数中可将其设置为0。</p>
<h4 id="3-1-2-成员函数实现"><a href="#3-1-2-成员函数实现" class="headerlink" title="3.1.2 成员函数实现"></a>3.1.2 成员函数实现</h4><h5 id="1-入队操作"><a href="#1-入队操作" class="headerlink" title="(1)入队操作"></a>(1)入队操作</h5><p>根据前面的分析，若队列不满，当有元素入队后，队尾指针移向“下”一个位置，即rear&#x3D;（rear+1）%QueueSize</p>
<p><img src="/images/image-20230718211234640.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-出队操作"><a href="#2-出队操作" class="headerlink" title="(2)出队操作"></a>(2)出队操作</h5><p>若队列为非空队列，则队头元素出队时，队头指针也要移向“下”一个位置，即front&#x3D;（front+1）%Queuesize</p>
<p><img src="/images/image-20230718211347820.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="3-查找队头元素"><a href="#3-查找队头元素" class="headerlink" title="(3)查找队头元素"></a>(3)查找队头元素</h5><p>查找队头元素的操作仅返回队头元素的值，不需要队头元素出队，因此队头指针保持不变，而队头元素的位置是队头指针的“下”一个位置，即（front+1）%Queuesize</p>
<p><img src="/images/image-20230718211548118.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="4-求队列长度"><a href="#4-求队列长度" class="headerlink" title="(4)求队列长度"></a>(4)求队列长度</h5><p>当队头指针小于等于队尾指针时，可得队列长度为队尾指针减去队头指针，即rear一front。</p>
<p>当队头指针大于队尾指针时，队列占据了数组的首尾两端，此时空闲区的长度为front一rear，因此队列长度为 rear-front+QueueSize，如下所示</p>
<p><img src="/images/image-20230718211653262.png" srcset="/img/loading.gif" lazyload alt="队头指针大于队尾指针"></p>
<p>将以上两种情况统一，则队列长度可表示为（rear-front+QueueSize）%QueueSize</p>
<p><img src="/images/image-20230718211724593.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-链队列"><a href="#3-2-链队列" class="headerlink" title="3.2 链队列"></a>3.2 链队列</h3><p>队列的链式存储结构称为链队列，因此链队列可看成仅在表头删除和表尾插入的单链表。</p>
<p>如果仅有单链表的头指针，不便于在表尾进行插入操作，因此通常会在表尾增加一个尾指针，指向最后一个结点。为了使空队列和非空队列的操作一致，多采用带有头结点的链队列。</p>
<p><img src="/images/image-20230718211826448.png" srcset="/img/loading.gif" lazyload alt="链队列示意图"></p>
<blockquote>
<ul>
<li>对于带头结点的链表来说，只带队尾指针（队尾指针指向终端结点）的循环单链表因为入队操作和出队操作的时间复杂度都为O(1)（入队从队尾入，出队从队头出，因为知道终端结点所以可以直接操作）</li>
<li>类似的分析，因为只带队首指针的非循环双链表在插入操作时需要O(n)的时间复杂度找到最后一个元素，因此不适合用于做链队列</li>
<li>用含头结点的单链表表示的链队的队头在链表的链尾（队列元素为1，此时既是队头也是队尾）或链中（队列元素大于1，因为头结点存在故队头在链表中间），队尾始终在链尾</li>
</ul>
</blockquote>
<h4 id="3-2-1-类声明"><a href="#3-2-1-类声明" class="headerlink" title="3.2.1 类声明"></a>3.2.1 类声明</h4><p>下面是链队列的C++模板类声明</p>
<p><img src="/images/image-20230718212651450.png" srcset="/img/loading.gif" lazyload></p>
<p>链队列类的构造函数将队列初始化为空队列，front 和 rear 都指向头结点。反之，当 front和rear都指向同一结点时，队列为空队列。</p>
<h4 id="3-2-2-成员函数实现"><a href="#3-2-2-成员函数实现" class="headerlink" title="3.2.2 成员函数实现"></a>3.2.2 成员函数实现</h4><h5 id="1-入队操作-1"><a href="#1-入队操作-1" class="headerlink" title="(1)入队操作"></a>(1)入队操作</h5><p>链队列的入队操作比较简单，在队尾元素后插入新结点并移动队尾指针</p>
<p><img src="/images/image-20230718212804639.png" srcset="/img/loading.gif" lazyload alt="入队操作示意图"></p>
<p>具体实现如下</p>
<p><img src="/images/image-20230718212831561.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-出队操作-1"><a href="#2-出队操作-1" class="headerlink" title="(2)出队操作"></a>(2)出队操作</h5><p>链队列的出队操作需要注意，当队列只有一个元素时，出队后rear指向的结点被释放，因此需要修改 rear队尾指针</p>
<p><img src="/images/image-20230718212943413.png" srcset="/img/loading.gif" lazyload alt="出队操作示意图"></p>
<p>(1)算法伪代码</p>
<p><img src="/images/image-20230718213014920.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)代码实现</p>
<p><img src="/images/image-20230718213040877.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="3-查找队头元素-1"><a href="#3-查找队头元素-1" class="headerlink" title="(3)查找队头元素"></a>(3)查找队头元素</h5><p><img src="/images/image-20230718213108071.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="4-析构函数"><a href="#4-析构函数" class="headerlink" title="(4)析构函数"></a>(4)析构函数</h5><p>析构函数完成链队列中所有结点的释放，具体实现如下</p>
<p><img src="/images/image-20230718213159246.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-3-双端队列"><a href="#3-3-双端队列" class="headerlink" title="3.3 双端队列"></a>3.3 双端队列</h3><p>双端队列是指允许两端都可以进行入队和出队操作的队列，如图所示</p>
<p><img src="/images/image-20230813194053522.png" srcset="/img/loading.gif" lazyload></p>
<p>其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。可以将双端队列看作栈底连在一起的两个栈，与共享栈不同之处在于双端队列的“栈顶指针”向两端延伸而不是向中间靠拢</p>
<p>在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。</p>
<p>还有一种概念是输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如图所示</p>
<p><img src="/images/image-20230813194409140.png" srcset="/img/loading.gif" lazyload></p>
<p>与此对应的，有输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为，输入受限的双端队列。</p>
<p>若限定双端队列从某个端点插入的元素只能从该端点删除（即输入输出均受限），则该双端队列就蜕变为两个栈底相邻接的栈。</p>
<h2 id="4-串详解"><a href="#4-串详解" class="headerlink" title="4.串详解"></a>4.串详解</h2><h3 id="4-1-串的存储结构"><a href="#4-1-串的存储结构" class="headerlink" title="4.1 串的存储结构"></a>4.1 串的存储结构</h3><p>串是一种结点元素仅由一个字符构成的线性表（即串的数据元素是单个字符而非多个字符），存储时既可以采用顺序存储结构，也可以采用链式存储结构。需要注意的是，串的操作往往将串作为一个整体来考虑，因此串在存储时还要考虑一些特殊技巧。</p>
<blockquote>
<p>长度为n(n!&#x3D;0)的串，其子串(包含空串也包含本身)数目为n(n+1)&#x2F;2+1</p>
<ul>
<li>长度为0的子串有1个</li>
<li>长度的1的子串有n个</li>
<li>长度为2的子串有n-1个</li>
<li>…</li>
<li>长度为n-1的子串有2个</li>
<li>长度为n的子串有1个</li>
</ul>
</blockquote>
<h4 id="4-1-1-顺序串"><a href="#4-1-1-顺序串" class="headerlink" title="4.1.1 顺序串"></a>4.1.1 顺序串</h4><p>串的顺序存储结构称为顺序串，可采用数组存储串中的字符序列。一般来说，串的顺序存储方式有多种，在此介绍两种最常用的方法。</p>
<p>第一种存储方法中，data数组存储字符串序列，length表示串的长度，可以使用顺序表的C++模板类<code>SqlList&lt;char&gt;</code>来实现</p>
<p><img src="/images/image-20230718215612086.png" srcset="/img/loading.gif" lazyload alt="串的顺序存储示意图"></p>
<p>另一种存储方法采用特殊字符作为串的结束标记，因而不需要额外的空间来存储串的长度。比如C和C++语言采用特殊字符”\0”作为串的结束标记</p>
<p><img src="/images/image-20230718220023038.png" srcset="/img/loading.gif" lazyload alt="串的顺序存储示意图"></p>
<h4 id="4-1-2-链串"><a href="#4-1-2-链串" class="headerlink" title="4.1.2 链串"></a>4.1.2 链串</h4><p>串的链式存储结构称为链串。链串具有同链表相同的结点结构，只是链串结点中的数据类型是字符类型。因此可直接使用链表的C++模板类<code>LinkList&lt;char&gt;</code>来实现链串。</p>
<p>下图是最简单的链串的存储示意图。该链串中的结点的数据类型为字符类型（如char只占1字节），而指针域通常占用4个字节，因此其存储密度只有20%空间利用率很低</p>
<p><img src="/images/image-20230718220646484.png" srcset="/img/loading.gif" lazyload alt="每个结点存储1个字符"></p>
<p>为了提高空间利用率可以对链串进行压缩存储，令每个结点存储多个字符</p>
<p><img src="/images/image-20230718220747748.png" srcset="/img/loading.gif" lazyload alt="每个结点存储4个字符"></p>
<p>实际应用中为了提高读写效率，每个结点不一定将存储空间全部填满。</p>
<h3 id="4-2-串的模式匹配"><a href="#4-2-串的模式匹配" class="headerlink" title="4.2 串的模式匹配*"></a>4.2 串的模式匹配*</h3><h4 id="4-2-1-朴素模式匹配算法"><a href="#4-2-1-朴素模式匹配算法" class="headerlink" title="4.2.1 朴素模式匹配算法"></a>4.2.1 朴素模式匹配算法</h4><p>朴素模式匹配算法又称为BF算法，其基本思想是将模式串T中的各个字符依次与目标串S进行比较，如果T的全部字符比较完成后都与S的对应字符相同，则说明在目标串 S 中已经找到模式串T。如果比较到某个字符不同后，则将模式串T 与目标串 S 的下一个字符重新进行比较。不妨设当前串 S 和串 T比较的字符下标分别为i和j(i和j都是从1开始而非0！！！)，下图给出了BF算法的示意图</p>
<p><img src="/images/image-20230720093144021.png" srcset="/img/loading.gif" lazyload alt="BF算法示意图"></p>
<p>BF算法中，当出现比较不成功则i需要回溯到本次起始位置的下一个位置，而j需要回溯到开始位置。假定本次的起始位置是主串的k位置，则有如下等式成立（即当前匹配的主串长度和当前匹配的子串长度相同）<br>$$<br>i-k&#x3D;j-1<br>$$<br>可以得到起始位置k的表达式为k+1-j，因此如果i需要进行回溯，应当回溯到i+2-j的位置；</p>
<p>(1)算法伪代码</p>
<p><img src="/images/image-20230720093237730.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)代码实现</p>
<p><img src="/images/image-20230720094059283.png" srcset="/img/loading.gif" lazyload></p>
<p>(3)时间复杂度</p>
<p>设<code>主串长度为 n，模式串长度为m</code>，下面通过字符的比较次数来分析算法的时间复杂度。</p>
<p>如果进行多趟匹配后匹配成功（这是大前提，此处没有分析第一轮就匹配成功和遍历到最后一轮发现匹配不成功的情况）</p>
<ul>
<li><p>最好的情况是每一趟匹配时比较的第一个字符不同，直到匹配成功，如在串”aaaaaaabc”中匹配模式”bc”</p>
<ul>
<li><p>设从主串的第i个位置开始匹配时(简称为第i趟匹配)，成功的概率为p<del>i</del>，其中i应满足1≤i≤n-m+1；</p>
</li>
<li><p>在前i-1 趟共有i-1 次字符比较均失败，第i趟匹配成功，共比较了 m 个字符，则匹配成功需要总的字符比较次数为 m+i-1；</p>
</li>
<li><p>假定从第 1 趟到第 n-m+1 趟，匹配成功是等概率的(也就是说从主串的第i个位置开始匹配的概率是相同的)，即p<del>i</del>&#x3D;1&#x2F;（n-m+1）；</p>
</li>
<li><p>则最好情况下匹配成功的平均比较次数为<br><img src="/images/image-20230720095414244.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>一般来说，n远大于m(主串长度远大于子串长度)，因此最好情况下的BF算法匹配成功的平均时间复杂度为O(n)</p>
</li>
</ul>
</li>
<li><p>最坏的情况是每一趟匹配比较到最后一个字符时两字符不同，如在串”aaaaaaab”中匹配模式”aab”</p>
<ul>
<li>设从主串的第i个位置开始匹配，即第i趟匹配时，成功的概率为p<del>i</del>，此时i应满足1≤i≤n-m+1；</li>
<li>在前i-1趟匹配时，每趟都是 m 次字符比较，只是比较最后一个字符时不同。第i趟匹配成功，也比较了m个字符。所以总的字符比较次数为m×i（匹配失败意味着此处的i&#x3D;n-m+1）；</li>
<li>假定从第1 趟到第 n-m+1趟，匹配成功是等概率的(也就是说从主串的第i个位置开始匹配的概率是相同的)，即p<del>i</del>&#x3D;1&#x2F;（n-m+1），则最坏情况下匹配成功的平均比较次数为<br><img src="/images/image-20230720100223172.png" srcset="/img/loading.gif" lazyload></li>
<li>因此最坏情况下的BF算法匹配成功的平均时间复杂度为O(nm)</li>
</ul>
</li>
</ul>
<p>BF算法的特点是匹配过程简单，易于理解，但是算法效率不高，其原因是每次匹配不成功，只能回溯到上次起始位置的下一个位置。实际上，很多回溯是不必要的，由此提出KMP改进算法。</p>
<h4 id="4-2-2-KMP模式匹配算法"><a href="#4-2-2-KMP模式匹配算法" class="headerlink" title="4.2.2 KMP模式匹配算法"></a>4.2.2 KMP模式匹配算法</h4><p>对于BF算法，每次匹配不成功时，模式串需要回溯到开头，主串需要回溯到上次起始位置的下一个位置。而如果事先对模式串进行分析，则<code>不需要回溯主串</code>，因为主串从上次起始位置到匹配不成功的前一个位置构成的子串一定是模式串的前缀子串，其信息通过事先对模式串的分析存储到next数组中，这就是KMP的基本思想。</p>
<h5 id="1-next数组构造"><a href="#1-next数组构造" class="headerlink" title="(1)next数组构造"></a>(1)next数组构造</h5><p>next数组的构造非常简单，利用口诀“前缀和后缀进行比较，如果前缀和后缀没有相同前缀，则为0+1，如果相同，则相同的字符个数+1”</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">序号<span class="hljs-keyword">j: </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>模式串s: a <span class="hljs-keyword">b </span>a <span class="hljs-keyword">b </span>a a a <span class="hljs-keyword">b </span>a <span class="hljs-keyword">b </span> a  a<br>next[]: <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><br> <span class="hljs-number">1</span>.next[<span class="hljs-number">1</span>],next[<span class="hljs-number">2</span>]无论是什么模式串数组，永远都是<span class="hljs-number">0</span>和<span class="hljs-number">1</span>。<br> <br> <span class="hljs-number">2</span>.next[<span class="hljs-number">3</span>]：如上，序号<span class="hljs-keyword">j[3]对应的模式串s[3]，那么我们就看模式串s[3]前面的字符即可，即为a </span><span class="hljs-keyword">b,那么s[3]的前缀为a,后缀为b,a和b不相同,则next[3]为0+1=1;</span><br><span class="hljs-keyword"></span> <br> <span class="hljs-number">3</span>.next[<span class="hljs-number">4</span>]:序号<span class="hljs-keyword">j[4]对应的s[4],找s[4]的前面字符，为a </span><span class="hljs-keyword">b </span>a,字符前缀为a、ab；后缀为<span class="hljs-keyword">ba, </span>a<span class="hljs-comment">;有1个相同字符，则next[4]=1+1=2;</span><br><br> <span class="hljs-number">4</span>.next[<span class="hljs-number">5</span>]:序号<span class="hljs-keyword">j[5]对应的s[5],找s[5]的前面字符，为a </span><span class="hljs-keyword">b </span>a <span class="hljs-keyword">b,字符前缀为a、ab、aba三个，后缀为bab、ab、b三个，进行比较，有字符串ab相同，则next[5]=2+1=3</span><br><span class="hljs-keyword"></span><br> 以此类推......<br><br> <span class="hljs-number">5</span>.next[<span class="hljs-number">12</span>]:序号<span class="hljs-keyword">j[12]对应的模式串字符为s[12],取前n-1个字符，为a </span><span class="hljs-keyword">b </span>a <span class="hljs-keyword">b </span>a a a <span class="hljs-keyword">b </span>a <span class="hljs-keyword">b </span>a,前缀为：ababaaabab、ababaaaba...后缀为<span class="hljs-keyword">babaaababa、abaaababa...可看出前缀中 </span>ababa与后缀中ababa5个字符相同，则next[<span class="hljs-number">12</span>]=<span class="hljs-number">5</span>+<span class="hljs-number">1</span>=<span class="hljs-number">6</span>;<br><br>最终生成的next字符串为<br><span class="hljs-keyword">j: </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>s: a <span class="hljs-keyword">b </span>a <span class="hljs-keyword">b </span>a a a <span class="hljs-keyword">b </span>a <span class="hljs-keyword">b </span> a  a<br><span class="hljs-symbol">next:</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>关于next数组的构造，这是一个小重点有必要掌握，参考链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64518217/article/details/127381285?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-127381285-blog-109466618.235%5Ev38%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-127381285-blog-109466618.235%5Ev38%5Epc_relevant_default_base3&utm_relevant_index=2">KMP算法中next数组与nextval如何求</a>进行刷题练习（一定要找有标准答案的题来练习，网上很多坑人的教程千万别随便学）；</p>
<p>下面给出next数组的构造函数</p>
<p><img src="/images/image-20230720111714594.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-nextval数组构造"><a href="#2-nextval数组构造" class="headerlink" title="(2)nextval数组构造"></a>(2)nextval数组构造</h5><p>nextval数组在北邮的官方教材中并没有用到，但是在其他参考资料中next数组和nextval是一起出现的所以这里做一个简单的补充</p>
<p>这里只介绍最简单的生成nextval数组的方法，nextval数组第一个字符永远为0。既然我们上面生成了next数组，nextval数组直接通过next数组便可生成</p>
<ul>
<li>若对应字符不同，直接填入next的值；</li>
<li>若对应字符相同，填入该值对应的序号的next的值</li>
</ul>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">  序号 :<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8<span class="hljs-number"> 9 </span>10<span class="hljs-number"> 11 </span>12<br>模式串s: a b a b a a a b a b  a  a<br> next[]:<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>4 <span class="hljs-number"> 5 </span> 6<br>nextval:<span class="hljs-number"> 0 </span><br><br>1.nextval[1]=0,默认值<br>2.nextval[2]：s[2]对应的next值为1，则以1为下标s[1]=a,与s[2b进行对比,不相同，则将s[2]对应的next值直接下发到nextval，nextval[2]=next[2]=1;<br>3.nextval[3]：s[3]对应的next值为1，则以1为下标，与s[3]=a进行对比，相同，则nextval[3]=nextval[1]=0;<br>4.nextval[4]：s[4]对应的next值为2,则以2为下标,与s[4]=b进行对比，相同，则nextval[4]=nextval[1]=0;<br>5.依次同理.....<br>6.nextval[12]:s[12]对应的next值为6，则s[6]=a与s[12]=a对比,相同，则nextval[12]=nextal[6]=4;<br><br>最终生成的nextval为：<br>  序号 :<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8<span class="hljs-number"> 9 </span>10<span class="hljs-number"> 11 </span>12<br>模式串s: a b a b a a a b a b  a  a<br> next[]:<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>4 <span class="hljs-number"> 5 </span> 6<br>nextval:<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>4<span class="hljs-number"> 2 </span>1<span class="hljs-number"> 0 </span>1 <span class="hljs-number"> 0 </span> 4<br><br></code></pre></td></tr></table></figure>

<h5 id="3-KMP算法"><a href="#3-KMP算法" class="headerlink" title="(3)KMP算法"></a>(3)KMP算法</h5><p>KMP的C++算法描述如下</p>
<p><img src="/images/image-20230720111752913.png" srcset="/img/loading.gif" lazyload></p>
<p>KMP 算法不需要对主串进行回溯，相对于 BF 算法做了很大的改进，算法的时间复杂度为O（m+n）。</p>
<p>尽管BF匹配的最坏时间复杂度为O(nm)，但在一般情况下其实际执行时间近似为O(m+n)，因此BF算法至今仍被采用。KMP算法仅仅只在主串与子串有大量“部分匹配”的特点时其执行时间才比BF算法快得多，其主要优点是主串不需要回溯，这意味着对于规模较大的外存中字符串的匹配操作可以分段进行，先读入内存一部分进行匹配，完成后写回外存，主串无需回溯确保了在发生不匹配时不需要将之前写回外存的部分再次读入，减少了I&#x2F;O操作提高执行效率。</p>
<h2 id="5-多维数组详解"><a href="#5-多维数组详解" class="headerlink" title="5.多维数组详解"></a>5.多维数组详解</h2><p>对于k维数组，每个元素都受到k个线性关系的约束，比如m行n列的二维数组</p>
<p><img src="/images/image-20230720160337200.png" srcset="/img/loading.gif" lazyload></p>
<p>其中每个元素均被两个线性关系约束：</p>
<ul>
<li><p>第j列上，除第一个结点外a<del>ij</del>的直接前驱为a<del>i-1,j</del>，除最后一个结点外a<del>ij</del>的直接后继为a<del>i+1,j</del>；</p>
</li>
<li><p>第j列上，除第一个结点外a<del>ij</del>的直接前驱为a<del>i,j-1</del>，除最后一个结点外a<del>ij</del>的直接后继为a<del>i,j+1</del>；</p>
</li>
</ul>
<blockquote>
<ul>
<li>矩阵、多维数组与广义表都属于拓展线性结构，表中的数据元素本身也是一个复合结构 – 一般讨论多维数组都以二维数组为例，同时以矩阵来称呼二维数组</li>
<li>考研数据结构中，矩阵的逻辑表示中第一个元素有的为a<del>0,0</del>，有的为a<del>1,1</del>（王道&#x2F;北邮和天勤的书写方式就不一样），解题时需要区分。而使用二维数组作为矩阵的存储结构，则二维数组的第一个元素基本都是<code>A[0][0]</code>(C语言中数组下标一定从0开始)。学习和解题时注意区分即可，数据结构的教辅和试题相当灵活没有统一性。</li>
</ul>
</blockquote>
<h3 id="5-1-一般数组的存储结构"><a href="#5-1-一般数组的存储结构" class="headerlink" title="5.1 一般数组的存储结构"></a>5.1 一般数组的存储结构</h3><p>大多数计算机语言都提供了数组数据类型，因此逻辑意义上的数组可以采用计算机语言中的数组数据类型进行存储，一个数组中的所有元素在内存中占用一段连续的存储空间。</p>
<p>由于计算机的内存结构都是一维的，因此在存储多维数组时，需要将数组中的所有元素按某种次序排成一个线性序列，然后将其按顺序存储到内存中。一般来说，数组不执行删除和插入操作，所以通常采用顺序存储方法来存储数组。多维数组通常有两种存储方式：行优先存储和列优先存储（这是书上的原话，很多学校的试题答案也是这样写的。然而对于三维除了行、列还有宽，因此其实这句话并不严谨。暂且认为书上研究多维数组都默认以二维数组作为研究对象）。下面将以二维数组(矩阵)为例说明这两种存储方式。</p>
<h4 id="5-1-1-行优先存储"><a href="#5-1-1-行优先存储" class="headerlink" title="5.1.1 行优先存储"></a>5.1.1 行优先存储</h4><p>基本思想是按行存储，即存储完第i行再接着存储第i+1 行。如存储二维数组 A<del>mn</del>，按行优先顺序存储的线性序列为</p>
<p><img src="/images/image-20230720161514439.png" srcset="/img/loading.gif" lazyload></p>
<p>二维数组以及其按行优先存储的示意图如下</p>
<p><img src="/images/image-20230720161910386.png" srcset="/img/loading.gif" lazyload></p>
<p>二维数组中任意一个元素a<del>ij</del>，其前面共有(i-1)*n+j-1个元素。设a<del>11</del>在内存中的地址为Loc(a<del>11</del>)，每个数组元素占c个存储单元，则a<del>ij</del>的地址为<br>$$<br>Loc(aij)&#x3D;Loc(a11)+[(i-1)*n+j-1]*c<br>$$</p>
<blockquote>
<p>在C++、PASCAL等语言中数组都是按行优先存储。以下讨论数组的存储结构时，均以C++语言的规范表示数组，数组中第一个元素各维的下标均为 0</p>
</blockquote>
<h4 id="5-1-2-列优先存储"><a href="#5-1-2-列优先存储" class="headerlink" title="5.1.2 列优先存储"></a>5.1.2 列优先存储</h4><p>基本思想是按列存储，即存储完第j列再接着存储第j+1列。如存储二维数组A<del>mn</del>，按列优先顺序存储的线性序列为</p>
<p><img src="/images/image-20230720165420621.png" srcset="/img/loading.gif" lazyload></p>
<p>二维数组以及其按列优先存储的示意图如下</p>
<p><img src="/images/image-20230720165445440.png" srcset="/img/loading.gif" lazyload></p>
<p>对于二维数组中的任意一个元素a<del>ij</del>，其前面共有i-1+m*(j-1)个元素。设a<del>11</del>在内存中的地址为Loc(a<del>11</del>)，每个元素占c个存储单元，则a<del>ij</del>的地址为<br>$$<br>Loc(aij)&#x3D;Loc(a11)+[i-1+m*(j-1)]*c<br>$$</p>
<blockquote>
<p>在FORTRAN语言中数组按列优先存储</p>
</blockquote>
<h3 id="5-2-稀疏矩阵的存储结构"><a href="#5-2-稀疏矩阵的存储结构" class="headerlink" title="5.2 稀疏矩阵的存储结构"></a>5.2 稀疏矩阵的存储结构</h3><p>当矩阵A<del>mn</del>中的非零元素个数远小于矩阵元素的总数时(具体什么叫远小于目前没有统一的定论)，称A<del>mn</del>为稀疏矩阵（稀疏矩阵被认为是一种具备特殊逻辑结构的多维数组）。在存储稀疏矩阵时，只需要存储非零元素即可。（严书对于稀疏矩阵的定义非常抽象，“相同元素或零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵”，这个定义知道就好，考研以北邮所给定义为准）</p>
<p>下面将介绍常见的稀疏矩阵的压缩方法（以下压缩方法都属于存储结构而非逻辑结构，专用于存储稀疏矩阵）：</p>
<ul>
<li>稀疏矩阵的顺序存储：三元组表示法、伪地址表示法</li>
<li>稀疏矩阵的链式存储：邻接表表示法、十字链表表示法</li>
</ul>
<h4 id="5-2-1-稀疏矩阵的顺序存储"><a href="#5-2-1-稀疏矩阵的顺序存储" class="headerlink" title="5.2.1 稀疏矩阵的顺序存储"></a>5.2.1 稀疏矩阵的顺序存储</h4><h5 id="1-三元组表示法"><a href="#1-三元组表示法" class="headerlink" title="(1)三元组表示法"></a>(1)三元组表示法</h5><p>将稀疏矩阵中每个非零元素的行号、列号及值构成一个三元组（3-tuples），将所有的三元组组成一个线性表进行顺序存储，就构成了三元组表。</p>
<p>使用C++实现的三元组结构如下</p>
<p><img src="/images/image-20230720170128135.png" srcset="/img/loading.gif" lazyload alt="三元组结构"></p>
<p>使用C++实现的三元组表模板结构如下</p>
<p><img src="/images/image-20230720170221057.png" srcset="/img/loading.gif" lazyload alt="三元组表"></p>
<p>下图展示了使用三元组表存储稀疏矩阵的示意图，一般按照行优先顺序遍历稀疏矩阵的每个非零元素，然后追加到三元组表中。所有三元组表的元素按行号有序，行号相同的元素按列号有序，这种特性称为三元组表的有序性。</p>
<p><img src="/images/image-20230720170755837.png" srcset="/img/loading.gif" lazyload></p>
<p>下面以矩阵的转置操作为例，说明采用三元组表存储结构如何实现矩阵的操作以及操作中可采用的一些技巧。</p>
<h6 id="a-稀疏矩阵的简单转置"><a href="#a-稀疏矩阵的简单转置" class="headerlink" title="a)稀疏矩阵的简单转置"></a>a)稀疏矩阵的简单转置</h6><p>对于 m 行n列的稀疏矩阵，转置后变为n行m 列的稀疏矩阵，但转置前后三元组表的结构并没有改变，而只是表中的各个三元组的行号和列号互换，并且次序发生了变化，以保证新表的有序性。一种简单的转置方法是遍历n趟三元组表(即遍历“列”趟三元组)，第一趟遍历找出列号为0的三元组，并将其行号和列号对调，添加到转置矩阵对应的三元组表中。第二趟遍历找出列号为1 的三元组并进行相同的操作，依次类推，最后一趟遍历找出列号为n-1的三元组。由于每趟遍历都需要比较所有的t个三元组的列号（其中t是稀疏矩阵非零元素的个数），因此算法的时间复杂度为O（nt）。</p>
<p>下图是将上面原始矩阵进行转置过后得到的结果</p>
<p><img src="/images/image-20230720171309195.png" srcset="/img/loading.gif" lazyload></p>
<p>稀疏矩阵简单转置算法的C++实现代码如下</p>
<p><img src="/images/image-20230720171400178.png" srcset="/img/loading.gif" lazyload></p>
<h6 id="b-稀疏矩阵的快速转置"><a href="#b-稀疏矩阵的快速转置" class="headerlink" title="b)稀疏矩阵的快速转置"></a>b)稀疏矩阵的快速转置</h6><p>上述稀疏矩阵的简单转置算法并不是最优的，下面给出一种快速的稀疏矩阵转置算法，其时间复杂度为 O（n+t）。</p>
<p>稀疏矩阵快速转置算法的基本思想是在原始三元组表（设为A）中依次取每个三元组，交换其行号和列号后，直接存放到转置矩阵的三元组表（设为B）中的适当位置。其中关键的问题是如何确定三元组在 B 中的位置。不难发现，A 中第 0 列的第一个非零元素一定存储在 B中下标为0 的位置上，该列中其他非零元素应存放在B[0]后面连续的位置上，那么第1列的第一个非零元素在 B 中的位置便等于第0列的第一个非零元素在 B 中的位置加上第 0 列的非零元素的个数，依次类推。因此引入两个数组作为辅助数据结构：</p>
<ul>
<li>number[n]：存储矩阵 A 中每列非零元素的个数；</li>
<li>position[n]：初始值表示矩阵 A 中每列的第一个非零元素在 B 中的位置；</li>
</ul>
<p>显然，number数组可以通过遍历一次三元组表A 得到。position数组可以通过number数组计算得到，计算公式如下：</p>
<p><img src="/images/image-20230720171709525.png" srcset="/img/loading.gif" lazyload></p>
<p>position[0]&#x3D;0 表示 A 中第 0 列的第一个非零元素一定存储在 B 中下标为 0 的位置上。position[i]&#x3D;position[i-1]+number[i-1]表示第 i 列的第一个非零元素在 B 中的位置等于第i-1 列的第一个非零元素在 B 中的位置加上第i-1列的非零元素的个数。可以参照下图理解</p>
<p><img src="/images/image-20230720171744819.png" srcset="/img/loading.gif" lazyload alt="number与position数组示例"></p>
<p>辅助数据结构 number与position数组确定后，接下来进行转置就非常简单了。顺序读取每一个三元组，得到列号col，则position[col]就是该元素在新三元组表中的位置，将行号和列号交换后写入新表，并将position[col]进行增1操作，这样同列的下一个元素依然可以根据position[col]确定其在新三元组表中的位置。</p>
<p>(1)算法伪代码</p>
<p><img src="/images/image-20230720172630675.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)代码实现</p>
<p><img src="/images/image-20230720172718636.png" srcset="/img/loading.gif" lazyload></p>
<p>(3)复杂度分析</p>
<p>稀疏矩阵快速转置算法中有 3 个循环操作，前两个操作各循环 n 次，第三个操作循环 t次，因此算法的时间复杂度为O（n+t），相对于时间复杂度为O（nt）的简单转置算法，这种算法效率更高。</p>
<h5 id="2-伪地址表示法"><a href="#2-伪地址表示法" class="headerlink" title="(2)伪地址表示法"></a>(2)伪地址表示法</h5><p>伪地址即元素在矩阵中按照行优先或列优先存储的相对位置。该方法存储稀疏矩阵与三元素类似，只是三元组每一行中有两个存储单元存放地址，而伪地址法只需要一个。故伪地址法每一行只需要两个存储单元，一个用来存放矩阵元素值，另一个用来存放伪地址。</p>
<p>伪地址表示法需要2N个存储单元，其中N为非零元素个数。对于一个m*n的稀疏矩阵A，元素<code>A[i][j]</code>的伪地址计算方法为n(i-1)+j。</p>
<h4 id="5-2-2-稀疏矩阵的链式存储"><a href="#5-2-2-稀疏矩阵的链式存储" class="headerlink" title="5.2.2 稀疏矩阵的链式存储"></a>5.2.2 稀疏矩阵的链式存储</h4><p>由于三元组表是一种顺序存储方式，对于经常进行插入或删除结点操作的稀疏矩阵，三元组表并不适合，此时采用链式存储结构存储这种矩阵更为恰当。链式存储结构存储稀疏矩阵的方法也有多种，最常用的是邻接表表示法和十字链表表示法。</p>
<h5 id="1-十字链表表示法"><a href="#1-十字链表表示法" class="headerlink" title="(1)十字链表表示法"></a>(1)十字链表表示法</h5><p>采用十字链表存储稀疏矩阵时，同三元组表一样，也是仅存储所有非零元素。同一行的非零元素构成一个带头结点的循环链表，同一列的非零元素也构成一个带头结点的循环链表。对于每个非零元素，采用一个五元组结点表示，五元组分别为非零元素的行号（row）、列号（col）、值（val）、同一行下一个非零元素的地址（rnext）、同一列下一个非零元素的地址（cnext）。下图是十字链表的结点结构示意图</p>
<p><img src="/images/image-20230720173036013.png" srcset="/img/loading.gif" lazyload></p>
<p>使用C++实现的十字链表的非零元素结点结构如下</p>
<p><img src="/images/image-20230720173122290.png" srcset="/img/loading.gif" lazyload></p>
<p>每行和每列构成的循环链表的头结点，可采用与非零元素结点相同的结构。每行头结点的 row 域表示本行的行号，而 col 域表示本行非零元素的个数。每列头结点的 col域表示本列的列号，而row域表示本列非零元素的个数，val域不使用。所有行的头结点又可以构成一个带头结点的循环链表，同理，所有列的头结点也可以构成一个带头结点的循环链表，两个链表可采用同一个头结点存储，该结点的 row 域和 col 域可用于表示矩阵的行数和列数。下图展示了采用十字链表存储稀疏矩阵的示意图</p>
<p><img src="/images/image-20230720173250122.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-邻接表表示法"><a href="#2-邻接表表示法" class="headerlink" title="(2)邻接表表示法"></a>(2)邻接表表示法</h5><p>邻接表表示法将矩阵中的每一行的非零元素串成一个链表，链表结点中有两个分量，分别表示该结点对应的元素值及其列号。</p>
<blockquote>
<p>这里的邻接表和图中的邻接表是同一个东西。图的邻接矩阵相当于这里的稀疏矩阵，图的邻接表相当于稀疏矩阵的邻接表表示（由此也可以发现图之所以使用邻接表也是出于一种节约空间的考量）。邻接表表示将在图的章节详细介绍。</p>
</blockquote>
<h3 id="5-3-特殊矩阵的存储结构"><a href="#5-3-特殊矩阵的存储结构" class="headerlink" title="5.3 特殊矩阵的存储结构"></a>5.3 特殊矩阵的存储结构</h3><p>压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间。</p>
<p>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。考研数据结构中主要涉及三种特殊矩阵：对称矩阵、三角矩阵以及对角矩阵。</p>
<p>特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。</p>
<h4 id="5-3-1-对称矩阵"><a href="#5-3-1-对称矩阵" class="headerlink" title="5.3.1 对称矩阵"></a>5.3.1 对称矩阵</h4><p>n阶矩阵中的元素可以分为三个部分：上三角区、主对角线和下三角区</p>
<p><img src="/images/image-20230818141134922.png" srcset="/img/loading.gif" lazyload></p>
<p>对一个n阶矩阵A中的任意一个元素a<del>i,j</del>都有a<del>ij</del>&#x3D;&#x3D;a<del>j,i</del>则称其为对称矩阵。因为对于n阶对称矩阵，其上三角区和下三角区的元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将n阶对称矩阵A存放在一维数组B[n（n+1）&#x2F;2]中，即元素a<del>i,j</del>存放在b<del>k</del>中。比如只存放下三角部分（含主对角）的元素。</p>
<p>元素a<del>i,j</del>与元素b<del>k</del>的下标对应关系如下（数组下标从0开始，下三角部分按行优先存储（下面与之类似，默认都是行优先存储））</p>
<p><img src="/images/image-20230818141614628.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-3-2-三角矩阵"><a href="#5-3-2-三角矩阵" class="headerlink" title="5.3.2 三角矩阵"></a>5.3.2 三角矩阵</h4><p>下三角矩阵中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，故可以将n阶下三角矩阵A压缩存储在 B[n（n+1）&#x2F;2+1]中。</p>
<p><img src="/images/image-20230818141947934.png" srcset="/img/loading.gif" lazyload></p>
<p>元素下标之间的对应关系如下（数组下标从0开始）</p>
<p><img src="/images/image-20230818142021056.png" srcset="/img/loading.gif" lazyload></p>
<p>下三角矩阵在内存中的压缩存储形式如下</p>
<p><img src="/images/image-20230818142102307.png" srcset="/img/loading.gif" lazyload></p>
<p>与之类似的，上三角矩阵中，下三角区的所有元素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在 B[n（n+1）&#x2F;2+1]中。</p>
<p><img src="/images/image-20230818142212148.png" srcset="/img/loading.gif" lazyload></p>
<p>元素下标之间的对应关系如下（数组下标从0开始）</p>
<p><img src="/images/image-20230818142246515.png" srcset="/img/loading.gif" lazyload></p>
<p>上三角矩阵在内存中的压缩存储形式如下</p>
<p><img src="/images/image-20230818142315400.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-3-3-对角矩阵"><a href="#5-3-3-对角矩阵" class="headerlink" title="5.3.3 对角矩阵"></a>5.3.3 对角矩阵</h4><p>对角矩阵也称带状矩阵。对于n阶矩阵A中的任意一个元素a<del>i,j</del>，当|i-j|&gt;1时，有a<del>i,j</del>&#x3D;0（1&lt;&#x3D;i，j&lt;&#x3D;n），则称为三对角矩阵。</p>
<p><img src="/images/image-20230818143152100.png" srcset="/img/loading.gif" lazyload></p>
<p>在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零（天勤规定的是均为c，其中c可以为0）。</p>
<p>三对角矩阵也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且a<del>1,1</del>存放于B[0]中，其存储形式如图所示。</p>
<p><img src="/images/image-20230818143250306.png" srcset="/img/loading.gif" lazyload></p>
<p>因此矩阵A中3条对角线上的元素a<del>i,j</del>在一维数组B中存放的下标为k&#x3D;2i+j-3。反之，若已知三对角矩阵中某元素a<del>i,j</del>存放在一维数组B中第k个位置，可得i&#x3D;向下取整[(k+1)&#x2F;3+1],j&#x3D;k-2i+3。</p>
<h1 id="第四章-树"><a href="#第四章-树" class="headerlink" title="第四章 树"></a>第四章 树</h1><p>树型结构是一类重要的<code>非线性</code>结构，其特点是结点之间有分支，并具有层次关系。树在计算机领域中有着广泛的应用，在源程序的编译中，用树来表示源程序的语法结构；在数据库系统中，可以用树来组织信息；在计算机信息存储或传输方式中，XML、DOM树、JSON数据、磁盘路径结构等也都是用树来组织信息的。</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-树概述"><a href="#1-1-树概述" class="headerlink" title="1.1 树概述"></a>1.1 树概述</h3><p>树是一种复杂的非线性数据结构，它是由 n(n≥1)个有限结点组成的一个具有层次关系的集合，把它叫作“树”是因为它看起来像一棵倒挂的树，也就是说树是根朝上，而叶朝下的，如下图所示</p>
<p><img src="/images/image-20230720212923053.png" srcset="/img/loading.gif" lazyload alt="树的示例"></p>
<blockquote>
<p>树的定义是递归的，即在树的定义中用到了树的定义</p>
</blockquote>
<p>树具有如下特点：</p>
<ul>
<li>每个结点有零个或多个子结点；</li>
<li>每个子结点只有一个父结点；</li>
<li>没有前驱的结点为根结点；</li>
<li>除了根结点外，每个子结点可以分为 m 个不相交的子树 T<del>1</del>…T<del>m</del>；</li>
</ul>
<p>树的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 树（tree）<br>Data <br>    树是由一个根节点和若干子树构成，树中结点具有相同的数据类型以及层次关系<br>Operation<br>    <span class="hljs-title function_">InitTree</span><span class="hljs-params">(*T)</span>:构造空树<br>    <span class="hljs-title function_">CreateTree</span><span class="hljs-params">(*T,definition)</span>:按照definition给出的树的定义来构造树<br>    <span class="hljs-title function_">Value</span><span class="hljs-params">(T,cur_e)</span>:cur_e是树T中的一个结点，返回此结点的值<br>    <span class="hljs-title function_">Assign</span><span class="hljs-params">(T,cur_e,value)</span>:给树T的结点cur_e赋值为value<br>    <span class="hljs-title function_">InsertChild</span><span class="hljs-params">(*T,*p,i,c)</span>:插入子树c作为树T中p指向的结点的第i棵子树，注意i只能是p的度+1<br>    <span class="hljs-title function_">DeleteChild</span><span class="hljs-params">(*T,*p,i)</span>:删除树T中p所指向的结点的第i棵子树，注意i只能是p的度<br></code></pre></td></tr></table></figure>

<p>为了方便描述树的特点，本章涉及的基本概念罗列如下：</p>
<ol>
<li>结点：结点不仅包含数据元素，通过是包含指向子树的分支（即同时含有数据域和指针域）</li>
<li>结点的度：一个结点含有的子树的个数称为该结点的度。</li>
<li>树的度：一棵树中，最大的结点的度称为树的度。</li>
<li>叶结点：度为零的结点称为叶结点或终端结点。</li>
<li>分支结点：度不为零的结点称为分支结点或非终端结点。</li>
<li>孩子结点：一个结点子树的根结点称为孩子结点。</li>
<li>双亲结点：在含有孩子的结点中，这个结点称为孩子结点的双亲结点或父结点（双亲结点并不是两个而是一个）。</li>
<li>兄弟结点：具有相同双亲结点的结点互称为兄弟结点。</li>
<li>祖先结点：从根到该结点所经分支上的所有结点。</li>
<li>子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙结点。</li>
<li>结点的层次：从根开始定义，根为第一层，根的孩子为第二层，如图所示</li>
</ol>
<p><img src="/images/image-20230720213132692.png" srcset="/img/loading.gif" lazyload alt="树的层次"></p>
<ol start="11">
<li><p>树的高度或深度：树中结点的最大层次。</p>
</li>
<li><p>结点的高度和深度：</p>
<ul>
<li>结点的深度是指从根结点到该结点路径上的结点个数（包含本身）</li>
<li>结点的高度是指从该结点到叶子结点的路径中最长的路径的结点个数（包含本身，根结点的高度就是树的高度）</li>
</ul>
</li>
<li><p>路径：两个结点之间的路径即连接这两个结点的边（树的路径是从上到下有向的）</p>
</li>
<li><p>路径长度：路径经过的边的个数，如图所示</p>
</li>
</ol>
<p><img src="/images/image-20230720213245781.png" srcset="/img/loading.gif" lazyload alt="结点的路径"></p>
<p>按照树中任意结点的子结点之间是否有顺序关系，可以把树分成无序树和有序树。有序树的任意结点的子结点相互交换顺序之后构成不同的树；反之，则是无序树。本章后续内容讨论的都是有序树。</p>
<p>树有如下常用结论（了解即可，相比二叉树的常用结论更重要</p>
<p><img src="/images/image-20230822202313506.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-2-二叉树概述"><a href="#1-2-二叉树概述" class="headerlink" title="1.2 二叉树概述"></a>1.2 二叉树概述</h3><p>二叉树是每个结点最多有两个子树的<code>有序树</code>，通常子树的根被称为“左子树”和“右子树”。因此，二叉树是一种最简单的树结构，特别适合计算机处理，而且任何树都可以简单地转化为二叉树，所以这也是本章的重点。</p>
<p><img src="/images/image-20230720214701376.png" srcset="/img/loading.gif" lazyload alt="二叉树示例"></p>
<p>可以参照树的ADT定义二叉树的ADT如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 二叉树（BinaryTree）<br>Data<br>    二叉树的结点具有相同的数据类型以及左右孩子关系<br>Operation<br>    <span class="hljs-title function_">InitBinaryTree</span><span class="hljs-params">(*BT)</span>: 构造空二叉树<br>    <span class="hljs-title function_">CreateBinaryTree</span><span class="hljs-params">(*BT, definition)</span>: 按照definition给出的二叉树的定义来构造二叉树<br>    <span class="hljs-title function_">DestroyBinaryTree</span><span class="hljs-params">(*BT)</span>: 销毁二叉树，释放内存<br>    <span class="hljs-title function_">IsEmptyBinaryTree</span><span class="hljs-params">(BT)</span>: 判断二叉树是否为空树，是则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>    <span class="hljs-title function_">Root</span><span class="hljs-params">(BT)</span>: 返回二叉树的根结点<br>    <span class="hljs-title function_">Parent</span><span class="hljs-params">(BT, cur_e)</span>: 返回二叉树中结点cur_e的双亲结点<br>    <span class="hljs-title function_">LeftChild</span><span class="hljs-params">(BT, cur_e)</span>: 返回二叉树中结点cur_e的左孩子结点<br>    <span class="hljs-title function_">RightChild</span><span class="hljs-params">(BT, cur_e)</span>: 返回二叉树中结点cur_e的右孩子结点<br>    <span class="hljs-title function_">InsertLeftChild</span><span class="hljs-params">(*BT, *p, value)</span>: 插入值为value的结点作为树BT中p指向的结点的左孩子<br>    <span class="hljs-title function_">InsertRightChild</span><span class="hljs-params">(*BT, *p, value)</span>: 插入值为value的结点作为树BT中p指向的结点的右孩子<br>    <span class="hljs-title function_">DeleteLeftChild</span><span class="hljs-params">(*BT, *p)</span>: 删除树BT中p所指向的结点的左子树<br>    <span class="hljs-title function_">DeleteRightChild</span><span class="hljs-params">(*BT, *p)</span>: 删除树BT中p所指向的结点的右子树<br>    <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BT, Visit)</span>: 前序遍历二叉树BT，并对每个结点调用函数Visit<br>    <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BT, Visit)</span>: 中序遍历二叉树BT，并对每个结点调用函数Visit<br>    <span class="hljs-title function_">PostOrderTraverse</span><span class="hljs-params">(BT, Visit)</span>: 后序遍历二叉树BT，并对每个结点调用函数Visit<br></code></pre></td></tr></table></figure>

<p>树和二叉树都是逻辑结构，主要区别如下：</p>
<ul>
<li>树的结点个数至少为 1，而二叉树的结点个数可以为 0；</li>
<li>树中结点的最大度数没有限制，而二叉树结点的最大度数为2（当然二叉树的度可以小于2）；</li>
</ul>
<p>二叉树具有5种基本的形态，由这5种基本形态可以形成不同的二叉树</p>
<p><img src="/images/image-20230720215312126.png" srcset="/img/loading.gif" lazyload></p>
<p>在实际的关于二叉树的应用中，经常用到两种特殊的二叉树分别是满二叉树和完全二叉树</p>
<h4 id="1-2-1-满二叉树"><a href="#1-2-1-满二叉树" class="headerlink" title="1.2.1 满二叉树"></a>1.2.1 满二叉树</h4><p>如果一棵二叉树中所有的叶结点均位于最后一层，而其他分支结点的度数均为2，则称此二叉树为满二叉树</p>
<p><img src="/images/image-20230720215933045.png" srcset="/img/loading.gif" lazyload alt="满二叉树示例"></p>
<h4 id="1-2-2-完全二叉树"><a href="#1-2-2-完全二叉树" class="headerlink" title="1.2.2 完全二叉树"></a>1.2.2 完全二叉树</h4><p>如果一棵二叉树扣除其最大层次那层后即成为一棵满二叉树，且最后一层的所有结点均向左靠齐，则称该二叉树为完全二叉树。</p>
<p><img src="/images/image-20230720220054747.png" srcset="/img/loading.gif" lazyload alt="完全二叉树示例"></p>
<p>若对深度相同的满二叉树和完全二叉树中的所有结点按自上而下、同一层次按自左向右的顺序依次编号，则两者对应位置上的结点编号应该相同。</p>
<blockquote>
<ul>
<li>满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树；</li>
<li>对于完全二叉树的定义，有另外两种更直观的理解<ul>
<li>如果对一棵深度为k有n个结点的二叉树编号后，各结点的编号与深度为k的满二叉树中相同位置上的结点的编号均相同，则该二叉树是完全二叉树；</li>
<li>一棵完全二叉树一定是由一棵满二叉树从右至左、从下至上挨个删除结点得到的；</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-2-3-二叉树性质"><a href="#1-2-3-二叉树性质" class="headerlink" title="1.2.3 二叉树性质"></a>1.2.3 二叉树性质</h4><p>在利用二叉树解决相关问题时，往往可以根据二叉树的性质设计出简单明了的存储结构和算法。首先要知道的是一些基本性质</p>
<ul>
<li>在一棵二叉树中，所有结点的分支数等于单分支结点数加双分支结点数的两倍即n<del>1</del>+2n<del>2</del>；</li>
<li>对任何树都有，总分支数&#x3D;总结点数-1（除根结点外，每个结点都有唯一的一个分支指向）；</li>
</ul>
<p>下面是根据基本性质推导得到的一些常见性质</p>
<ul>
<li><p>性质1：二叉树的第i层上至多有2^i-1^个结点（i≥1） – 数比数列的通项（首项为1，公比为2）</p>
</li>
<li><p>性质2：深度为h的二叉树至多有2^h^-1个结点（其中h≥1） – 等比数列求和</p>
</li>
<li><p>性质3：对于任何一棵二叉树，如果其终端结点数为 n<del>0</del>，度为 2 的结点数为 n<del>2</del>，则n<del>0</del>&#x3D;n<del>2</del>+1</p>
</li>
<li><p>性质4：具有 n 个结点的完全二叉树的深度为 [log<del>2</del>n]+1（向下取整）或[log<del>2</del>(n+1)]（向上取整）</p>
</li>
<li><p>性质5：对于具有 n 个结点的完全二叉树，如果按照从上到下、同一层次上的结点按从左到右的顺序对二叉树中的所有结点从1开始顺序编号，则对于序号为i的结点，有</p>
<ul>
<li><p>如果 i&gt;1，则序号为i 的结点其双亲结点的序号为[i&#x2F;2]（[i&#x2F;2]表示对 i&#x2F;2 的值取整）；如果i&#x3D;1，则结点i为根结点，没有双亲。</p>
</li>
<li><p>如果 2i&gt;n，则结点i无左孩子（此时结点i为终端结点）；否则其左孩子为结点 2i。</p>
</li>
<li><p>如果 2i+1&gt;n，则结点i无右孩子；否则其右孩子为结点 2i+1。</p>
</li>
</ul>
</li>
<li><p>性质6：给定n个结点，可以构成h种不同的二叉树，其中C(2n,n)&#x2F;(n+1) (n&#x3D;0,1,2,…)</p>
</li>
<li><p>性质7：含有n个结点的二叉链表（二叉树）中，有n+1个空链域</p>
</li>
</ul>
<h3 id="1-3-森林概述"><a href="#1-3-森林概述" class="headerlink" title="1.3 森林概述"></a>1.3 森林概述</h3><p>由 m（m&gt;0）棵互不相交的树构成的集合称为森林</p>
<p><img src="/images/image-20230720222710465.png" srcset="/img/loading.gif" lazyload alt="由3棵树构成的森林"></p>
<h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2.基本操作"></a>2.基本操作</h2><h3 id="2-1-树的遍历"><a href="#2-1-树的遍历" class="headerlink" title="2.1 树的遍历"></a>2.1 树的遍历</h3><p>树的遍历的定义如下：按照某种次序访问树中的所有结点，使得每个结点被访问且仅被访问一次。其中，“访问”的含义很广泛，可定义为读取结点的数据、打印结点的信息等。</p>
<p>根据树的定义可知，一棵树由根结点和 m棵子树构成，因此只要遍历根结点和 m 棵子树就可以遍历整棵树。通常树的遍历方法有 3 种：前序遍历、后序遍历和层序遍历。</p>
<p>（1）前序遍历</p>
<ol>
<li>访问根结点；</li>
<li>按照从左到右的顺序前序遍历根结点的每一棵子树。</li>
</ol>
<p>（2）后序遍历</p>
<ol>
<li>按照从左到右的顺序后序遍历根结点的每一棵子树；</li>
<li>访问根结点。</li>
</ol>
<p>（3）层序遍历</p>
<p>树的层序遍历也称树的广度遍历，其操作定义为从树的第一层（即根结点）开始自上而下逐层遍历，每一层按照从左到右的顺序逐个访问结点。</p>
<p>下图展示了一棵树按照上述三种遍历方式对应的遍历结果</p>
<p><img src="/images/image-20230721170932929.png" srcset="/img/loading.gif" lazyload alt="树的遍历示例"></p>
<blockquote>
<p>树的先序遍历与其对应的二叉树的先序遍历相同，树的后序遍历与其对应的二叉树的<code>中序遍历</code>相同</p>
</blockquote>
<h3 id="2-2-二叉树遍历"><a href="#2-2-二叉树遍历" class="headerlink" title="2.2 二叉树遍历"></a>2.2 二叉树遍历</h3><blockquote>
<p>给出任意一棵二叉树，它的遍历序列都是唯一的。反之，若已知一棵二叉树的前序遍历和中序遍历序列或后序遍历和中序遍历序列也可以唯一确定一棵二叉树。</p>
</blockquote>
<h4 id="2-2-1-遍历序列"><a href="#2-2-1-遍历序列" class="headerlink" title="2.2.1 遍历序列"></a>2.2.1 遍历序列</h4><p>二叉树最主要的算法就是二叉树的遍历。所谓二叉树的遍历，是指按一定的顺序对二叉树中的每个结点均访问且仅访问一次。</p>
<p>按照根结点访问位置的不同，不妨约定 D 表示根结点，L 表示左子树，R 表示右子树。通常把二叉树的遍历分为3种：前序遍历、中序遍历和后序遍历。</p>
<p>（1）前序遍历</p>
<ol>
<li>访问根结点；</li>
<li>前序遍历访问根结点的左子树；③ 前序遍历访问根结点的右子树。</li>
</ol>
<p>（2）中序遍历</p>
<ol>
<li>中序遍历访问根结点的左子树；</li>
<li>访问根结点；</li>
<li>中序遍历访问根结点的右子树。</li>
</ol>
<p>（3）后序遍历</p>
<ol>
<li>后序遍历访问根结点的左子树；② 后序遍历访问根结点的右子树；</li>
<li>访问根结点。</li>
</ol>
<p>此外，按照从上到下、同一层次从左到右的顺序访问二叉树，也是一种遍历方式，称为层序遍历。因此，根据以上二叉树遍历的定义，可得下图所示二叉树的前序、中序、后序和层序遍历的结果。</p>
<p><img src="/images/image-20230721171203655.png" srcset="/img/loading.gif" lazyload alt="二叉树的遍历示例"></p>
<h4 id="2-2-2-反问题"><a href="#2-2-2-反问题" class="headerlink" title="2.2.2 反问题"></a>2.2.2 反问题</h4><p>由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p>
<p><img src="/images/image-20230822202910704.png" srcset="/img/loading.gif" lazyload></p>
<p>同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。</p>
<p>由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树，实现方法留给读者思考</p>
<blockquote>
<p>若只知道二叉树的先序序列和后序序列，则无法唯一确定一棵二叉树。</p>
</blockquote>
<h3 id="2-3-森林的遍历"><a href="#2-3-森林的遍历" class="headerlink" title="2.3 森林的遍历"></a>2.3 森林的遍历</h3><p>森林的遍历方式有两种：前序遍历森林和后序遍历森林</p>
<p>（1）前序遍历森林，若森林非空，则：</p>
<ol>
<li>访问森林中的第一棵树的根结点；</li>
<li>前序遍历第一棵树中根结点的每一棵子树；</li>
<li>前序遍历除第一棵树以外的其他树。</li>
</ol>
<p>（2）后序遍历森林，若森林非空，则：</p>
<ol>
<li>后序遍历第一棵树的根结点的各个子树；</li>
<li>访问第一棵树的根结点；</li>
<li>后序遍历除第一棵树以外的其他树。</li>
</ol>
<p>下图展示了包含3棵树的森林的前序遍历和后序遍历结果</p>
<p><img src="/images/image-20230721171712647.png" srcset="/img/loading.gif" lazyload alt="森林的遍历示例"></p>
<p>简言之，前序遍历森林就是从左到右前序遍历森林中的每一棵树；后序遍历森林就是从左到右后序遍历森林中的每一棵树。</p>
<blockquote>
<ul>
<li>森林的先序遍历对应二叉树的先序遍历，森林的后序遍历对应二叉树的中序遍历</li>
<li>森林的中序遍历和后序遍历被认为是同一回事</li>
</ul>
</blockquote>
<h3 id="2-4-树、森林和二叉树的转换"><a href="#2-4-树、森林和二叉树的转换" class="headerlink" title="2.4 树、森林和二叉树的转换"></a>2.4 树、森林和二叉树的转换</h3><p>在树、森林和二叉树之间有一个一一对应关系，任何一个森林或一棵树可唯一地对应一棵二叉树；反之，任何一棵二叉树也能唯一地对应一个森林或一棵树。</p>
<p>根据森林、树和二叉树之间的关系，有如下结论（前面有提及，这里做汇总）：</p>
<p><img src="/images/image-20230822203428553.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>前序遍历森林&#x3D;前序遍历该森林对应的二叉树；</li>
<li>后序遍历森林&#x3D;中序遍历该森林对应的二叉树；</li>
<li>前序遍历树&#x3D;前序遍历该树对应的二叉树；</li>
<li>后序遍历树&#x3D;中序遍历该树对应的二叉树；</li>
</ul>
<p>故当用二叉链表作为存储结构时，树和森林的前序遍历、后序遍历可以用二叉树的前序遍历和中序遍历实现。</p>
<h4 id="2-4-1-树转换为二叉树"><a href="#2-4-1-树转换为二叉树" class="headerlink" title="2.4.1 树转换为二叉树"></a>2.4.1 树转换为二叉树</h4><p>实际上，前面介绍树的时候说过，二叉链表同样可以作为树的存储结构，但是与用二叉链表存储二叉树的指针域的意义不同：</p>
<ul>
<li>二叉链表存储二叉树，lchild指针域指向左孩子，rchild指针域指向右孩子；</li>
<li>二叉链表存储树，child指针域指向一个孩子结点，sibling指针与指向兄弟结点；</li>
</ul>
<p>要使用二叉链表存储树，需要先将树转换为二叉树后再使用孩子兄弟存储结构存储。</p>
<p>树中的每个结点可能有多个孩子，但二叉树中每个结点最多只能有两个孩子。要把树转换为二叉树，就必须要找到一种结点和结点之间至多有两个变量就能说明的关系。后面我们将提到树的一种存储结构：孩子兄弟表示法，即树中每个结点最多只有一个最左边的孩子（长子）和一个右邻的兄弟，这就是我们要找的关系。利用这种关系，我们很自然地就能将树转换成二叉树。具体方法如下。</p>
<ol>
<li>在所有兄弟之间加一连线。</li>
<li>对每个结点，除保留与其长子的连线外，去掉该结点与其他孩子的连线。</li>
</ol>
<p>下图就是按照上述方法进行的转换步骤，首先按照步骤１和２修改树中结点之间的连线，它就已经是一棵二叉树了，再旋转45°，就更加清楚了。</p>
<p><img src="/images/image-20230721172016523.png" srcset="/img/loading.gif" lazyload alt="树转换成二叉树"></p>
<h4 id="2-4-2-森林转换为二叉树"><a href="#2-4-2-森林转换为二叉树" class="headerlink" title="2.4.2 森林转换为二叉树"></a>2.4.2 森林转换为二叉树</h4><p>将森林转换成二叉树的方法与树类似，首先将森林中的每一棵树转换成二叉树，然后将每棵二叉树的根结点视为兄弟连在一起，如下图所示。</p>
<p><img src="/images/image-20230721172050231.png" srcset="/img/loading.gif" lazyload alt="森林转换成二叉树"></p>
<blockquote>
<p>因为要求是将森林转换为“一棵”二叉树，因此最终需要进行连接操作，具体做法就是将转换完成的二叉树依次作为前面二叉树的右子树连接即可。</p>
</blockquote>
<h4 id="2-4-3-二叉树转换成树"><a href="#2-4-3-二叉树转换成树" class="headerlink" title="2.4.3 二叉树转换成树"></a>2.4.3 二叉树转换成树</h4><p>将二叉树转换成树实际就是将树转换为二叉树的逆过程：</p>
<ol>
<li>从左上到右下进行分层，调整为水平方向；</li>
<li>将每层的结点和其父结点相连，删除每层结点之间的连接；</li>
</ol>
<h4 id="2-4-4-二叉树转换成森林"><a href="#2-4-4-二叉树转换成森林" class="headerlink" title="2.4.4 二叉树转换成森林"></a>2.4.4 二叉树转换成森林</h4><p>相应地，只需不停将根结点中有右孩子的二叉树的右孩子链接断开，直到不存在根节点有右孩子的二叉树。接着将每个二叉树按照上述转换成树的方法依次转化即可。</p>
<p><img src="/images/image-20230721172211337.png" srcset="/img/loading.gif" lazyload alt="二叉树转换成森林"></p>
<h2 id="3-存储结构"><a href="#3-存储结构" class="headerlink" title="3.存储结构"></a>3.存储结构</h2><blockquote>
<p>顺序存储方式同样适合图和树，但这种顺序存储一般不简单</p>
</blockquote>
<h3 id="3-1-树的存储结构"><a href="#3-1-树的存储结构" class="headerlink" title="3.1 树的存储结构"></a>3.1 树的存储结构</h3><p>无论采用什么存储结构来表示树，都要求具备两个特性：</p>
<ul>
<li>能够存储各结点的信息；</li>
<li>能够唯一地表示树中各结点之间的逻辑关系——父子关系；</li>
</ul>
<p>一般来说，无论多么复杂的逻辑结构，其存储结构一般为顺序结构、链式结构或二者的组合结构这3种，下面就介绍几种树的基本存储结构。</p>
<h4 id="3-1-1-双亲表示法"><a href="#3-1-1-双亲表示法" class="headerlink" title="3.1.1 双亲表示法"></a>3.1.1 双亲表示法</h4><blockquote>
<p>树的顺序存储结构中最简单直观的就是双亲表示法，用一维数组即可实现：</p>
<ul>
<li>数组下标表示树的结点</li>
<li>数组元素的内容表示该结点的双亲结点</li>
</ul>
<p>双亲表示法在克鲁斯卡尔算法中有重要应用</p>
</blockquote>
<p>数组中的第一个元素表示根结点，该结点无双亲，因此parent域用-1表示，其他结点按照层序存储。如结点B、C、D的双亲结点是下标为0的根结点，其parent域用0表示。</p>
<p><img src="/images/image-20230721172501864.png" srcset="/img/loading.gif" lazyload alt="双亲表示法示例"></p>
<p>双亲表示法的存储结构实质上是一个静态链表，每个数组元素的结点结构如下图所示</p>
<p><img src="/images/image-20230721172545630.png" srcset="/img/loading.gif" lazyload alt="树的结点结构与"></p>
<p>其中data表示数据域，parent是指针域，存储该结点的双亲在数组中的下标。整棵树的C++描述如下。</p>
<p><img src="/images/image-20230721172611049.png" srcset="/img/loading.gif" lazyload></p>
<p>双亲表示法存储树的结构的优点在于结构简单，查找结点的双亲或者祖先非常方便。</p>
<h4 id="3-1-2-孩子表示法"><a href="#3-1-2-孩子表示法" class="headerlink" title="3.1.2 孩子表示法"></a>3.1.2 孩子表示法</h4><blockquote>
<p>链式存储结构（该存储结构实际上就是图的邻接表存储结构）</p>
</blockquote>
<p>如果应用时需要查找当前结点的孩子，双亲表示法就会比较复杂，此时可以设计其他的存储结构来适应查找孩子结点的需求，即孩子表示法，如下图所示。</p>
<p><img src="/images/image-20230721172657242.png" srcset="/img/loading.gif" lazyload alt="孩子表示法示例"></p>
<p>孩子表示法采用一维数组和多个单链表结合的方法。其中，一维数组的每个元素包含一个结点和一个指针，该指针指向一个链表，这个链表即该结点的所有孩子结点的集合，结点的结构如上图所示。</p>
<p>用C++描述上述结构，代码如下</p>
<p><img src="/images/image-20230721172748902.png" srcset="/img/loading.gif" lazyload></p>
<p>从上述结构可知，孩子表示法与双亲表示法正好相反，查找孩子结点很方便，但是查找双亲结点较为复杂。</p>
<h4 id="3-1-3-孩子-双亲表示法"><a href="#3-1-3-孩子-双亲表示法" class="headerlink" title="3.1.3 孩子-双亲表示法"></a>3.1.3 孩子-双亲表示法</h4><blockquote>
<p>顺序+链式存储结构</p>
</blockquote>
<p>这种存储结构受到上述存储结构的启发，既可以方便的查找双亲结点也可以方便的查找孩子结点</p>
<p><img src="/images/image-20230721172830933.png" srcset="/img/loading.gif" lazyload alt="孩子-双亲表示法示意图"></p>
<h4 id="3-1-4-多重链表法"><a href="#3-1-4-多重链表法" class="headerlink" title="3.1.4 多重链表法"></a>3.1.4 多重链表法</h4><blockquote>
<p>链式存储结构</p>
</blockquote>
<p>多重链表法指每个结点包括一个结点信息域和多个指针域，每个指针域指向该结点的一个孩子结点，通过各个指针域的值反映出树中各结点之间的逻辑关系，如图所示。</p>
<p><img src="/images/image-20230721173030183.png" srcset="/img/loading.gif" lazyload alt="多重链表表示法示例"></p>
<p>在这种表示法中，树中每个结点有多个指针域，从而形成了多条链表。由于每个结点的孩子个数没有限制，各结点的度数又各异，可能会造成存储空间的浪费。例如，一棵度为k的树，若其结点总数为n，则至少要浪费nk-n+1个空指针域。所以多重链表法不适合存储度数较大的树。</p>
<h4 id="3-1-5-孩子兄弟表示法"><a href="#3-1-5-孩子兄弟表示法" class="headerlink" title="3.1.5 孩子兄弟表示法"></a>3.1.5 孩子兄弟表示法</h4><blockquote>
<p>链式存储结构（该存储结构与树和森林与二叉树的相互转换关系密切）</p>
</blockquote>
<p>孩子兄弟表示法又称二叉链表表示法，链表中的每个结点包含一个数据域和两个指针域，其中，数据域用来存储结点数据；第1 个指针域指向该结点的第一个孩子结点；第2 个指针域指向该结点的第一个右兄弟。</p>
<p>按照孩子兄弟表示法，树的存储结构如图所示</p>
<p><img src="/images/image-20230721173154873.png" srcset="/img/loading.gif" lazyload alt="孩子兄弟表示法示例"></p>
<p>用C++描述上述结构代码如下</p>
<p><img src="/images/image-20230721173230588.png" srcset="/img/loading.gif" lazyload></p>
<p>由于二叉树是一种最简单的树，这种方法便于实现树的各种操作。因此，该结构最大的优点就是可以将任意复杂的树结构转换成二叉树，这样对树的研究就可以转化为对二叉树的研究，降低了问题的复杂程度。</p>
<h3 id="3-2-二叉树的存储结构"><a href="#3-2-二叉树的存储结构" class="headerlink" title="3.2 二叉树的存储结构"></a>3.2 二叉树的存储结构</h3><p>二叉树的存储结构应能体现二叉树结点之间的逻辑关系，也就是双亲和孩子之间的关系。不同的实际应用需求不同，因此衍生出了不同的存储结构。</p>
<h4 id="3-2-1-顺序存储结构"><a href="#3-2-1-顺序存储结构" class="headerlink" title="3.2.1 顺序存储结构"></a>3.2.1 顺序存储结构</h4><p>二叉树的顺序存储结构使用一维数组存储二叉树的结点，利用结点的存储位置来表示结点之间的关系。由于二叉树结点之间不具有顺序关系，因此利用二叉树的性质5实现顺序存储。具体如下：</p>
<p>将二叉树按照完全二叉树编号；其中无结点的位置使用 NULL 表示，结点则存储在一维数组相应的位置上，如图所示。</p>
<p><img src="/images/image-20230721173433234.png" srcset="/img/loading.gif" lazyload alt="顺序存储结构"></p>
<p>显然，这种存储数据的方法逻辑简单但会造成空间的浪费，因此，该方法最适合存储完全二叉树。</p>
<h4 id="3-2-2-二叉链表"><a href="#3-2-2-二叉链表" class="headerlink" title="3.2.2 二叉链表"></a>3.2.2 二叉链表</h4><p>二叉树每个结点最多有两个分支，因此一般多采用二叉链表的存储结构，其基本思想如下所示</p>
<p><img src="/images/image-20230721173535170.png" srcset="/img/loading.gif" lazyload alt="二叉链表示例"></p>
<p>二叉链表的结点结构如图所示</p>
<p><img src="/images/image-20230721173607970.png" srcset="/img/loading.gif" lazyload></p>
<p>其中每一个结点由 3 个域组成。其中，数据域存储结点的数据；左指针域存储左孩子结点的地址；右指针域存储右孩子结点的地址。</p>
<p>二叉链表的C++的类型描述如下</p>
<p><img src="/images/image-20230721173654143.png" srcset="/img/loading.gif" lazyload></p>
<p>二叉链表的存储方式和树的孩子兄弟表示法的存储结构完全相同，任何一棵复杂的树都可以容易地使用二叉链表的方式进行存储，因此，许多树和二叉树的应用都是围绕二叉链表这种存储结构展开的。</p>
<h4 id="3-2-3-三叉链表"><a href="#3-2-3-三叉链表" class="headerlink" title="3.2.3 三叉链表"></a>3.2.3 三叉链表</h4><p>在二叉链表的存储方式下，从某结点出发可以直接访问到它的孩子结点，但要找到它的双亲，则必须从根结点开始搜索，最坏情况下，可能需要遍历整个二叉链表。所以，在这种情况下，可以采用三叉链表来存储二叉树，以避免该问题的发生。三叉链表的结构如图所示</p>
<p><img src="/images/image-20230721173752027.png" srcset="/img/loading.gif" lazyload alt="三叉链表示例"></p>
<p>三叉链表的结点结构如下所示</p>
<p><img src="/images/image-20230721173821571.png" srcset="/img/loading.gif" lazyload alt="三叉链表的结点结构"></p>
<p>其中每一个结点由4个域组成。其中，数据域存储结点的数据；左指针域存储左孩子结点的地址；右指针域存储右孩子结点的地址；双亲指针域存储双亲结点的地址。</p>
<p>三叉链表结点的C++描述如下</p>
<p><img src="/images/image-20230721173852921.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-二叉树详解"><a href="#4-二叉树详解" class="headerlink" title="4.二叉树详解"></a>4.二叉树详解</h2><h3 id="4-1-类声明-1"><a href="#4-1-类声明-1" class="headerlink" title="4.1 类声明"></a>4.1 类声明</h3><p>本节采用二叉链表作为二叉树的存储结构，其简单的C++类声明如下</p>
<p><img src="/images/image-20230721174122908.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-2-成员函数实现"><a href="#4-2-成员函数实现" class="headerlink" title="4.2 成员函数实现"></a>4.2 成员函数实现</h3><h4 id="4-2-1-二叉树的创建"><a href="#4-2-1-二叉树的创建" class="headerlink" title="4.2.1 二叉树的创建"></a>4.2.1 二叉树的创建</h4><p>建立二叉树有很多种方法，其中较为简单的就是使用顺序存储结构来建立二叉链表。根据顺序存储结构的特点和二叉树的性质5，可知如果当前结点的位置为i，则其左孩子位置为2i，右孩子为2i+1。所以，以顺序存储结构为输入创建二叉树时，采用先建立根结点，再建立左右孩子的方法递归地建立用二叉链表表示的二叉树，其C++描述如下：</p>
<p><img src="/images/image-20230721174222743.png" srcset="/img/loading.gif" lazyload></p>
<p>上述递归程序分解步骤如下，假设输入为下图的顺序存储结构表示的二叉树，则递归地建立用二叉链表表示的二叉树示意图如下</p>
<p><img src="/images/image-20230721174316620.png" srcset="/img/loading.gif" lazyload alt="建立结点的过程"></p>
<h4 id="4-2-2-前序、中序、后序遍历"><a href="#4-2-2-前序、中序、后序遍历" class="headerlink" title="4.2.2 前序、中序、后序遍历"></a>4.2.2 前序、中序、后序遍历</h4><p>由二叉树的前序遍历定义，结合递归，可以很容易地写出前序遍历的递归算法，前序遍历的结果如图所示。</p>
<p><img src="/images/image-20230721174423027.png" srcset="/img/loading.gif" lazyload alt="二叉树前序遍历结果"></p>
<p>C++算法描述如下：</p>
<p><img src="/images/image-20230721174444608.png" srcset="/img/loading.gif" lazyload></p>
<p>对于中序遍历，只需要把语句cout &lt;<R-> data；移到语句PreOrder（R-&gt; 1child）；之后即可；对于后续遍历，只需要把语句 cout &lt;<R->data；移到语句 PreOrder（R-&gt; rchild）；之后即可。在这里不再给出具体代码。</p>
<h4 id="4-2-3-层序遍历"><a href="#4-2-3-层序遍历" class="headerlink" title="4.2.3 层序遍历"></a>4.2.3 层序遍历</h4><p>在进行层序遍历时，对某一层的结点访问完毕后，再按照它们的访问次序对各个结点的左孩子和右孩子顺序访问，这样一层一层地进行，先访问的结点其左右孩子也要先访问，这与队列的特性比较吻合。因此，我们可以利用队列来实现二叉链表的层序遍历。</p>
<p>二叉链表的层序遍历基本思想如下，以下图(a)所示二叉树为例，层序遍历的步骤分解如下图(b)所示。</p>
<p><img src="/images/image-20230721174606541.png" srcset="/img/loading.gif" lazyload alt="层序遍历分解图"></p>
<p>算法流程描述如下</p>
<p><img src="/images/image-20230721174712217.png" srcset="/img/loading.gif" lazyload></p>
<p>层序遍历的C++描述代码如下</p>
<p><img src="/images/image-20230721174732826.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-2-4-析构函数"><a href="#4-2-4-析构函数" class="headerlink" title="4.2.4 析构函数"></a>4.2.4 析构函数</h4><p>二叉链表属于动态存储分配，因此，需要在析构函数中释放二叉链表的所有结点。为了防止内存泄漏，释放结点时应先释放该结点的左右子树，左右子树全部释放完毕后再释放该结点。采用后序遍历的方法，其具体算法如下：</p>
<p><img src="/images/image-20230721174902418.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5-哈夫曼树详解"><a href="#5-哈夫曼树详解" class="headerlink" title="5.哈夫曼树详解"></a>5.哈夫曼树详解</h2><p>本节将介绍二叉树的一种应用 – 哈夫曼（Huffman）编码。哈夫曼编码是1952年最先由Huffman提出的一种广泛应用于数据压缩的有效的编码方法，如JPEG中就应用了哈夫曼编码。哈夫曼编码的基础是哈夫曼树，这是一种特殊的二叉树，下面首先介绍什么是哈夫曼树。</p>
<h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><blockquote>
<p>哈夫曼树是二叉树的一种应用，但实际上并没有明确的规定说哈夫曼树一定是二叉树，这意味着可能有哈夫曼n叉树。若题干要求构造哈夫曼n叉树但所给权值结点不足，则需要手动补充权值为0的结点使其能够构造为哈夫曼n叉树（构造方法模仿哈夫曼二叉树自底向上依次选择结点即可）</p>
</blockquote>
<h4 id="5-1-1-哈夫曼树"><a href="#5-1-1-哈夫曼树" class="headerlink" title="5.1.1 哈夫曼树"></a>5.1.1 哈夫曼树</h4><p>与哈夫曼树相关的一些概念：</p>
<ul>
<li>路径长度：从树中一个结点到另一个结点的分支的数目（注意是分支的数目而非结点的数目）</li>
<li>树的路径长度：指从根结点到每个结点的路径长度的求和</li>
<li>树的带权路径长度WPL：树中所有叶子结点的带权路径长度求和</li>
</ul>
<p>通过计算下图中的3棵二叉树的带权路径长度可以更好的理解上述概念</p>
<p><img src="/images/image-20230721181233481.png" srcset="/img/loading.gif" lazyload alt="带权路径长度"></p>
<p>哈夫曼树的几个特点：</p>
<ol>
<li>权值越大的结点离根结点越近；</li>
<li>树中不存在度为1的结点（这是因为它是自底向上构造的）；</li>
<li>树的带权路径长度WPL最短；</li>
</ol>
<p>给定n个权值，使用这n个权值构造哈夫曼树的算法描述如下</p>
<p><img src="/images/image-20230822195448378.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>哈夫曼树的形态标准：左子树根权值小于右子树权值，若两者全职相同则较矮的子树在左边</p>
</blockquote>
<h4 id="5-1-2-哈夫曼编码"><a href="#5-1-2-哈夫曼编码" class="headerlink" title="5.1.2 哈夫曼编码"></a>5.1.2 哈夫曼编码</h4><p>有了哈夫曼树，就可以对所有的结点进行编码了。哈夫曼编码根据字符出现的概率来构造平均长度最短的编码，是一种变长的编码（经哈夫曼编码得到的字符编码，其长度因符号出现的概率而不同，所以说哈夫曼编码是变长的编码）。它的基本原理是频繁使用的数据用较短的代码代替，较少使用的数据用较长的代码代替，每个数据的代码各不相同，但最终编码的平均长度是最小的。</p>
<p>以字符出现的概率为权值构造一棵哈夫曼树后，经哈夫曼编码得到对应的码值。哈夫曼编码的规则是从根结点到叶结点（包含原信息）的路径，向左孩子前进编码为0，向右孩子前进编码为1，当然也可以反过来规定。例如，设字符A、B、Z、C出现的次数分别为9、6、2、3，其构造的哈夫曼树和哈夫曼编码如图所示</p>
<p><img src="/images/image-20230721182607343.png" srcset="/img/loading.gif" lazyload alt="哈夫曼编码示例"></p>
<p>根据哈夫曼树得到字符A、B、Z、C的编码分别为0、11、100、101。只要使用同一棵哈夫曼树，就可以把编码还原成原来那组字符。显然哈夫曼编码是前缀编码，即任何一个字符的编码都不是另一个字符的编码的前缀，否则，编码就不能进行翻译。</p>
<blockquote>
<ul>
<li>构造哈夫曼编码时使用编码规则表更方便；</li>
<li>反向解码时直接使用哈夫曼树更方便：<ol>
<li>遇到叶子结点则解码；</li>
<li>遇到非叶子结点则继续向下读取；</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="5-2-类声明"><a href="#5-2-类声明" class="headerlink" title="5.2 类声明"></a>5.2 类声明</h3><p>如何设计存储结构来存储一棵哈夫曼树呢？我们可以采用如前所述的二叉树存储方法。在这里，我们采用一种新的静态存储结构 – 静态三叉链表来存储。静态存储结构一般采用数组来实现，数组中的每个元素包含多个数据域，存储一个树结点。</p>
<p>静态三叉链表结点的C++描述如下</p>
<p><img src="/images/image-20230721182815712.png" srcset="/img/loading.gif" lazyload></p>
<p>哈夫曼树是一棵正则二叉树。所谓正则二叉树，即只有度为 0 和2 的结点的二叉树。根据二叉树的性质，一棵有n个叶子的哈夫曼树共有2n-1个结点，可以用一个大小为2n-1 的一维数组存放哈夫曼树的各个结点。</p>
<p>图（a）所示的哈夫曼树含有4个叶子结点，因此可定义存储结构为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HNode*HTree=new HNode（<span class="hljs-number">7</span>）；<br></code></pre></td></tr></table></figure>

<p>其存储内容如图（b）所示，值为-1表示无孩子结点或双亲结点</p>
<p><img src="/images/image-20230721183012480.png" srcset="/img/loading.gif" lazyload alt="哈夫曼树及其存储结构举例"></p>
<p>为了记录每个结点的编码，需要设计哈夫曼编码表对其进行存储。编码表中每个元素的C++描述如下</p>
<p><img src="/images/image-20230721183109475.png" srcset="/img/loading.gif" lazyload></p>
<p>其中，data存储结点的内存，在这里其数据类型假设为char，在实际应用中，可根据需要选择合适的数据类型。code数组存储结点对应的编码，在这里编码采用字符串存储。使用 HCod类型定义一个一维数组，就可以存储所有结点的编码了。</p>
<p>存储结构设计好以后，就可以设计哈夫曼编码的相关算法，如哈夫曼树的构造、编码算法、解码算法等。其 C++类描述如下：</p>
<p><img src="/images/image-20230721183146785.png" srcset="/img/loading.gif" lazyload></p>
<p>其中，HTree存储哈夫曼树的结构，HCodeTable存储每个结点的编码内容。在这里，假设要编码的数据和编码结果均为字符串类型。</p>
<h3 id="5-3-成员函数实现"><a href="#5-3-成员函数实现" class="headerlink" title="5.3 成员函数实现"></a>5.3 成员函数实现</h3><h4 id="5-3-1-哈夫曼树的创建"><a href="#5-3-1-哈夫曼树的创建" class="headerlink" title="5.3.1 哈夫曼树的创建"></a>5.3.1 哈夫曼树的创建</h4><p>创建(构造)哈夫曼树的方法就是哈夫曼算法，哈夫曼树的构造算法描述如下</p>
<p><img src="/images/image-20230722192836488.png" srcset="/img/loading.gif" lazyload alt="哈夫曼树构造算法"></p>
<p>这里举一个例子帮助理解，一篇文档中只有4种字符，分别是A、B、Z、C，每个字符出现次数分别为9、6、2、3，每个字符出现的次数可看成是字符的权值，则按照哈夫曼算法，构造哈夫曼的步骤如图所示</p>
<p><img src="/images/image-20230722192930253.png" srcset="/img/loading.gif" lazyload alt="哈夫曼算法示例"></p>
<p>下面来验证哈夫曼编码的压缩效果。若4 个字符按照定长编码，则A、B、Z、C的编码最短为00、01、10、11，按照这个编码方式，该文档的大小为<code>(9+6+3+2)*2=40bit</code>；而如果按照哈夫曼编码则得到的文档大小为<code>9*1+6*2+(2+3)*2=36bit</code>；</p>
<p>假设已知需要编码的数据中每种字符的权值，则可以按照哈夫曼树的建树方法对静态三叉链表进行处理，如下所示。</p>
<p><img src="/images/image-20230722193155728.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-3-2-哈夫曼编码表的创建"><a href="#5-3-2-哈夫曼编码表的创建" class="headerlink" title="5.3.2 哈夫曼编码表的创建"></a>5.3.2 哈夫曼编码表的创建</h4><p>在哈夫曼树构建完成后，下一步就是生成编码表。下面将采用向上而下递归的处理方式，对每一个结点进行编码。从哈夫曼树的根结点开始，设其编码为空，然后分别对其左右子树中的结点进行编码。若子树的根结点是其父结点的左分支则编码“0”，若是右分支则编码“1”，然后递归处理，直到叶子结点为止。</p>
<p>生成编码表的C++描述如下</p>
<p><img src="/images/image-20230722193333716.png" srcset="/img/loading.gif" lazyload alt="生成哈夫曼编码表"></p>
<p>下图(a)所示的哈夫曼树其对应的编码表可以是下图(b)所示的结构实际上字符的编码应该用bit表示，即对于1个字符“Z”使用3个bit“100”表示。由于本算法主要用来说明算法思想，为方便起见，字符编码采用纯字符串形式，即对“Z”的编码“100”使用3个字符表示（这个地方作者的意思实际上就是“编码表中的编码是以纯字符串形式表示的，而不是常见的二进制形式。在实际的计算机应用中，编码会用二进制位来表示，而不是纯字符串形式。”）。</p>
<p><img src="/images/image-20230722193515147.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-3-3-哈夫曼编码-amp-解码"><a href="#5-3-3-哈夫曼编码-amp-解码" class="headerlink" title="5.3.3 哈夫曼编码&amp;解码"></a>5.3.3 哈夫曼编码&amp;解码</h4><p>通常，我们对一段信息进行哈夫曼编码时，需要对编码的数据进行两遍扫描。第一遍用来统计原数据中各字符出现的频率，利用得到的频率值创建哈夫曼树，并要把树的信息及编码表保存起来，以便解压时创建同样的哈夫曼树进行解压；第二遍根据第一遍扫描得到的哈夫曼编码表对原始数据进行编码，并把编码后得到的码字存储起来。生成编码表后，对于要编码的字符串，如”ACCZBBBAAACBBZABAAAA”，每读出一个字符，只要在编码表中找出对应的编码即可。哈夫曼编码的代码书上并没有给出，这里给出自行编写的一个编码函数（不一定完全正确）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 哈夫曼编码函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Huffman::Encode</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">char</span>* d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (*s != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        <span class="hljs-comment">// 寻找当前字符在编码表中对应的编码</span><br>        <span class="hljs-type">char</span> c = *s;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (HCodeTable[i].data == c)<br>            &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果找到了对应的编码</span><br>        <span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)<br>        &#123;<br>            string code = HCodeTable[index].code;<br>            <span class="hljs-comment">// 将当前字符的编码逐个写入输出缓冲区（d指针指向的位置）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> bit : code)<br>            &#123;<br>                *d = bit;<br>                d++;<br>            &#125;<br>        &#125;<br><br>        s++; <span class="hljs-comment">// 处理下一个字符</span><br>    &#125;<br><br>    <span class="hljs-comment">// 最后加上字符串结束符</span><br>    *d = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在这个编码函数中，我们逐个处理输入的字符，然后在编码表中查找对应的编码。找到编码后，将每个二进制位（&#x27;0&#x27;或&#x27;1&#x27;）逐个写入输出缓冲区（d指针指向的位置）。最后，我们加上字符串结束符&#x27;\0&#x27;，确保输出的编码字符串正确终止。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">请注意，为了更好地与解码函数配合，编码表（HCodeTable）应该在创建哈夫曼树后创建，并且在编码和解码过程中都需要使用相同的编码表。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>对于解码，如”010110110011111100010111111000110000”编码串，其基本思想是将编码串从左到右逐位判别，直到确定一个字符。即从哈夫曼树的根结点开始，根据每一位是0还是1，确定选择左分支还是右分支，直到到达叶子结点，至此一个字符解码结束。然后，再从根结点开始下一个字符的解码。所以上述编码串的解码结果为”ACCZBBB…”。哈夫曼解码的C++描述如下</p>
<p><img src="/images/image-20230722194858065.png" srcset="/img/loading.gif" lazyload></p>
<p>上述算法采用字符串的方式对哈夫曼编码算法进行模拟，如字符“C”使用了“101”这3 个字符进行编码，这种情况下是没有任何压缩效果的，反而会增大存储空间。实际上真正的哈夫曼编码采用比特方式进行，如字符”C”应该使用“101”这3个bit进行编码，此外，若解码时编码表未知，则必须将编码表保存在压缩后的信息中，才能保证正确解压缩。</p>
<h2 id="6-并查集详解"><a href="#6-并查集详解" class="headerlink" title="6.并查集详解"></a>6.并查集详解</h2><ul>
<li>并查集超简单详解：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">并查集</a>；</li>
<li>相关代码及其优化：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798?p=53&vd_source=276d55048634a5b508b1b53a1ecd56b3">并查集</a>；</li>
</ul>
<p>并查集是一种树状结构，在图的最小生成树中有应用。并查集是一种简单的集合表示，管理一系列不相交的集合，主要执行对集合的“并”以及对集合元素的“查”操作：</p>
<ul>
<li>Union（S，Root1，Root2）：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并；</li>
<li>Find（S，x）：查找集合S中单元素x所在的子集合，并返回该子集合的根结点；</li>
</ul>
<p>通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内（森林的定义：m棵互不相交的树的集合）。</p>
<p>在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从 0 到 SIZE-1其中 SIZE 是最大元素的个数。下面是并查集的结构定义以及主要运算的实现（有些地方令根的双亲小于0，有的令其等于自身，规定不同操作略有不同）。</p>
<p><img src="/images/image-20230825205447232.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="第五章-图"><a href="#第五章-图" class="headerlink" title="第五章 图"></a>第五章 图</h1><p>在线性结构中，数据元素之间是一对一的关系，树结构中数据元素之间是一对多的关系，图结构是一种比树结构还要复杂的非线性结构，图结构中数据元素之间是多对多的关系。因此，图结构具有极强的表达能力，可用于描述各种复杂的数据对象，在通信系统、交通系统、人工智能、计算机网络、信息处理等领域有着广泛的应用。</p>
<h2 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>图G由两个集合V和E组成，记为G&#x3D;（V，E），其中，V代表图中顶点的集合，E代表顶点之间的关系。E可以是空集，表示图只有顶点而没有边。</p>
<p><img src="/images/image-20230722200351176.png" srcset="/img/loading.gif" lazyload alt="图的表示方法示例"></p>
<p>线性表、树与图之间的联系与区别如下：</p>
<ul>
<li>线性表中的数据元素称为元素，树中的数据元素称为结点，图中的数据元素称为顶点Vertex</li>
<li>线性表中可以没有数据元素（空表），树中可以没有结点（空树），但是在图结构中不允许没有顶点</li>
<li>图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，顶点集不能为空，但是边集可以为空</li>
</ul>
<blockquote>
<p>为了与树区分，图中的结点称为顶点</p>
</blockquote>
<p>图的逻辑结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 图（graph）<br>Data <br>    顶点的非空有穷集合和边的集合<br>Operation 	<br>    <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(*G,V,VR)</span>:按照顶点集和边弧集VR的定义构造图G<br>    <span class="hljs-title function_">LocateVex</span><span class="hljs-params">(G,u)</span>:若图G中存在顶点u则返回u在图中的位置<br>    <span class="hljs-title function_">GetVex</span><span class="hljs-params">(G,u)</span>:若图G中存在顶点u则返回u的值<br>    <span class="hljs-title function_">DeleteVex</span><span class="hljs-params">(*G,v)</span>:删除图G中顶点v以及其相关的弧<br>    <span class="hljs-title function_">DeleteArc</span><span class="hljs-params">(*G,v,w)</span>:删除图中的有向弧&lt;v,w&gt;，若G是无向图则还需要删除其对称弧&lt;w,v&gt;<br>    <span class="hljs-title function_">DFSTraverse</span><span class="hljs-params">(G)</span>:深度优先遍历<br>    <span class="hljs-title function_">HFSTraverse</span><span class="hljs-params">(G)</span>:广度优先遍历<br>endADT<br></code></pre></td></tr></table></figure>

<p>为了方便描述图的特点，本章涉及的基本概念如下：</p>
<ol>
<li><p>顶点：数据元素通常称为顶点。</p>
</li>
<li><p>边：顶点之间的无向连线，如图（a）所示。</p>
</li>
<li><p>弧：顶点之间的有向连线，如图（b）所示。</p>
<ul>
<li>含箭头的一端称为弧头，另一端称为弧尾</li>
</ul>
</li>
<li><p>无向图：图中的每条连线都是无方向的，如图（a）所示。</p>
</li>
<li><p>有向图：图中的每条连线都是有方向的，如图（b）所示。</p>
</li>
<li><p>简单图：不存在顶点到其自身的边，且同一条边不重复。图（c）和图（d）都不是简单图</p>
</li>
<li><p>邻接点：如果（v<del>i</del>,v<del>j</del>）是图中的一条边，则称v<del>i</del>与v<del>j</del>互为邻接点；如果 &lt;v<del>i</del>,v<del>j</del>&gt;是图中的一条弧，则称v<del>j</del>是v<del>i</del>的邻接点。</p>
</li>
<li><p>含有 n 个顶点、n（n-1）&#x2F;2 条边的图称为完全无向图，如图（e）所示；含有 n 个顶点、n（n-1）条弧的图称为完全有向图，如图（f）所示。</p>
<ul>
<li>若无向图有n个顶点，则最多有(n-1)n&#x2F;2条边；称有(n-1)n&#x2F;2条边的无向图为无向完全图</li>
<li>若有向图有n个顶点，则最多有(n-1)n条边；称有(n-1)n条边的有向图为有向完全图</li>
</ul>
</li>
<li><p>边或弧很少的图，称为稀疏图；边或弧较多的图，称为稠密图。稀疏图和稠密图常常是相对而言的，如图（g）和图（h）对比，则图（g）是稀疏图，图（h）是稠密图。</p>
</li>
</ol>
<p><img src="/images/image-20230722200758044.png" srcset="/img/loading.gif" lazyload alt="图的示例"></p>
<ol start="10">
<li>度：一个顶点的度是与它相关联的边或弧的条数。</li>
<li>入度：有向图中到达顶点的弧数，下图中顶点 A 的入度为 1。</li>
<li>出度：有向图中顶点出发的弧数，下图中顶点 A 的出度为 2。</li>
<li>网：带权的图；根据网是否有向可分为有向网和无向网。</li>
</ol>
<p><img src="/images/image-20230722201304534.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<ol start="14">
<li>子图：图的子集</li>
</ol>
<p><img src="/images/image-20230722201401094.png" srcset="/img/loading.gif" lazyload alt="子图示例"></p>
<ol start="15">
<li>路径：接续的边的端点构成的顶点序列，下图中v<del>1</del>到v<del>5</del>的路径为(v<del>1</del>,v<del>4</del>,v<del>3</del>,v<del>5</del>)；</li>
<li>路径长度：路径上边或弧的数目；在网中为路径上边或弧的权值之和。下图中v<del>1</del>到v<del>5</del>的路径长度为3；</li>
</ol>
<p><img src="/images/image-20230722201547711.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<ol start="17">
<li>回路：起点和终点相同的路径。</li>
<li>简单路径：路径序列中，顶点不重复出现的路径，如图（a）所示。</li>
<li>简单回路：路径序列中，除了起点和终点外，其余顶点均不相同的回路，如图（c）所示</li>
</ol>
<p><img src="/images/image-20230722201647700.png" srcset="/img/loading.gif" lazyload></p>
<ol start="20">
<li>连通图：在<code>无向图</code>中，若任意一对顶点都存在路径，则称其为连通图，否则为非连通图。</li>
<li>连通分量：当图非连通时，<code>无向图</code>中的极大连通子图称为联通分量<ul>
<li>极大连通子图包含所有连通的顶点以及和这些顶点相关联的所有边，无法继续扩充顶点</li>
<li>极小联通子图中的“极小”指的是添加一条边就会出现环</li>
</ul>
</li>
</ol>
<p><img src="/images/image-20230722201857376.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<ol start="22">
<li>强连通图：在<code>有向图</code>中，若任意一对顶点都存在路径(双向路径)，则称其为强连通图，否则为非强连通图。</li>
<li>强连通分量：当图非连通时，<code>有向图</code>中的极大连通子图称为强连通分量</li>
</ol>
<p><img src="/images/image-20230722201936562.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<ol start="24">
<li>生成树：连通图中一个极小连通子图，即含有全部顶点，但只有足以构成树的 n一1条边，如图所示。</li>
</ol>
<p><img src="/images/image-20230722202008858.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<ol start="25">
<li>生成森林：在非连通图中，每个连通分量都可以得到一棵生成树，这些连通分量的生成树构成生成森林，如图所示。</li>
</ol>
<p><img src="/images/image-20230722202033527.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<h2 id="2-图的存储结构"><a href="#2-图的存储结构" class="headerlink" title="2.图的存储结构"></a>2.图的存储结构</h2><p>图是一种复杂的非线性结构，因此要想设计出合理的图的存储结构，就一定要先讨论图的逻辑结构关系。数据结构中除集合外还有3种逻辑结构，即线性结构、树结构和图结构，对比分析如下。</p>
<ol>
<li>线性结构：结点之间的关系是线性关系，即除头结点和尾结点外，每个结点只有唯一一个前驱和唯一一个后继。</li>
<li>树结构：结点之间的关系实质上是层次关系，即除根结点外，每个结点都只有唯一一个前驱，但每个结点可以有0个或多个后继。</li>
<li>图结构：结点之间是多对多的关系，即每个结点都可以有 0个或多个前驱和 0 个或多个后继，结点之间的关系是任意的。</li>
</ol>
<p>根据图的定义，一个图包括两部分信息，即顶点和顶点之间的关系。顶点之间的关系表示是设计图存储结构的关键。下面将讨论5种图的存储结构：邻接矩阵、邻接表、十字链表、邻接多重表和边集数组。</p>
<h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>二维数组可以用来表示顶点之间相邻关系。设G&#x3D;（V，E）是具有 n 个顶点的图，顶点序号依次为 0，1，…，n-1，则邻接矩阵表示为</p>
<p><img src="/images/image-20230722202420154.png" srcset="/img/loading.gif" lazyload></p>
<p>无向图的邻接矩阵一定是一个对称矩阵，如图（a）所示；而有向图的邻接矩阵可以是不对称的，如图（b）所示；</p>
<p><img src="/images/image-20230722202450933.png" srcset="/img/loading.gif" lazyload></p>
<p>网的邻接矩阵可以定义为</p>
<p><img src="/images/image-20230722202528066.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>不同的教材对结点到自身的路径长度规定不同，有的规定尾0有的规定的∞，需要注意辨别；</p>
</blockquote>
<p>实际编程中，可以使用一个计算机允许的、大于所有边上权值的数，即宏 MAX_VALUE代替∞。下图给出了一个网的邻接矩阵存储的示例。</p>
<p><img src="/images/image-20230722202615193.png" srcset="/img/loading.gif" lazyload alt="网的邻接矩阵存储示例"></p>
<p>用邻接矩阵表示法来表示图，除了存储用于表示顶点间相邻关系的邻接矩阵外，通常还要用一个顺序表来存储顶点信息。</p>
<p>下面给出邻接矩阵的 C++描述：</p>
<p><img src="/images/image-20230722202704111.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>(1)有向图的邻接表存储</p>
<p>邻接表表示法类似于树的孩子链表表示法，是一种顺序结构和链式结构相结合的存储方法。对于图的每个顶点v<del>i</del>，将所有邻接于v<del>i</del>的顶点链接成一个单链表，称其为顶点v<del>i</del>的边表（对于有向图称为出边表）；对所有顶点使用顺序结构进行存储，得到顶点表，用来存放顶点v的信息和对应边表的头指针，如图所示。</p>
<p><img src="/images/image-20230722202819290.png" srcset="/img/loading.gif" lazyload alt="有向图邻接表示例"></p>
<p>所以，邻接表的存储结构中有两种结点结构：顶点结点VertexNode 和弧结点ArcNode，如图所示。</p>
<p><img src="/images/image-20230722202851916.png" srcset="/img/loading.gif" lazyload alt="邻接表结点结构"></p>
<p>邻接表顶点和弧结点的 C++描述如下：</p>
<p><img src="/images/image-20230722202915091.png" srcset="/img/loading.gif" lazyload></p>
<p>(2)无向图的邻接表存储</p>
<p>在存储无向图时，每一条边相当于两条弧，如图所示。</p>
<p><img src="/images/image-20230722202945922.png" srcset="/img/loading.gif" lazyload alt="无向图的邻接表存储"></p>
<p>(3)网的邻接表存储</p>
<p>若采用邻接表存储无向网，那么每条弧还需要存储边权值</p>
<p><img src="/images/image-20230722203039040.png" srcset="/img/loading.gif" lazyload alt="网的邻接表存储"></p>
<p>(4)有向图的逆邻接表</p>
<p>有向图还有一种表示方法称为逆邻接表表示法，该方法为图中每个顶点v<del>i</del>，建立一个入边表，入边表中的每个表结点均对应一条以v<del>i</del>为终点的边，其方法与出边表类似</p>
<p><img src="/images/image-20230722203129359.png" srcset="/img/loading.gif" lazyload alt="有向图的逆邻接表"></p>
<p>邻接表用C++语言描述如下</p>
<p><img src="/images/image-20230722203400073.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h3><p>对于有向图，可以采用十字链表作为存储结构。十字链表可以看成是将邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应有向图的每一条弧都有一个弧结点，对应有向图的每一个顶点都有一个头结点。每条弧对应的弧结点分别组织到出边表和入边表，其顶点结构如下</p>
<p><img src="/images/image-20230722203501315.png" srcset="/img/loading.gif" lazyload alt="十字链表结点结构"></p>
<p>十字链表头结点的C++描述如下</p>
<p><img src="/images/image-20230722203531717.png" srcset="/img/loading.gif" lazyload></p>
<p>十字链表弧结点的C++描述如下</p>
<p><img src="/images/image-20230722203608080.png" srcset="/img/loading.gif" lazyload></p>
<p>在十字链表中既可以很容易地找到以v<del>i</del>为弧头的弧，也可以很容易地找到以v<del>i</del>为弧尾的弧，因而容易求得每个顶点的入度和出度。因此，在某些有向图的应用中，十字链表是一个很有用的工具。如何建立十字链表教材并没有给出相关代码，需自行解决。</p>
<p>下图是一个十字链表的示例</p>
<p><img src="/images/image-20230722204048841.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h3><p>无向图可以采用邻接多重表来存储。用邻接表存储无向图，其每条边的两个顶点分别在该边所依附的两个顶点的边表中，这种重复存储给图的某些操作带来不便。例如，在对已访问过的边做标记，或者要删除图中某一条边时，都需要找到表示同一条边的两个边表结点。在进行这类操作的无向图中采用邻接多重表作为存储结构更为适宜。</p>
<p>邻接多重表的存储结构和邻接表类似，也是由顶点表和边表组成，每条边用一个边表结表示，其顶点表和边表的结点结构如下</p>
<p><img src="/images/image-20230722203816070.png" srcset="/img/loading.gif" lazyload alt="邻接多重表结点结构"></p>
<p>邻接多重表顶点表结点的C++描述如下</p>
<p><img src="/images/image-20230722203934125.png" srcset="/img/loading.gif" lazyload></p>
<p>邻接多重表边表结点C++描述如下</p>
<p><img src="/images/image-20230722204005971.png" srcset="/img/loading.gif" lazyload></p>
<p>下图是一个邻接多重表的示例</p>
<p><img src="/images/image-20230722204028087.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-5-边集数组"><a href="#2-5-边集数组" class="headerlink" title="2.5 边集数组"></a>2.5 边集数组</h3><p>图的另外一种常见的存储方法是边集数组。它利用两个一维数组，其中一个数组存储图中的顶点，另一个数组存储图中的边。在存储边的数组中，每个数组元素存储一条边的起点、终点（对于无向图，可选定边的任意一个顶点为起点）和权（网），在数组中的次序可任意安排。下图给出了一个有向网的边集数组的存储示意图。</p>
<p><img src="/images/image-20230722204200111.png" srcset="/img/loading.gif" lazyload></p>
<p>在边集数组中，查找一条边或求一个顶点的度都需要扫描整个边数组，其时间复杂度为O（e），因此适用于那些对边依次进行处理的操作，不适用于对顶点的操作和对任意一条边的操作。另外，边集数组表示一个图时需要一个边数组和一个顶点数组，所以其空间复杂度为O（n+e），从空间复杂度上讲，边集数组也适合表示稀疏图。</p>
<h2 id="3-图详解"><a href="#3-图详解" class="headerlink" title="3.图详解"></a>3.图详解</h2><h3 id="3-1-类声明-1"><a href="#3-1-类声明-1" class="headerlink" title="3.1 类声明"></a>3.1 类声明</h3><p>此处使用图的邻接表作为图的存储结构，其简单的C++类声明如下</p>
<p><img src="/images/image-20230722203400073.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-成员函数实现-1"><a href="#3-2-成员函数实现-1" class="headerlink" title="3.2 成员函数实现"></a>3.2 成员函数实现</h3><h4 id="3-2-1-图的构建"><a href="#3-2-1-图的构建" class="headerlink" title="3.2.1 图的构建"></a>3.2.1 图的构建</h4><p>假定图的所有的信息全部存储在文本文件中。文件首先存储顶点数量、边的数量，然后存储每个顶点的名字，最后存储所有的边。每条边用弧尾结点编号和弧头结点编号表示，编号从0开始顺序编号。文件中所有信息用空格或回车分开。例如，图（a）所示的有向图，对应的文件内容如图（b）所示（b中的边用数表示，01表示头结点为v<del>1</del>尾结点为v<del>2</del>的有向边，以此类推）。</p>
<p><img src="/images/image-20230722214738782.png" srcset="/img/loading.gif" lazyload alt="有向图邻接表示例"></p>
<p>该文件可用ifstream对象打开，则构造函数中需要该对象作为实参传递进来。下面给出一个用邻接表建立有向图的算法，即图的构造函数的C++描述。</p>
<p><img src="/images/image-20230722215037164.png" srcset="/img/loading.gif" lazyload></p>
<p>该算法的时间复杂度是O（n+e）。在邻接表表示中，每个边表对应于邻接矩阵的一行，边表中结点个数等于对应行非零元素的个数。对于一个具有n个顶点、e条边的图G，若G是无向图，则它的邻接表表示中有n个顶点表结点和2e个边表结点。若G是有向图，则它的邻接表表示中均有n个顶点表结点和e个边表结点。因此邻接表表示的空间复杂度为O（n+e）。</p>
<p>需要注意的是，同一个图的邻接表表示不唯一，这是因为在邻接表表示中，各边表结点的链接次序取决于建立邻接表的算法以及边的输入次序。但若采用邻接矩阵表示，则是唯一的。</p>
<h4 id="3-2-2-深度优先遍历"><a href="#3-2-2-深度优先遍历" class="headerlink" title="3.2.2 深度优先遍历"></a>3.2.2 深度优先遍历</h4><p>和树的遍历类似，图的遍历也是指从图中的某一顶点出发，对图中的每一个顶点访问且仅访问一次。若给定的图是连通图，则从图中任一顶点出发可以访问到所有顶点。然而图的遍历比树要复杂得多，这是因为图中任一顶点都可能和其他顶点邻接，故在访问了某个顶点之后，可能顺着某条回路又回到了该顶点。</p>
<p>为避免重复访问同一个顶点，必须记住每个顶点是否已被访问过。所以，图的遍历算法必须添加一个布尔向量 bool visited[n]，初始值为 FALSE，一旦访问了顶点v，则 visited[i-1]设置为TRUE。</p>
<p>根据搜索路径的方向不同，图的遍历方式有两种，即深度优先遍历和广度优先遍历。这里先介绍深度优先遍历。</p>
<p>深度优先遍历（DFS，Depth-First Search）类似于树的前序遍历，假定给定图 G的初始状态是所有顶点均未曾访问过，它的基本思想如下</p>
<p><img src="/images/image-20230722215334568.png" srcset="/img/loading.gif" lazyload></p>
<p>很显然这是一个递归的过程，对下图从v<del>1</del>开始进行深度遍历，得到的结点依次为v<del>1</del>,v<del>2</del>,v<del>3</del>,v<del>4</del>,v<del>5</del>,v<del>6</del>；若从v<del>3</del>开始进行深度遍历结点依次为v<del>3</del>,v<del>1</del>,v<del>2</del>,v<del>5</del>,v<del>6</del>,v<del>4</del>；</p>
<p><img src="/images/image-20230722215540135.png" srcset="/img/loading.gif" lazyload></p>
<p>具体的，下图展示了一个深度优先遍历访问过程中栈结构的示意</p>
<p><img src="/images/image-20230722215709855.png" srcset="/img/loading.gif" lazyload></p>
<p>无论采用哪种存储结构，深度优先遍历的思想是一致的，只是在寻找结点 v 的第一个未访问邻接点时的实现方法不同。邻接表需要根据表头结点找到出边表，然后遍历弧结点所在的链表，从而找到邻接顶点。</p>
<p>对于邻接表存储结构，从邻接表中寻找结点v 的第一个未访问邻接点的实现方法如下：</p>
<p><img src="/images/image-20230722215739085.png" srcset="/img/loading.gif" lazyload></p>
<p>值得注意的是图的邻接表表示不唯一，故对于指定的初始出发点，同一个图的遍历顺序也是不唯一的，它取决于邻接表表示中边表结点的链接次序。这里给出采用邻接表的深度优先遍历的完整 C++语言描述：</p>
<p><img src="/images/image-20230722215804258.png" srcset="/img/loading.gif" lazyload></p>
<p>基于邻接矩阵的深度优先算法和基于邻接表的深度优先算法的区别仅在于寻找第一个未访问过的邻接点时的方法不同，前者是遍历当前结点所在邻接矩阵的一行，时间复杂度是O（n）；后者是遍历以当前结点为首的单链表，由于所有结点的单链表长度之和是e，所以当用邻接表存储图时，深度优先遍历的时间复杂度均为O（n+e），使用的栈的深度为O（n），空间复杂度为O（n）。</p>
<h4 id="3-2-3-广度优先遍历"><a href="#3-2-3-广度优先遍历" class="headerlink" title="3.2.3 广度优先遍历"></a>3.2.3 广度优先遍历</h4><p>图的广度优先遍历（BFS，Breadth-First Search）类似于树的层序遍历，假定给定图G 的补始状态是所有顶点均未曾访问过，它的基本思想如下</p>
<p><img src="/images/image-20230722220016834.png" srcset="/img/loading.gif" lazyload></p>
<p>采用广度优先遍历方式访问时的结点依次为v<del>1</del>,v<del>2</del>,v<del>4</del>,v<del>3</del>,v<del>5</del>。广度优先遍历以队列来得到下一个待访问的结点，其状态如下</p>
<p><img src="/images/image-20230722220141337.png" srcset="/img/loading.gif" lazyload></p>
<p>无论采用哪种存储结构，广度优先遍历的思想是一致的，只是在寻找结点 v 的所有未访问的邻接点时的实现方法不同。</p>
<p>对于邻接表存储结构，从邻接表中寻找结点v的所有未访问的邻接点的方法如下：</p>
<p><img src="/images/image-20230722220224073.png" srcset="/img/loading.gif" lazyload></p>
<p>同样地，图的邻接表表示不唯一，故对于指定的初始出发点，同一个图的遍历顺序也是不唯一的，它取决于邻接表表示中边表结点的链接次序。这里给出采用邻接表的广度优先遍历的完整 C++语言描述：</p>
<p><img src="/images/image-20230722220316401.png" srcset="/img/loading.gif" lazyload></p>
<p>基于邻接矩阵的广度优先遍历算法和基于邻接表的广度优先遍历算法的区别仅在于寻找所有未访问过的邻接点的方法不同，前者是遍历当前结点所在邻接矩阵的一行，时间复杂度是O（n）；后者是遍历以当前结点为首的单链表，由于所有结点的单链表长度之和是e，所以当用邻接表存储图时，广度优先遍历的时间复杂度均为O（n+e），空间复杂度为O（n）。</p>
<h4 id="3-2-4-析构函数"><a href="#3-2-4-析构函数" class="headerlink" title="3.2.4 析构函数"></a>3.2.4 析构函数</h4><p>基于邻接矩阵的图类MGraph，由于图的顶点集合和弧集合都是提前定义好的数组，因此不需要析构。而基于邻接表的图类 ALGraph，其边集是存储在链表中的，因此需要析构。</p>
<p>析构的方法可以利用广度优先遍历的思想。代码如下：</p>
<p><img src="/images/image-20230722220550680.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-关键路径"><a href="#4-关键路径" class="headerlink" title="4.关键路径"></a>4.关键路径</h2><ul>
<li>参考文章：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15069443/4525855">关键路径算法相关概念解读_51CTO博客_关键路径 算法</a>；</li>
</ul>
<p>关键路径也称为最长路径，与最短路径相对，但不能借鉴最短路径的两种算法思想（因为关键路径中顶点还有前提）。在关键路径算法中，将事件定义为AOE图中的“顶点”，将活动定义为AOE图中的“弧”。需要注意辨别以下两个名词与动词之间的搭配：</p>
<ul>
<li>“发生”是针对于事件的，也就是图中的顶点。只有在指向该顶点的所有有向边对应的活动结束，该顶点所代表的事件才发生。举个例子，一个事件C，它仅被两条边a, b指向，仅当a，b两活动都完成时，事件C发生。</li>
<li>“开始”是针对于活动的，也就是图中的弧。只有在一个顶点所代表的事件发生后，从该顶点出发的所有边对应的活动才能开始。什么时候开始？即可以在事件一完成就立马开始接下来的活动，也可以推迟活动开始的时间。</li>
</ul>
<p>详细的这部分内容直接参考天勤书解答的很详细，本部分算法只要求掌握手工求解最长路径对代码部分并没有要求。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%80%83%E7%A0%94/" class="category-chain-item">考研</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">#数据结构设计</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">#算法分析</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>考研_专业课_数据结构</div>
      <div>https://gintoki-jpg.github.io/2023/07/12/考研_专业课_数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>杨再俨</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月12日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/17/%E8%80%83%E7%A0%94_%E8%8B%B1%E8%AF%AD%E4%B8%80_%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/" title="考研_英语一_解题技巧">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">考研_英语一_解题技巧</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/07/%E8%80%83%E7%A0%94_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" title="考研_数学公式">
                        <span class="hidden-mobile">考研_数学公式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  

</div>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>







  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
