

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/logo.png">
  <link rel="icon" href="/img/bg/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="杨再俨">
  <meta name="keywords" content="">
  
    <meta name="description" content="主要整理经典算法题目并记录解题思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法刷题">
<meta property="og:url" content="https://gintoki-jpg.github.io/2022/06/27/%E5%85%B6%E4%BB%96_%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="Tintoki_blog">
<meta property="og:description" content="主要整理经典算法题目并记录解题思路。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gintoki-jpg.github.io/img/bg/num.png">
<meta property="article:published_time" content="2022-06-27T03:40:00.000Z">
<meta property="article:modified_time" content="2023-03-01T14:56:20.609Z">
<meta property="article:author" content="YangZaiyan">
<meta property="article:tag" content="刷题">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gintoki-jpg.github.io/img/bg/num.png">
  
  
  
  <title>算法刷题 - Tintoki_blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gintoki-jpg.github.io","root":"/","version":"1.9.1","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tintoki_blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">算法刷题</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-27 11:40" pubdate>
          2022年6月27日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          59k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          495 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法刷题</h1>
            
            <div class="markdown-body">
              
              <p>这里博客中我们主要总结力扣上一些经典的算法题目，参考网站<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>注意这里我们的分类不是严格按照基本数据结构来分类的，而是按照力扣算法题的共性总结，可能是使用了某种共同的数据结构、解题思想或某种共同的算法；</p>
<hr>
<p>2023&#x2F;2&#x2F;20 8:28 刷题这部分暂时也搁置一段时间，主要是这个东西只需要在短时间内大量刷题就可以，而对于考研来说现阶段刷题的收益太低了，现阶段几乎用不到这些算法相关的知识点；</p>
<hr>
<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="0-数组概述"><a href="#0-数组概述" class="headerlink" title="0.数组概述"></a>0.数组概述</h2><blockquote>
<ul>
<li><p>数组是存放在连续内存空间上的相同类型的数据的集合；</p>
</li>
<li><p>因为数组在内存空间的地址是连续的，所以针对数组不能删除某元素只能覆盖某元素；</p>
</li>
</ul>
</blockquote>
<p>一维数组<img src="/images/image-20220705085743151.png" srcset="/img/loading.gif" lazyload></p>
<p>二维数组<img src="/images/image-20220705085826800.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><p>题目要求：</p>
<p><img src="/images/image-20220704082530804.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>本题可以直接暴力遍历数组，以查找数组中不重复的某个元素（由假设得来）；</p>
<p>但是直接使用暴力遍历会导致时间复杂度极高，题干中出现关键词“有序”“不重复元素”，可以考虑使用二分法；</p>
<p>使用二分法要注意原始区间是双闭还是半闭半开，这将影响判断条件的书写；</p>
</blockquote>
<p>解题思路1：</p>
<p><img src="/images/image-20220704084647270.png" srcset="/img/loading.gif" lazyload></p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[middle + 1, right]</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>解题思路2：</p>
<p><img src="/images/image-20220704084703328.png" srcset="/img/loading.gif" lazyload></p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 定义target在左闭右开的区间里，即：[left, right)</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle; <span class="hljs-comment">// target 在左区间，在[left, middle)中</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在[middle + 1, right)中</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h2><p>题目要求：</p>
<p><img src="/images/image-20220704085005077.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20220704085029658.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>这道题直接看示例很容易把人搞晕不知道该干什么，实际上就是一个简单的删除数组中所有值等于val的元素并返回最终数组的大小；</p>
<p>因为数组内存空间连续，只能使用后面的元素将前面的元素覆盖，所以我们有两种解题思路；</p>
<p>一种是使用两层for循环，第一个循环遍历数组元素，第二个循环用于更新数组，时间复杂度为O(n^2)；</p>
<p>第二种是使用双指针，通过一个快指针一个慢指针，在一层for循环中完成两层for循环的工作；</p>
</blockquote>
<p>思路1实现代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 时间复杂度：O(n^2)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == val) &#123; <span class="hljs-comment">// 发现需要移除的元素，就将数组中该元素以后的部分集体向前移动一位</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; j++) &#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                i--; <span class="hljs-comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位（这里如果不处理i会导致下一次直接处理i+2忽略i+1）</span><br>                size--; <span class="hljs-comment">// 此时数组的大小-1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>解题思路2：</p>
<blockquote>
<p>首先我们需要定义快慢指针的含义（其实这里的指针并不是严格意义上的指针，只能说是一个数组元素位置标记）：</p>
<ul>
<li>快指针：遍历原数组，寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：更新新数组元素</li>
</ul>
</blockquote>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 时间复杂度：O(n)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (val != nums[fastIndex]) &#123;<br>                nums[slowIndex++] = nums[fastIndex];<span class="hljs-comment">//这里是本题的核心所在，简单来说就是使用slowIndex创建了一个新的数组，该数组只保存fastIndex数组中与val值不同的数值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h2><p>题目要求：</p>
<p><img src="/images/image-20220704092459647.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>这道题有一个很容易忽略的点，假如原数组只有正数则直接遍历并返回平方即可，但是原数组是可以有负数的；</p>
<p>本题同样有两种解法，一种是使用单层for循环返回原数组的平方，接着再对返回的数进行排序（自己写函数或者直接调用sort()函数都可以）；</p>
<p>第二种是使用双指针（注意这里的双指针是头尾指针，与前面使用的快慢指针有一定区别）；</p>
</blockquote>
<p>思路1代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//时间复杂度是 O(n + nlogn)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            A[i] *= A[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 快速排序，默认升序排序</span><br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>思路2：</p>
<blockquote>
<p>尽管数组中有负数，但是原数组因为是有序的，所以平方后得到的较大值在原数组中要么就是靠左要么靠右；</p>
</blockquote>
<p><img src="/images/image-20220704093646806.png" srcset="/img/loading.gif" lazyload></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//时间复杂度为O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(A.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= j;) &#123; <span class="hljs-comment">// 注意这里要i &lt;= j，因为最后要处理两个元素</span><br>            <span class="hljs-keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j])  &#123;<br>                result[k--] = A[j] * A[j];<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result[k--] = A[i] * A[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="4-长度最小的子数组"><a href="#4-长度最小的子数组" class="headerlink" title="4.长度最小的子数组"></a>4.长度最小的子数组</h2><p><img src="/images/image-20220704093835769.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>这道题同样也是题干就很容易让人混淆，究竟是什么意思？</p>
<p>翻译过来就是给定一个target，我们需要在原数组中寻找元素使其和大于等于target，我们使用的这些元素将会构成一个新的数组，要求该数组的长度最小；</p>
<p>这道题同样有两种解法，一种是使用暴力双循环，外循环用于确定子序列起点i，内循环用于确定子序列的终点j；</p>
<p>第二种解法是使用滑动窗口，本质上也是双指针；                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </p>
</blockquote>
<p>思路1代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//时间复杂度：O(n^2)</span><br><span class="hljs-comment">//空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) &#123; <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break，注意break仅是退出当前for循环</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>思路2：</p>
<blockquote>
<p>滑动窗口：不断调整子序列的起始位置和终止位置（其实和上面设置起始位置i和终止位置j相同，但是只用了一个for循环）</p>
<p>使用滑动窗口需要解决下面的几个问题</p>
<ul>
<li>窗口内是什么？——窗口内是满足其和 ≥s 的长度最小的连续子数组</li>
<li>如何移动窗口的起始位置？——如果当前窗口的值大于s了，窗口就要向后移动了（也就是该缩小了）</li>
<li>如何移动窗口的结束位置？——窗口的结束位置就是遍历数组的指针，也就是for循环里的索引值i</li>
</ul>
<p>因此使用滑动窗口的关键在于 如何移动窗口的起始位置</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件（即窗口内的值是否大于等于s）</span><br>            <span class="hljs-comment">//只要窗口内的值大于等于s,则比较子序列的长度，取长度较小者作为最新的result</span><br>            <span class="hljs-comment">//尽管此处使用了while循环，但是它只是作为一个条件偶尔执行，所以和for循环比起来可以不算复杂度</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（即子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="5-螺旋矩阵"><a href="#5-螺旋矩阵" class="headerlink" title="5.螺旋矩阵"></a>5.螺旋矩阵</h2><p><img src="/images/image-20220704102601003.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>首先这道题其实就是考察我们对二维数组&#x2F;矩阵的掌握程度，</p>
<ul>
<li>二维数组&#x2F;矩阵是以数组作为数组元素的数组；</li>
<li>二维数组第一个参数是行，第二个参数是列，先按照行排再按照列排，即数Aij位于矩阵的第i行第j列；</li>
</ul>
<p>第二个考察点是在画矩阵的时候需要按照顺序，不要想到哪里画哪里</p>
<ul>
<li><p>由外向内构建二维矩阵</p>
</li>
<li><p>填充上行从左到右</p>
</li>
<li><p>填充右列从上到下</p>
</li>
<li><p>填充下行从右到左</p>
</li>
<li><p>填充左列从下到上</p>
</li>
</ul>
<p>第三点是每一条边都要遵守某个相同的规则</p>
<ul>
<li>按照左闭右开构建每一条边</li>
</ul>
<p><img src="/images/image-20220704103617858.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 使用vector定义一个二维数组</span><br>        <span class="hljs-type">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义每循环一个圈的起始位置</span><br>        <span class="hljs-type">int</span> loop = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只循环构造一圈，矩阵中间的值需要单独处理不作为圈构造 </span><br>        <span class="hljs-type">int</span> mid = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来给矩阵中每一个空格赋值</span><br>        <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span><br>        <span class="hljs-type">int</span> i,j;<br>        <span class="hljs-keyword">while</span> (loop --) &#123;<br>            i = startx;<br>            j = starty; <br><br>            <span class="hljs-comment">// 下面开始的四个for就是模拟转了一圈</span><br>            <span class="hljs-comment">// 模拟填充上行从左到右(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;<br>                res[startx][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 模拟填充右列从上到下(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;<br>                res[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 模拟填充下行从右到左(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (; j &gt; starty; j--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 模拟填充左列从下到上(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (; i &gt; startx; i--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span><br>            startx++;<br>            starty++;<br><br>            <span class="hljs-comment">// offset 控制每一圈里每一条边遍历的长度</span><br>            offset += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            res[mid][mid] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="0-链表概述"><a href="#0-链表概述" class="headerlink" title="0.链表概述"></a>0.链表概述</h2><p>链表这一章仔细看看，能够提升对C++指针概念的理解</p>
<blockquote>
<p>链表是通过指针串联在一起的节点的线性集合；</p>
<p>每个节点由两部分组成，数据域用于存放数据，指针域用于存放指向下一个节点的指针（最后一个节点的指针域为NULL）</p>
</blockquote>
<p>单链表<img src="/images/image-20220705090117890.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意区分头指针和头节点的概念</p>
<ul>
<li>头指针指向链表的第一个结点，若存在头结点则指向头结点，若不存在头节点则指向第一个结点；</li>
<li>头节点的数据域一般不存数据（也可以存储表长等数据），头节点不一定是链表必须要的元素（引入头节点为了方便单链表的特殊操作,保证在表头插入或者删除第一个结点与其他结点操作相同.保持了单链表操作的统一性）；</li>
<li>常用头指针冠以链表的名字，头指针是链表的必要元素；</li>
</ul>
</blockquote>
<p>双链表（每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点；双链表既可以向前查询也可以向后查询）</p>
<p><img src="/images/image-20220705090645334.png" srcset="/img/loading.gif" lazyload></p>
<p>循环链表<img src="/images/image-20220705090709409.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1.移除链表元素"></a>1.移除链表元素</h2><p><img src="/images/image-20220705091135505.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这道题本质上非常简单，就是考察单链表的删除操作；</p>
<p>需要注意的是，因为力扣直接给出了单链表的定义，但是这个单链表是不包含头节点的，需要我们在处理的时候增加一个头节点；</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点，数据域为0，由dummyHead指针指着（此时dummyHead指针指向虚拟头节点，头指针head指向第一个节点）</span><br>        dummyHead-&gt;next = head; 			  <span class="hljs-comment">// 令虚拟头结点的指针域指向head，这样对后面结点的操作都统一</span><br>        ListNode* cur = dummyHead;			  <span class="hljs-comment">// 令寻址指针初始指向虚拟头节点，注意不是头指针，头指针不能移动</span><br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">NULL</span>) &#123;			  <br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val) &#123;			<span class="hljs-comment">// 当寻址指针指向的下一个节点的数据域是需要删除的val值时，进行删除操作</span><br>                ListNode* tmp = cur-&gt;next;		<span class="hljs-comment">// 首先使用临时指针tmp指向待删除节点（如果不保存则下一步拆断联系后就找不到这个节点了，也就无法回收）</span><br>                cur-&gt;next = cur-&gt;next-&gt;next;	<span class="hljs-comment">// 拆断原有联系</span><br>                <span class="hljs-keyword">delete</span> tmp;					   <span class="hljs-comment">// 删除无用节点，养成内存回收机制的好习惯</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        head = dummyHead-&gt;next;				<span class="hljs-comment">//为了避免第一个节点被删除后head没有指向的问题，最后需要重新给head赋值</span><br>        <span class="hljs-keyword">delete</span> dummyHead;					<span class="hljs-comment">//最后返回结果之前我们还需要手动将增加的虚拟头节点删除</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="2-设计链表"><a href="#2-设计链表" class="headerlink" title="2.设计链表"></a>2.设计链表</h2><p><img src="/images/image-20220705093337483.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>可能刚开始看到这个题会很疑惑，不是说leecode不是已经帮我们定义了链表吗？怎么这里又让我们自己去设计？</p>
<p>其实这是leecode刷题这种模式的特点，它不像牛客所有的题都让你从0开始写，很多题目leecode是直接帮你调用了STL或者默认帮你实现了数据结构，只需要额外定义一个solution类来解决题目中的问题即可；</p>
<p>但是这道题的话就有点0基础使用链表定义来设计并实现具有特定功能的链表了；</p>
<p>这个题也非常简单非常基础，有利于理解链表的知识框架，我们直接给出代码和注释即可；</p>
</blockquote>
<p>代码如下（虚拟头节点版本）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义链表节点结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> val;									<span class="hljs-comment">//数据域</span><br>        LinkedNode* next;							<span class="hljs-comment">//指针域</span><br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;  <span class="hljs-comment">//自定义节点构造函数（如果使用默认构造函数在初始化节点时不能直接给节点的数据域赋值）</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 初始化链表</span><br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        _dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); 			<span class="hljs-comment">// 这里定义的头结点是一个虚拟头结点（数据域存0），而不是真正的链表头结点（习惯上称为第一个节点）</span><br>        _size = <span class="hljs-number">0</span>;								  <span class="hljs-comment">//初始化链表大小为0（虚拟头节点不算size）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是第一个节点（而非虚拟节点）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        LinkedNode* cur = _dummyHead-&gt;next;			<span class="hljs-comment">//令寻址指针从第一个节点（而非虚拟头节点）开始</span><br>        <span class="hljs-keyword">while</span>(index--)&#123; 						   <span class="hljs-comment">// 如果--index 就会陷入死循环（index为0导致无限循环，因为非0即真while会一直执行下去）</span><br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);	<span class="hljs-comment">//创建一个新的节点，使用newNode指针指向该新节点</span><br>        newNode-&gt;next = _dummyHead-&gt;next;		   <span class="hljs-comment">//添加节点的操作，不用太在意顺序，只要不搞丢要添加或者删除的节点就行</span><br>        _dummyHead-&gt;next = newNode;				  <span class="hljs-comment">//令虚拟头节点指向新的第一个节点</span><br>        _size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表最后面添加一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = newNode;					<span class="hljs-comment">//最后一个节点直接在末尾添加就可以，不用考虑它后面再连接哪个节点</span><br>        _size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span><br>    <span class="hljs-comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span><br>    <span class="hljs-comment">// 如果index大于链表的长度，则返回空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; _size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        newNode-&gt;next = cur-&gt;next;<br>        cur-&gt;next = newNode;<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            cur = cur -&gt;next;<br>        &#125;<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        _size--;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//私有变量</span><br>    <span class="hljs-type">int</span> _size;							<span class="hljs-comment">//size表示链表的大小</span><br>    LinkedNode* _dummyHead;				<span class="hljs-comment">//用头指针冠以链表的名字</span><br><br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3.反转链表"></a>3.反转链表</h2><p><img src="/images/image-20220707101621250.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>反转链表这种题，实际上就是改变了next指针的指向，同时将第一个节点和最后一个节点互换；</p>
<p>解题使用双指针，第一个cur指针用于从前到后遍历链表的每个节点，第二个pre指针用于创建新的链表（本质上并没有使用额外空间，仅仅只是改变了next指针的指向而已）</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp; 		<span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;	<span class="hljs-comment">//cur指针从head指向的结点开始，这里没有虚拟头节点故head指向第一个节点</span><br>        ListNode* pre = <span class="hljs-literal">NULL</span>;	<span class="hljs-comment">//pre指针开始指向NULL，用于构建新的链表</span><br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre;   <span class="hljs-comment">// 翻转操作，第一轮时pre指向NULL，cur指向第一个节点，cur-&gt;next=pre意味着让第一个节点指向NULL</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针，pre移动到第一个节点，cur移动到下一个节点</span><br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;			<span class="hljs-comment">//最终当cur==NULL的时候，pre刚好移动到最后一个节点，也就是反转过后的第一个节点，此时返回pre也就返回了反转过后的链表（此处涉及C++特性，和数组类似）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="4-交换链表节点"><a href="#4-交换链表节点" class="headerlink" title="4.交换链表节点"></a>4.交换链表节点</h2><p><img src="/images/image-20220707103150488.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>leecode的题总是能够让你读的半懵半懵的，实际上就是交换相邻的两个节点（交换过后的节点不再交换）——所以如果节点个数是奇数怎么办？？？假如是单数的话默认最后一个节点没得交换；</p>
<p>注意这个是单向链表，只能操作其next指针，所以需要注意交换的步骤</p>
<p>具体交换过程主要分为三个步骤（这里需要引入虚拟头节点，我们假设涉及交换的节点分别为cur，1，2，3，其中要交换的节点是1，2）</p>
<ul>
<li>cur-&gt;next&#x3D;2</li>
<li>2-&gt;next&#x3D;1</li>
<li>1-&gt;next&#x3D;3</li>
</ul>
</blockquote>
<p><img src="/images/image-20220707104121887.png" srcset="/img/loading.gif" lazyload></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//时间复杂度O(n)</span><br><span class="hljs-comment">//空间复杂度O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头节点，方便统一处理第一个节点</span><br>        dummyHead-&gt;next = head; 			  <span class="hljs-comment">// 将虚拟头结点指向head</span><br>        ListNode* cur = dummyHead;			  <span class="hljs-comment">//初始时，遍历指针cur处于虚拟头节点位置</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* tmp = cur-&gt;next; 		  <span class="hljs-comment">// 记录临时节点，也就是1，因为cur指向2后就只能靠tmp找到1了</span><br>            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="hljs-comment">// 记录临时节点，也就是3，因为2指向1后就只能靠tmp1找到3了</span><br><br>            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="hljs-comment">// 步骤一，cur-&gt;next=2</span><br>            cur-&gt;next-&gt;next = tmp;          <span class="hljs-comment">// 步骤二，2-&gt;next=1</span><br>            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="hljs-comment">// 步骤三，1-&gt;next=3</span><br><br>            cur = cur-&gt;next-&gt;next; <span class="hljs-comment">// cur指针在交换过后的基础上移动两位，准备下一轮交换（第一轮后cur移动到2），当是单数的时候因为不符合cur-&gt;next-&gt;next != nullptr条件所以直接结束</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;	<span class="hljs-comment">//返回第一个节点，注意虚拟头节点是手动增加的所以不要返回</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="5-删除链表倒数第n个节点"><a href="#5-删除链表倒数第n个节点" class="headerlink" title="5.删除链表倒数第n个节点"></a>5.删除链表倒数第n个节点</h2><p><img src="/images/image-20220711082146252.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>这个题感觉很简单啊，直接找到并删除倒数第n个节点即可；</p>
<p>所以这道题是中等难度的原因就在于，找到倒数第n个节点在链表中是一件不容易的事；</p>
<p>这道题使用双指针可以快速解决——如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾NULL，删掉slow所指向的节点就可以了</p>
<p>细节：</p>
<ul>
<li>定义虚拟头节点且fast和slow初值均指向虚拟头节点；</li>
<li>slow指针在fast指针指向NULL的时候，slow指针是指向要删除的节点的前一个节点而非要删除的节点（否则没办法进行删除操作）；</li>
<li>删除的节点是slow指针指向的节点的下一个节点；</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//定义虚拟头节点</span><br>        dummyHead-&gt;next = head;                 <span class="hljs-comment">//将虚拟头节点加入链表中</span><br>        ListNode* slow = dummyHead;			   <span class="hljs-comment">//初始slow和fast均指向虚拟头节点</span><br>        ListNode* fast = dummyHead;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) &#123;		   <span class="hljs-comment">//先移动fast指针，fast != NULL是为了防止用户输入大于链表长度的n导致程序错误</span><br>            fast = fast-&gt;next;<br>        &#125;<br>        fast = fast-&gt;next; 					  <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) &#123;				  <span class="hljs-comment">//fast和slow同时移动，直到fast指向NULL（这道题细节很多，注意画图理解）</span><br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next;		  <span class="hljs-comment">//直接暴力改指向，回收甚至都不使用，这样做可能导致算法内存比较大；</span><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="6-环形链表1"><a href="#6-环形链表1" class="headerlink" title="6.环形链表1"></a>6.环形链表1</h2><p><img src="/images/image-20220711083400787.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/image-20220711083421493.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这道题不是直接根据输入的skip就写出来了吗…还是说是我读题理解有问题？</p>
<p>这道题的举例是有问题的，我们定义的Solution类中的方法仅仅只有两个参数，即传入链表A和链表B，而相交节点的值明显是一个误导信息，因为链表中节点相同实质上是指向节点的指针的地址相同而不是节点存储的值相同，另外，skip这个条件属于是作弊条件，我要是都知道相交节点在距离头节点多远的位置，为什么我不直接跳过去呢？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* curA = headA;	<span class="hljs-comment">//初始curA指针指向A链表头节点</span><br>        ListNode* curB = headB; <span class="hljs-comment">//初始curB指针指向B链表头节点</span><br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB-&gt;next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;		<span class="hljs-comment">//求完长度之后重新调整curA和curB的指向</span><br>        <span class="hljs-comment">// 让curA指向长链表的头节点，len(长链表)为该链表长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) &#123;<br>            <span class="hljs-built_in">swap</span> (lenA, lenB);<br>            <span class="hljs-built_in">swap</span> (curA, curB);<br>        &#125;<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap--) &#123;<br>            curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curA == curB) &#123;<br>                <span class="hljs-keyword">return</span> curA;<span class="hljs-comment">//如果指针相同则返回此时的指针即可</span><br>            &#125;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//如果永远都没有相同的指针则返回NULL</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="7-环形链表2"><a href="#7-环形链表2" class="headerlink" title="7.环形链表2"></a>7.环形链表2</h2><p><img src="/images/image-20220711090656787.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这道题乍一看挺吓人的，找到环形的入口，这让人如何是好？实际上这道题主要有两个考点：</p>
<ul>
<li>判断链表是否有环；</li>
<li>若存在环，如何找到这个环的入口；</li>
</ul>
</blockquote>
<blockquote>
<p>判断链表是否有环可以使用双指针，fast每次移动2步，slow每次移动1步，如果有环则fast和slow一定会相交并且是在环内相交</p>
</blockquote>
<blockquote>
<p>如果链表有环，</p>
<p>参考题解：刘翔以老八2倍的速度和老八从头开始跑，直到和老八相遇，很疑惑：哦原来有环啊？ </p>
<p>老八也很疑惑，那么什么是哪个点出现的环啊？ </p>
<p>刘翔说：忘记了，我只知道我跑的路程是你的两倍，而且我已经比你这个乌龟多跑一圈了，不然怎么可能抓到你。 </p>
<p>老八说：杀千刀的，那假设那个点前距离是a好了，我现在跑了a+b了，你比我多一圈那就是2(a+b) 那 2(a+b)&#x3D;&#x3D;a+c(c是圈的长度)+b 得出a+b&#x3D;c。</p>
<p>刘翔：哦那简单啊，那你现在距离那个点已经b了，再跑a个点不就到那里了嘛。</p>
<p>老八生气的说： 我他niang的怎么知道a是多少？求的就是a啊大哥！</p>
<p>刘翔邪魅一笑：那简单啊，我现在叫我朋友博尔特从起点和你一个速度跑，你们都差a 就到了，相遇了就是答案了哇。 </p>
<p>老八： 呵呵。算你狠。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode root=head;<span class="hljs-comment">//博尔特</span><br>        ListNode left=head;<span class="hljs-comment">//老八</span><br>        ListNode right=head;<span class="hljs-comment">//刘翔</span><br>        <span class="hljs-keyword">while</span>(right!=null &amp;&amp; right.next!=null)&#123;<br>           right=right.next.next;<span class="hljs-comment">//刘翔两倍速</span><br>           left=left.next;		<span class="hljs-comment">//老八一倍速</span><br>           <span class="hljs-keyword">if</span>(left==right)&#123;<br>               <span class="hljs-keyword">while</span>(root!=right)&#123;<span class="hljs-comment">//当刘翔和老八相遇，博尔特开始以一倍速跑步</span><br>                   root=root.next;<br>                   right=right.next;<br>               &#125;<br>               <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//要是root==right说明环入口就在第一个节点</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> null;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="0-哈希表概述"><a href="#0-哈希表概述" class="headerlink" title="0.哈希表概述"></a>0.哈希表概述</h2><p>hash table即哈希表、散列表，一般用来快速判断一个元素是否出现在集合里；</p>
<blockquote>
<p>哈希表是根据关键码的值直接进行访问的数据结构；</p>
</blockquote>
<p>数组就是一张哈希表，哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素；</p>
<p><img src="/images/image-20220712095046278.png" srcset="/img/loading.gif" lazyload></p>
<p>哈希表上的映射函数也称为哈希函数，下面展示了一个将学生姓名映射到哈希表上的hash function；</p>
<p><img src="/images/image-20220712095516062.png" srcset="/img/loading.gif" lazyload></p>
<p>使用哈希函数涉及模运算，这可能导致小王和小张在哈希表的同一个索引下标的位置进而发生冲突，这就叫做哈希碰撞；</p>
<p>一般哈希碰撞有两种解决方法，拉链法和线性探测法；</p>
<blockquote>
<p>拉链法是指将发生冲突的元素都存储在链表中；</p>
</blockquote>
<p><img src="/images/image-20220712095946318.png" srcset="/img/loading.gif" lazyload></p>
<p>拉链法就是要选择适当的哈希表的大小，这样既不会因为哈希表空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间；</p>
<blockquote>
<p>使用线性探测法，一定要保证哈希表大小tableSize大于数据规模dataSize，我们需要依靠哈希表中的空位来解决碰撞问题；</p>
</blockquote>
<p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了</p>
<p><img src="/images/image-20220712100252040.png" srcset="/img/loading.gif" lazyload></p>
<p>上面我们介绍了哈希表的基本概念（这个在数据结构的笔记里没有专门的介绍，感兴趣可以再查资料学习），当我们需要使用<code>哈希算法</code>解决问题通常涉及如下三种数据结构：</p>
<ul>
<li>数组</li>
<li>集合</li>
<li>映射</li>
</ul>
<p>STL为集合set提供了以下三种数据结构</p>
<blockquote>
<p>红黑树是一种平衡二叉搜索树，所有key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加</p>
</blockquote>
<p><img src="/images/image-20220712100634088.png" srcset="/img/loading.gif" lazyload></p>
<p>STL为映射map提供了以下三种数据结构</p>
<p><img src="/images/image-20220712100745347.png" srcset="/img/loading.gif" lazyload></p>
<p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p>
<blockquote>
<p>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法；</p>
<p>但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找；</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法；</p>
</blockquote>
<hr>
<p>红黑树是一种自平衡二叉查找树，是一种接近平衡的二叉搜索树，它能够保证任意一个节点左右子树的高度差不会超过较低子树的高度；</p>
<h2 id="1-有效字母异位词"><a href="#1-有效字母异位词" class="headerlink" title="1.有效字母异位词"></a>1.有效字母异位词</h2><p><img src="/images/image-20220905092901161.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>首先要知道什么是字母异位词，实际上就是两个单词包含相同的字母但是字母的次序不同如”anagram” 和 “nagaram”；</p>
<p>暴力解法本质上就是两层for循环并记录出现的字符是否重复，时间复杂度为O(n^2^)；</p>
<p>第二种解法使用数组，数组是一个哈希表，因为这题的本质就是判断元素是否出现在集合中（可以使用两个集合互相比较，也可以使用一个集合加减判断），所以我们考虑哈希表；</p>
<p>因为题目说只需要考虑小写字母，故数组的大小设置为26，字母a映射在数组下标0，字母z映射在数组下标25，数组record用于记录字符串s和t中字符出现的次数，s中出现的字符对应在数组中+1，t中出现的字符对应在数组中-1，最后检查record数组中如果存在元素不为0则reurn false，该方法时间复杂度为O(n)，空间复杂度为O(1)；</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;				<span class="hljs-comment">//初始化record数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 此处非常巧妙的利用了a作为26个小写字母起始字符的特点，因此s[i]或者t[i]如果是&#x27;a&#x27;则&#x27;a&#x27;-&#x27;a&#x27;会得到0也就刚好映射在record数组的第一个位置</span><br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 假如record数组存在元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-两个数组的交集"><a href="#2-两个数组的交集" class="headerlink" title="2.两个数组的交集"></a>2.两个数组的交集</h2><p><img src="/images/image-20220906200348036.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>这道题本质上也就是需要判断某个元素是否出现在集合中，因此我们选择考虑哈希表；</p>
<p>当然这道题可以使用暴力for循环，其时间复杂度为O(n^2^)；</p>
<p>前面使用了数组作为哈希表，但需要注意这样的前提是题目已经限制了数组的大小，而且如果哈希值较少、分散且跨度很大使用数组会造成浪费；</p>
<p>我们这里考虑使用set结构体作为哈希表，关于set，C++提供了三种可用的数据结构：</p>
<ul>
<li>std::set</li>
<li>std::multiset</li>
<li>std::unordered_set</li>
</ul>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表，更多关于set容器的介绍可以参考<a href="https://gintoki-jpg.github.io/2022/07/08/CPP_STL%E5%88%9D%E7%BA%A7/#3-set%E5%AE%B9%E5%99%A8">STL初级 - Tintoki_blog (gintoki-jpg.github.io)</a></p>
<p>set 容器具有以下几个特性：</p>
<ul>
<li>不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；</li>
<li>set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；</li>
<li>存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；</li>
<li>set 容器存储的元素必须互不相等；</li>
</ul>
<p>我们很容易看出set容器恰好符合题干的要求，这里综合考虑最终选择unordered_set</p>
</blockquote>
<p>set容器代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放最终结果，用set容器是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 假如发现nums2的元素在nums_set中没有出现过，则insert该num</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>数组代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放最终结果，之所以用set是为了给结果集去重，注意这里使用的是两个数据结构，所以一个使用set一个使用数组</span><br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">1005</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 默认数值为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123; <span class="hljs-comment">// nums1中出现的字母在hash数组中做记录，这里直接用字母对应的ASCLL作为数组索引</span><br>            hash[num] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123; <span class="hljs-comment">// 假如num2中出现相同的字母则将该字母insert进最终结果集中</span><br>            <span class="hljs-keyword">if</span> (hash[num] == <span class="hljs-number">1</span>) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3-快乐数"><a href="#3-快乐数" class="headerlink" title="3.快乐数"></a>3.快乐数</h2><p>题目链接<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p>
<p>快乐数被定义为</p>
<ul>
<li><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和；</p>
</li>
<li><p>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1；</p>
</li>
<li><p>如果这个过程 结果为 1，那么这个数就是快乐数；</p>
</li>
</ul>
<p><img src="/images/image-20220908085220431.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>“需要快速判断一个元素是否出现在集合中，考虑哈希法”，本题采用哈希法快速判断sum平方和是否重复出现，如果sum重复出现代表一定是无限循环，则return false，否则需要一直计算sum直到sum为1；</p>
<p>因为需要判断sum是否重复出现，也就是集合中重复元素的判断，因此这里使用unordered_set而非数组；</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 1.定义取数值各个位上的单数平方和函数，比如n是101，则n依次赋值为101,10,1,0因此会进行三次循环，对应n是一个三位数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-comment">/*除法运算用作判断数值的位数，取模运算用作判断数值的每一位</span><br><span class="hljs-comment">            *n依次被赋值为101，10，1，对应取模运算得到的值依次是1,0,1符合数值的每一位</span><br><span class="hljs-comment">            */</span><br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            <span class="hljs-comment">/*“/=”属于复合赋值运算符中的一种，把左边的变量除以右边变量的值赋予左边的变量，如a/=b等价于a=a/b</span><br><span class="hljs-comment">            *C++中除法的运算规则是强制类型转换，如果两个操作数中有一个为浮点型，则结果为浮点，如果两个均为整型，则为整除（int a = 5、int b = 2，则a/b的值为2（整除），而用(double)a/b			  *的值则为2.5）</span><br><span class="hljs-comment">            */</span><br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-comment">//只要sum不是循环，就一直求解下去</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false，此处调用了set的find方法，如果sum已经在set中出现过则返回的两个迭代器指向的位置不会一致</span><br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果sum没出现过则直接insert在最后即可</span><br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            &#125;<br>            n = sum;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4-两数之和"><a href="#4-两数之和" class="headerlink" title="4.两数之和"></a>4.两数之和</h2><p><img src="/images/image-20220908092230853.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析：</p>
<p>这道题很眼熟…因该是之前在哪里做过？或者其实数组那一节的第四题有点类似；</p>
<p>什么时候使用哈希法 —— 需要查询一个元素是否出现过，或者一个元素是否在集合里的时候</p>
<p>本题题意为使用一个集合存放我们遍历过的元素，然后在遍历数组的时候去访问这个集合（如果觉得绕的话可以看了代码解析再回头理解这句话）</p>
<p>本题采用map的key value结构分别存放元素以及该元素对应的下标，之所以不选择数组和set是因为</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费；</li>
<li>set是一个集合，里面放的元素只能是一个key，而本题不仅要判断y是否存在而且还要记录y的下标位置，所以set 也不能用；</li>
</ul>
<p>C++提供了三种map的数据类型</p>
</blockquote>
<p><img src="/images/image-20220908093249743.png" srcset="/img/loading.gif" lazyload></p>
<p>基本原理图如下</p>
<p><img src="/images/image-20220908093657510.png" srcset="/img/loading.gif" lazyload></p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;				<span class="hljs-comment">//用于存放遍历过的元素的map</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;			<span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key，至于为什么不是我们以为的value，是因为map.find查找的是key的位置</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;					   <span class="hljs-comment">//假如在map中找到匹配的value则返回其key和value</span><br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); 	<span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="5-四数相加"><a href="#5-四数相加" class="headerlink" title="5.四数相加"></a>5.四数相加</h2><p><img src="/images/image-20221024081958131.png" srcset="/img/loading.gif" lazyload></p>
<p>这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] &#x3D; 0就可以，不用考虑有重复的四个元素相加等于0的情况；（这道题和只给出一个数组并找出四个元素相加等于0相比的难度较小）</p>
<blockquote>
<p>解析：（看不懂很正常，结合代码理解）</p>
<ol>
<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数；</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中；</li>
<li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数；</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来；</li>
<li>最后返回统计值 count 就可以了；</li>
</ol>
</blockquote>
<p><img src="/images/image-20221024083451692.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C, vector&lt;<span class="hljs-type">int</span>&gt;&amp; D)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">//key:a+b的数值，value:a+b数值出现的次数</span><br>        <span class="hljs-comment">//之所以不使用三个数相加再和一个数匹配，是因为O(n^2)和O(n^3)是不一样的复杂度</span><br>        <span class="hljs-comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                umap[a + b]++; <br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计a+b+c+d = 0 出现的次数</span><br>        <span class="hljs-comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D) &#123;<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span> - (c + d)) != umap.<span class="hljs-built_in">end</span>()) &#123;<br>                    count += umap[<span class="hljs-number">0</span> - (c + d)];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6.三数之和"></a>6.三数之和</h2><p><img src="/images/image-20221024083843214.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>之所以把这道题放在这里不是因为它可以使用哈希法解决，而是它恰好不能使用哈希法（因为三元组不能重复所以细节处理很耗费时间）；</p>
<p>这道题使用双指针解法如下，首先我们需要将数组排序（双指针法一定需要排序），借助一层for循环，定义了left和right两个指针，left初始化为i+1，right初始化为数组末尾，将三个数转换为nums[i]、nums[left]以及nums[right]；</p>
<p>移动left指针和right指针的规则如下：</p>
<ul>
<li>如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些；</li>
<li>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时三数之和小了，left 就向右移动，才能让三数之和大一些；</li>
<li>如果找到结果，则将三元组存储后同时收缩left和right指针，转移到下一层for循环；</li>
<li>如果没有找到结果，直到left与right相遇，转移到下一层for循环；</li>
</ul>
<p>基本思想并不难，需要注意的是题干要求不能有重复的三元组，那么还需要考虑去重，也就是nums[i]、nums[left]以及nums[right] —— 注意是三元组不能相同，但是三元组中的元素可以重复；</p>
<p>很多人可能一来的想法是直接得到所有符合的三元组之后，依次比较每一个三元组的元素进行三元组去重，这种方法就属于是最低效的，我们应该考虑在构造三元组的时候就进行去重；</p>
<p>首先是对nums[i]的去重，因为nums[i]是依次移动的，从数组下标0位置移动到末尾（注意我们的数组是经过排序的），因此只需要比较nums[i]和它前面一个数nums[i-1]是否相同，如果相同则直接跳过（注意千万不能和nums[i]后面的数nums[i+1]比较，比如三元组[-1,-1,2]这种情况就会被遗漏）</p>
</blockquote>
<p><img src="/images/image-20221024084403342.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b和c去重，因为数组是经过排序的所以直接移动left和right指针即可，即寻找第一个符合条件的元素</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<span class="hljs-comment">//之所以nums[left]和nums[i]的去重逻辑不同，需要仔细体会，举例来说，对于[-1,-1,-1,2]，其中nums[i]是第一个-1，nums[left]是第二个-1，第三个-1会因为left去重直接被pass</span><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="7-四数之和"><a href="#7-四数之和" class="headerlink" title="7.四数之和"></a>7.四数之和</h2><p><img src="/images/image-20221024091954193.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>这道题同样不能使用哈希表，因为和三数求和一样需要去重，这道题的解法也是使用双指针，只是多套用了一层for循环（为什么不能使用三指针呢？因为三指针不便于管理，还不如for循环）；</p>
<p>需要注意以下细节：</p>
<ul>
<li>判断第一个数大于target值直接return的逻辑需要严格限制，因为这里的target并不是指定的0，将<code>nums[k] &gt; target</code>变为<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>；</li>
<li>三数求和的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0；四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^)；（同理我们可以类推五数求和、六数求和…实际上三数求和就是将暴力O(n^3^)降为O(n^2^)同理…）</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++) &#123;<br>            <span class="hljs-comment">// 剪枝处理</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="hljs-number">0</span>) &#123;<br>            	<span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break，统一通过最后的return返回，其实这里使用return result也没问题，但是尽量和2级剪枝处理保持一致</span><br>            &#125;<br>            <span class="hljs-comment">// 对nums[k]去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-comment">// 2级剪枝处理</span><br>                <span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">if</span> (i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;<br>                        right--;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                        right--;<br>                        left++;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="8-赎金信"><a href="#8-赎金信" class="headerlink" title="8.赎金信"></a>8.赎金信</h2><p><img src="/images/image-20221024133706273.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p><code>杂志字符串中的每个字符只能在赎金信字符串中使用一次，且我们假设两个字符串只有小写字符</code></p>
</blockquote>
<p>这道题使用暴力解法（双层for循环）也是非常容易想到的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 时间复杂度: O(n^2)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; magazine.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ransomNote.<span class="hljs-built_in">length</span>(); j++) &#123;<br>                <span class="hljs-comment">// 在ransomNote中找到和magazine相同的字符</span><br>                <span class="hljs-keyword">if</span> (magazine[i] == ransomNote[j]) &#123;<br>                    ransomNote.<span class="hljs-built_in">erase</span>(ransomNote.<span class="hljs-built_in">begin</span>() + j); <span class="hljs-comment">// ransomNote删除这个字符</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果ransomNote为空，则说明magazine的字符可以组成ransomNote</span><br>        <span class="hljs-keyword">if</span> (ransomNote.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当然也可以使用哈希表，采取空间换取时间的策略，用长度为26的数组记录magazine中字母出现的次数，接着使用ransomNote验证</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 时间复杂度: O(n)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//假如赎金信中的字符串长度都大于杂志字符串了，那么必然是不可能组成的（其实这个条件也可以加在上面暴力for循环之前）</span><br>        <span class="hljs-keyword">if</span> (ransomNote.<span class="hljs-built_in">size</span>() &gt; magazine.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//其实这个题目给我们最大的启发就是如何记录并匹配数组中的字符，record数组中0表示小写字母a，数组内容就是该小写字母出现的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; magazine.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-comment">// 通过recode数据记录 magazine里各个字符出现次数</span><br>            record[magazine[i]-<span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ransomNote.<span class="hljs-built_in">length</span>(); j++) &#123;<br>            <span class="hljs-comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span><br>            record[ransomNote[j]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span><br>            <span class="hljs-keyword">if</span>(record[ransomNote[j]-<span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h2><blockquote>
<p>首先我要说一下，哈希表在整个数据结构课程中其实是没有单独作为一个基本的数据结构介绍的，因为它实际上是作为一种“查找思想”，使得我们不需要挨个比较值是否相等来查找某个数值；</p>
<p>在我们解题的过程中只需要记住可以使用数组、set以及map这三种基本数据结构都可以实现哈希法即可，不要手动去写一个哈希表的数据结构（这当然是可行的，这就需要我们选择散列函数、处理冲突…本末倒置了属于是）；</p>
</blockquote>
<p>我们知道有如下常见的三种哈希结构：</p>
<ul>
<li>数组</li>
<li>set</li>
<li>map</li>
</ul>
<p>数组是最简单的哈希表，但是数组的大小是受限的，当题干明显给出暗示如小写字母(仅有26个)则直接选择数组，注意可以选择数组和map的时候一定要选择数组，因为map的消耗在实际数据量很大的时候是远远超过数组的；</p>
<p>当题干没有限制数组大小的时候就不能使用数组作为哈希表，此时就可以选择set(set还可以避免数据重复)；</p>
<p>选择数组和set作为哈希表有如下限制：</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，但哈希值太大会造成内存空间的浪费；</li>
<li>set只能存储单个值，当面临需要存储某个元素的两个值的时候set是不能满足的；</li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><p>在字符串相关的题目中，因为C&#x2F;C++对字符串的特性，所以有很多针对字符串的库函数，注意选择的原则就是“库函数仅仅是解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数”；（如果不太明白这个库函数就最好不要使用，否则分析时间复杂度的时候真的会一脸懵）</p>
<h2 id="1-反转字符串1"><a href="#1-反转字符串1" class="headerlink" title="1.反转字符串1"></a>1.反转字符串1</h2><p><img src="/images/image-20221025080323989.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>这个题实际上大一的时候做过一次，用的是最简单的for循环以及一个额外的result数组，however，此处要求必须原地修改数组，因此我们选择和<code>反转链表</code>类似的双指针方法；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--) &#123;<br>            <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-反转字符串2"><a href="#2-反转字符串2" class="headerlink" title="2.反转字符串2"></a>2.反转字符串2</h2><p><img src="/images/image-20221025081610292.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>与简单的字符串反转不同，这里是花式反转；</p>
<p>这道题乍一看需要分三种情况，实际只需要分两种情况：</p>
<ol>
<li>剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</li>
<li>剩余字符少于 k 个，则将剩余字符全部反转</li>
</ol>
<p>还有一点需要注意的是，不要一来就搞个计数器计数2k以及前k个字符，这道题关键点在于<code>“以固定规律分段处理字符串”</code>，这也就意味着我们可以在for循环上考虑优化，每次for循环都在2k的起点即可；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + i + k );<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">end</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.替换空格</h2><p><img src="/images/image-20221025083006669.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>这道题最容易想到的思路就是for循环，比较每个字符，如果是空格则替换，乍一看时间复杂度为O(n)可以接受；</p>
<p>However，注意题干是将空格字符替换为”%20”字符串，这意味着每次替换空格都需要将其后面的字符向后移动两个字符，如果只是使用简单的替换方法会导致非常大的时间开销；</p>
<p>假如需要将这道题的时间缩短到极致，就需要利用双指针；</p>
<p>这里我们先给出一个解题原则 —— <code>大多数数组填充的问题，都可以预先给数组扩容为填充后的大小，然后再从后向前填充以减少原有字符的移动次数</code></p>
</blockquote>
<p><img src="/images/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计空格的个数</span><br>        <span class="hljs-type">int</span> sOldSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> sNewSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 从后先前将空格替换为&quot;%20&quot;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sNewSize - <span class="hljs-number">1</span>, j = sOldSize - <span class="hljs-number">1</span>; j &lt; i; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[i] = s[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//直接替换连续三个元素，并移动指针i向前两个元素位置</span><br>                s[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4-反转字符串中的单词"><a href="#4-反转字符串中的单词" class="headerlink" title="4.反转字符串中的单词"></a>4.反转字符串中的单词</h2><p><img src="/images/image-20221025085634938.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>这题当然可以直接以空格或字符串尾部分隔每个单词（注意这里默认符号属于前一个单词，但是如果是”hello,world”这种字符串就会被认为是同一个单词…），然后使用新的string字符串或char数组将分隔的单词倒序相加；</p>
<p>假如我们增加限制，要求空间复杂度为O(1)，也就是只能在原有字符串进行反转；</p>
<p>解题主要步骤如下：</p>
<ol>
<li>移除多余空格；</li>
<li>将整个字符串反转；</li>
<li>分别将每个单词反转；</li>
</ol>
<p>在移除空格的过程中，如果我们使用简单的earse会导致时间复杂度实际是O(n^2^)（因为数组元素是不能被删除的，earse的底层原理实际仍然是覆盖元素），所以采用双指针的方法来移除空格最后resize整个字符串的大小就可以达到O(n)的复杂度；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//移除空格函数，关于这个函数如何构造的可以参考数组章节的移除元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>, fastIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义快指针，慢指针</span><br>    <span class="hljs-comment">// 去掉字符串前面的空格</span><br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; fastIndex &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        fastIndex++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; fastIndex &lt; s.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>        <span class="hljs-comment">// 去掉字符串中间部分的冗余空格</span><br>        <span class="hljs-keyword">if</span> (fastIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[fastIndex - <span class="hljs-number">1</span>] == s[fastIndex] &amp;&amp; s[fastIndex] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            s[slowIndex++] = s[fastIndex];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (slowIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[slowIndex - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 去掉字符串末尾的空格</span><br>        s.<span class="hljs-built_in">resize</span>(slowIndex - <span class="hljs-number">1</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        s.<span class="hljs-built_in">resize</span>(slowIndex); <span class="hljs-comment">// 重新设置字符串大小</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//手动实现reverse函数</span><br><span class="hljs-comment">// 反转字符串s中左闭右闭的区间[start, end]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//反转函数</span><br><span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s); <span class="hljs-comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//翻转，注意是左闭右闭 []的翻转。</span><br>                start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//更新下一个单词的开始下标start</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-左旋转字符串"><a href="#5-左旋转字符串" class="headerlink" title="5.左旋转字符串"></a>5.左旋转字符串</h2><p><img src="/images/image-20221026075852285.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>这道题究竟是否涉及数组的扩容？肯定最简单的方式就是截取前n个字符然后移动后面的所有字符，再在末尾加上n个字符，但是这种方法需要的时间成本太高了；</p>
<p>这里我们加限制，不能使用额外的空间，只能在本串上操作；</p>
<p>前面反转字符串中的单词说过，使用整体反转+局部反转可以实现反转单词顺序的目的（这里我们将字符串看作整体，将需要旋转的n个字符看作局部），步骤为：</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<p>举例来说，abcdefg，先反转ab得到bacdefg，再反转cdefg得到bagfedc，最后反转整个字符串得到cdefgab</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n);<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6-实现strStr"><a href="#6-实现strStr" class="headerlink" title="6.实现strStr()"></a>6.实现strStr()</h2><p><img src="/images/image-20221026080947260.png" srcset="/img/loading.gif" lazyload></p>
<p>这道题是KMP的经典题目，所以需要我们掌握KMP算法；</p>
<p>KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配；</p>
<p>strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串</p>
<ul>
<li>如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；</li>
<li>否则，返回NULL；</li>
</ul>
<p>具体实现参考<a target="_blank" rel="noopener" href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录 (programmercarl.com)</a></p>
<h2 id="7-重复子串"><a href="#7-重复子串" class="headerlink" title="7.重复子串"></a>7.重复子串</h2><p><img src="/images/image-20221026091200284.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>暴力解法就是一个for循环获取子串的终止位置（之所以只使用一个for循环而不是两个for循环是因为只需要判断<code>以第一个字母开始的子串</code>即可（第一个不匹配那么就不可能重复组成主串），同时根本不需要for循环结束，因为子串结束的位置大于主串中间位置则一定不能重复组成字符串），然后判断子串是否能重复构成字符串，这将嵌套一个for循环，一共是O(n^2^)的时间复杂度；</p>
<p>我们这里主要讲解移动匹配解法；</p>
<p>一个主串如果是由重复子串组成，则将两个主串拼接在一起中间一定还会出现一个主串，比如”abcabcabc”拼接在一起得到”abcabcabcabcabcabc”我们能在中间找到新出现的主串；</p>
<p>因此判断字符串s是否有重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，要刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string t = s + s;<br>        t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">begin</span>()); t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 掐头去尾</span><br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">find</span>(s) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 当然使用库函数的时间复杂度为O(m+n)，相较于暴力解法的O(m*n)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里我们衍生一下，前面说到的KMP也可以用于这道题，KMP主要用于在一个串中查找是否出现过另一个串，这里我们主要使用的是KMP算法概念中的前缀表，并不涉及KMP算法查找；</p>
<p>在由重复子串构成的字符串中，最长相等前后缀不包含的子串就是组成字符串的最小重复子串，比如下面的例子，ab就是最小重复单位</p>
<p><img src="/images/image-20221026100302538.png" srcset="/img/loading.gif" lazyload></p>
<p>假设某字符串s(其长度也是s)是由n个最小重复子串x(其长度也是x)构成，也就是s&#x3D;n * x；字符串s的最长相同前后缀的长度为(n-1) * x；</p>
<p>我们可以得出如下结论：前缀表的长度（实际就是字符串s的长度）减去最长相同前后缀的长度等于最小重复单位的长度，如果这个长度可以被整除代表该字符串由最小重复单位重复n次组成；</p>
<p>这里举个例子，字符串”asdfasdfasdf”长度为12，其最长相同前后缀为”asdfasdf”长度为8，因此最小重复单位”asdf”的长度为4，4可以被12整除说明字符串由最小重复单位组成；</p>
<blockquote>
<p>这个解题方法很新颖，将字符串匹配的问题转换为数学问题，主要利用了KMP算法的前后缀概念；</p>
</blockquote>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>字符串类型的题目往往想法简单但是实现并不容易，其中双指针是常用策略，而KMP算法是字符串查找的最重要的算法；</p>
<p>前面使用过很多次的双指针算法，双指针并不隶属于某种特定的数据结构（当然也并不是严格意义上的指针，可以是数组下标），双指针主要有以下的作用：</p>
<ul>
<li>通过两个指针在一个for循环下完成两个for循环的工作；</li>
</ul>
<p>双指针主要有快慢指针、前后指针；</p>
<h1 id="五、栈和队列"><a href="#五、栈和队列" class="headerlink" title="五、栈和队列"></a>五、栈和队列</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><p>队列是先进先出，栈是先进后出；</p>
<p>栈和队列是STL中的数据结构，而STL有多个版本，我们这里介绍和使用的STL都是SGI STL中的数据结构；</p>
<blockquote>
<p>栈</p>
</blockquote>
<p>栈提供push和pop等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)，不像是set或者map提供迭代器iterator来遍历所有元素；</p>
<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能），这也意味着STL中栈常常并不被归类为容器，而是被归类为容器适配器；</p>
<p>STL中栈的底层实现可以是vector、list或deque，主要是链表和数组；</p>
<p><img src="/images/image-20221028090742290.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>队列</p>
</blockquote>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，与栈相同，SGI STL中队列一样是以deque为缺省情况下的底部结构；</p>
<p>STL中的结构同样不被归类为容器，而被认为是容器适配器；</p>
<h2 id="1-栈实现队列"><a href="#1-栈实现队列" class="headerlink" title="1.栈实现队列"></a>1.栈实现队列</h2><p><img src="/images/image-20221028091020338.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>实际这道题的意思就是利用STL提供的栈来实现一个队列的数据结构和相关操作（模拟队列的行为），只用一个栈是无法实现的，需要一个输入栈，一个数输出栈：</p>
<ul>
<li>模拟队列的push只需要将数据放入输入栈即可；</li>
<li>模拟队列的pop需要进行判断：<ul>
<li>输出栈为空则将输入栈中的元素全部导入，再将栈中的数据全部弹出；</li>
<li>输出栈不为空则直接将栈中的元素弹出；</li>
<li>如果输入栈和输出栈都是空则说明模拟的队列空；</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/images/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stIn.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span><br>        <span class="hljs-keyword">if</span> (stOut.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 从stIn导入数据直到stIn为空</span><br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>()) &#123;<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());<br>                stIn.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 直接使用已有的pop函数</span><br>        stOut.<span class="hljs-built_in">push</span>(res); <span class="hljs-comment">// 因为pop函数弹出了元素res，所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-队列实现栈"><a href="#2-队列实现栈" class="headerlink" title="2.队列实现栈"></a>2.队列实现栈</h2><p><img src="/images/image-20221028092455299.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>依旧需要使用两个队列来模拟栈，但注意这两个队列的关系并不是输入和输出，另一个队列用于备份；</p>
<p>两个队列que1和que2实现队列的功能，que2其实就是一个备份的作用：</p>
<ul>
<li>模拟实现pop操作，把除que1最后的元素都备份到que2，然后弹出最后的元素，再把其他元素从que2导回que1（如此往复，尽管很复杂）；</li>
<li>模拟实现push操作，直接将元素存入que1即可；</li>
</ul>
</blockquote>
<p><img src="/images/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que1;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que2; <span class="hljs-comment">// 辅助队列，用来备份</span><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = que1.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-keyword">while</span> (size--) &#123; <span class="hljs-comment">// 将que1 导入que2，但要留下最后一个元素</span><br>            que2.<span class="hljs-built_in">push</span>(que1.<span class="hljs-built_in">front</span>());<br>            que1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-type">int</span> result = que1.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 留下的最后一个元素就是要返回的值</span><br>        que1.<span class="hljs-built_in">pop</span>();<br>        que1 = que2;            <span class="hljs-comment">// 再将que2赋值给que1</span><br>        <span class="hljs-keyword">while</span> (!que2.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 清空que2</span><br>            que2.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que1.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当然这个题使用一个队列也可以实现</p>
<p>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-keyword">while</span> (size--) &#123; <span class="hljs-comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span><br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> result = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时弹出的元素顺序就是栈的顺序了</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3-有效括号"><a href="#3-有效括号" class="headerlink" title="3.有效括号"></a>3.有效括号</h2><p><img src="/images/image-20221031080143896.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p><code>括号匹配是使用栈解决的经典问题</code>，实际上编译器在词法分析的过程中处理括号、花括号这些符号逻辑的时候使用的也是栈数据结构；</p>
<p>由于栈的特殊性质，非常适合做对称匹配的题目，括号<code>不匹配</code>有如下三种情况：</p>
<ul>
<li>字符串左边括号多余 —— 对应指针遍历完字符串但栈不为空；</li>
<li>括号不多于但括号类型不匹配 —— 对应指针遍历字符串的过程中指针和栈的字符不匹配；</li>
<li>字符串右边括号多余 —— 对应指针遍历字符串的过程中栈已经空；</li>
</ul>
<p>匹配成功的情况是指针遍历完字符串且栈为空；</p>
</blockquote>
<p>使用栈解决括号匹配问题（小技巧：“左括号入栈改为右括号入栈，则只需要比较当前栈顶符号是否和输入符号一致即可”）</p>
<p><img src="/images/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果s的长度为奇数，一定不符合要求</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; st;  <span class="hljs-comment">// 借助STL提供的stack栈结构</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span><br>            <span class="hljs-comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// st.top() 与 s[i]相等，栈弹出元素</span><br>        &#125;<br>        <span class="hljs-comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span><br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4-删除字符串相邻重复项"><a href="#4-删除字符串相邻重复项" class="headerlink" title="4.删除字符串相邻重复项"></a>4.删除字符串相邻重复项</h2><p><img src="/images/image-20221031081400111.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>实际解读这道题很容易想到这也需要使用栈来解决，上一题使用栈解决左右括号匹配，本题使用栈匹配相邻元素</p>
</blockquote>
<p>使用栈解决相邻字符匹配（最终只需要将栈中的字符弹出并做一个反转即可）</p>
<p><img src="/images/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> s : S) &#123;<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">empty</span>() || result.<span class="hljs-built_in">back</span>() != s) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5.逆波兰表达式求值"></a>5.逆波兰表达式求值</h2><p><img src="/images/image-20221031082047473.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>逆波兰表达式相当于二叉树中的后序遍历，当然解题完全没必要从二叉树的角度进行；</p>
<p>逆波兰表达式的每一个子表达式要得出一个结果并用该结果做运算，本质上就是相邻字符串消除过程：指针遍历字符串的时候，遇到数字则入栈，遇到算符则取出栈顶两个数字并将计算结果压入栈中；</p>
</blockquote>
<p><img src="/images/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 + num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 * num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoll</span>(tokens[i]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 把栈里最后一个元素弹出（其实不弹出也没事，此时栈中只剩下这最后一个元素了）</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6-滑动窗口最大值"><a href="#6-滑动窗口最大值" class="headerlink" title="6.滑动窗口最大值"></a>6.滑动窗口最大值</h2><p><img src="/images/image-20221031084403974.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>本题是使用单调队列的经典题目（单调队列是指队列中元素之间的关系具有单调性，单调队列的典型题目是滑动窗口，我们下面会详细介绍什么是单调队列，注意和优先级队列区别）</p>
<p>本题的核心是求解每个区间中的最大值，最简单的暴力法就是遍历的过程中每次都从窗口中找到最大的数值，时间复杂度为O(n*k)；</p>
<p>我们需要这样一个队列：该队列中的元素就是窗口中的元素，随着窗口的移动，队列元素也随之进出，每次移动后队列会返回其中的最大值；</p>
<p><code>单调队列的定义</code>：</p>
<ul>
<li>不维护窗口中的所有元素，只维护可能成为窗口中最大值的元素即可；</li>
<li>保证单调队列中的元素数值是从大到小的；</li>
<li>单调队列配合窗口移动：<ul>
<li>pop(value)：如果窗口滑动导致将要移除的元素value等于单调队列的出口元素，那么队列pop队首元素，否则不用任何操作；</li>
<li>push(value)：如果push的元素value大于入口元素的数值，那么就将队首元素pop，直到push元素的数值小于等于队列入口元素的数值，再进行push进队尾；</li>
</ul>
</li>
</ul>
</blockquote>
<p>单调队列配合窗口进行滑动：</p>
<ul>
<li><p>第一个窗口(1,3,-1)：</p>
<ul>
<li><p>空队列，push 1；</p>
</li>
<li><p>因为3&gt;1，故pop 1再push 3；</p>
</li>
<li><p>因为-1&lt;3，故直接push -1；</p>
</li>
</ul>
</li>
<li><p>第二个窗口(3,-1,-3)：</p>
<ul>
<li>因为窗口滑动将要移除1，于是不需要做任何操作；</li>
<li>因为-3&lt;3，故直接push -3；</li>
</ul>
</li>
<li><p>第三个窗口(-3,5,3)；</p>
<ul>
<li>因为窗口滑动将要移除3，故pop3并滑动窗口，此时队首元素为-1；</li>
<li>因为5&gt;-1，故pop -1；</li>
<li>因为5&gt;-3，故pop -1并push 5；</li>
</ul>
</li>
</ul>
<p>…</p>
<p><img src="/images/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" srcset="/img/loading.gif" lazyload></p>
<p>使用deque作为底层容器实现单调队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>    <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>    <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>            que.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br>    <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>            que.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        que.<span class="hljs-built_in">push_back</span>(value);<br><br>    &#125;<br>    <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>使用单调队列实现滑动窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br>    <span class="hljs-keyword">public</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>        <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>        <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>                que.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br>        <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            que.<span class="hljs-built_in">push_back</span>(value);<br><br>        &#125;<br>        <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>        &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        MyQueue que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 先将前k的元素放进队列</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// result 记录前k的元素的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            que.<span class="hljs-built_in">pop</span>(nums[i - k]); <span class="hljs-comment">// 滑动窗口移除最前面元素</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">// 滑动窗口前加入最后面的元素</span><br>            result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 记录对应的最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>单调队列并不是一成不变的，针对不同的应用其pop和push接口也不同，唯一不变的就是要保证队列中单调递减或递增的原则</p>
</blockquote>
<h2 id="7-前k个高频元素"><a href="#7-前k个高频元素" class="headerlink" title="7.前k个高频元素"></a>7.前k个高频元素</h2><p><img src="/images/image-20221031092002690.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>实际上本题由三个模块组成：</p>
<ol>
<li>统计元素出现的频率 —— 使用map统计；</li>
<li>对频率进行排序 —— 使用优先级队列（本质上是一个堆，算法动画图解中直接认为堆就是在实现优先级队列时使用）；</li>
<li>找出前k个高频元素；</li>
</ol>
<p>之所以使用堆排序而不是快速排序，是因为快排需要将map转换为vector结构；</p>
<p>本题使用小顶堆，要统计前k个最大元素，小顶堆只需要每次将最小的元素弹出，最后小顶堆中积累的就是前k个最大的元素；</p>
</blockquote>
<p>寻找前k个最大频率元素的流程如下</p>
<p><img src="/images/347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.jpg" srcset="/img/loading.gif" lazyload></p>
<p>C++代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 时间复杂度：O(nlogk)</span><br><span class="hljs-comment">// 空间复杂度：O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> &#123;  <span class="hljs-comment">//这个比较运算用于建堆时使用，注意左大于右建立小顶堆，右大于左建立大顶堆</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 统计元素出现频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// map&lt;nums[i],对应出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k，可以直接使用priority实现</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了k，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找出前k个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><h2 id="0-二叉树概述"><a href="#0-二叉树概述" class="headerlink" title="0.二叉树概述"></a>0.二叉树概述</h2><blockquote>
<p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
</blockquote>
<p>满二叉树的深度为k，有2^k^-1个节点；</p>
<blockquote>
<p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p>
</blockquote>
<p>若完全二叉树最底层为第h层，则该层包含1~ 2^(h-1)^个节点；</p>
<p><img src="/images/image-20221031132117562.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>二叉搜索树：又被称为二叉排序树，二叉搜索树是一个有数值的树，二叉搜索树是一个有序树</p>
<ul>
<li><p>它的左、右子树也分别为二叉排序树；</p>
</li>
<li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
</li>
<li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
</li>
</ul>
</blockquote>
<p><img src="/images/image-20221031132454844.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉搜索树。</p>
</blockquote>
<p><img src="/images/image-20221031132622958.png" srcset="/img/loading.gif" lazyload></p>
<p>C++中的map、set等容器的底层实现都是<code>平衡二叉搜索树</code>，实际上红黑树就是一种平衡二叉搜索树，红黑树和平衡二叉搜索树不是独立的，具体信息可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/TABE_/article/details/116160330">(4条消息) 红黑树和AVL树_TABE_的博客-CSDN博客_avl和红黑树区别</a></p>
<blockquote>
<p>二叉树的遍历方式</p>
</blockquote>
<p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先：先往深层次遍历，遇到叶子节点再往回遍历</li>
<li>广度优先：一层一层的遍历</li>
</ol>
<p>从深度优先和广度优先进一步拓展才有以下遍历方式：</p>
<ul>
<li>深度优先遍历（这里的前中后实际上就是指中间节点的遍历顺序）<ul>
<li>前序遍历（递归法，迭代法）：中左右</li>
<li>中序遍历（递归法，迭代法）：左中右</li>
<li>后序遍历（递归法，迭代法）：左右中</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<h2 id="1-二叉树的递归遍历"><a href="#1-二叉树的递归遍历" class="headerlink" title="1.二叉树的递归遍历"></a>1.二叉树的递归遍历</h2><p>递归算法的三要素：</p>
<ol>
<li>确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型；</li>
<li>确定终止条件：写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出；</li>
<li>确定单层递归的逻辑：确定每一层递归需要处理的信息，在这里也就会重复调用自己来实现递归的过程；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-comment">//1.确定递归函数的参数和返回值：参数就是传入的需要遍历的结点指针和vec结果数组，不需要返回任何值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-comment">//2.确定终止条件：当前遍历的结果是空</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//3.确定单层递归的逻辑：前序遍历的逻辑是中、左、右</span><br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>	&#125;<br>    <br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>	&#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-二叉树的迭代遍历"><a href="#2-二叉树的迭代遍历" class="headerlink" title="2.二叉树的迭代遍历"></a>2.二叉树的迭代遍历</h2><p>递归的实现就是每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，之后递归返回的时候从栈顶弹出上一次递归的各项参数，这也是递归可以返回上一层位置的原因；</p>
<p>下面我们要将递归法修改为迭代法（即非递归的方式）来实现二叉树的遍历；</p>
<blockquote>
<p>前序遍历</p>
</blockquote>
<p>这里需要借助栈实现递归向迭代的转换（之后的层次遍历会使用队列来实现，这都是因为栈和队列不同的特点所决定的），前序遍历每次先处理的都是中间节点，因此入栈的顺序是根节点、右孩子、左孩子，这样出栈的时候就是中左右的顺序</p>
<p><img src="/images/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//栈用来处理节点上的元素（即将节点的数值放入result数组中）</span><br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//node指针用来帮助访问节点，访问节点和处理节点同时进行</span><br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">关于上面的逻辑，可能直观上不是很好理解（我甚至都不知道怎么想出来这个逻辑的...），我们这里直接拿数据做一个演示；</span><br><span class="hljs-comment">首先将root 5放入stack中，同时令结点指针指向stack的顶端（也就是root 5）；接着直接stack pop弹出栈顶元素 5，将node指向的值5存入result；然后将6和4依次存入stack中；</span><br><span class="hljs-comment">第二个while循环，node指针指向stack的顶端也就是节点 4；接着直接stack pop后将node指向的值4存入result；然后将2和1依次存入stack中；</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>中序遍历</p>
</blockquote>
<p>前序遍历相对来说较简单，因为要访问的节点和要处理的节点的顺序一致，都是中间节点；</p>
<p>而中序遍历先访问二叉树的顶部节点，然后层层深入直到左子树的最下，再开始处理节点（处理节点意思就是将节点中的数值放入result数组中），这就造成处理顺序和访问顺序是不一致的；</p>
<p><img src="/images/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//访问节点和处理节点分开进行</span><br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123;                  <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); 				   <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;               <br>            &#125; <br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); 			   <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <br>                cur = cur-&gt;right;              <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">同样还是举例说明，首先cur指针指向root 5，此时进入while循环；</span><br><span class="hljs-comment">因为cur不为NULL，所以将cur存入stack中并将cur指向其左孩子；</span><br><span class="hljs-comment">接着进入第二轮while循环，此时将cur 4存入satck并令cur指向其左孩子；</span><br><span class="hljs-comment">进入第三轮循环stack中为5，4，1，且cur为NULL;</span><br><span class="hljs-comment">进入第四轮循环，开始进入else分支，cur指向1，result存入1；</span><br><span class="hljs-comment">进入第五轮循环，进入else分支，cur指向4，reault存入4；</span><br><span class="hljs-comment">进入第六轮循环，进入else分支，cur指向5，result存入5，cur重新赋值为2...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>后序遍历</p>
</blockquote>
<p>后序遍历的实现相对简单，只需要将前序遍历的中左右变为中右左，接着反转result数组就能得到左右中的遍历结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left); <span class="hljs-comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 空节点不入栈</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将结果反转之后就是左右中的顺序了</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>统一迭代</p>
</blockquote>
<p>实际上前中后遍历的迭代代码是可以统一为一样的风格的（了解即可），之所以之前不一样是因为没有解决遍历节点和处理节点不一致的情况，解决方法是将访问的节点放入栈中，将要处理的节点也放入栈中但需要做上标记；</p>
<p>标记的方法就是将要处理的节点放入栈后，紧跟着放入一个空指针作为标记；这样只有空节点弹出的时候，才将下一个节点放进结果集（也就是只有先出现空节点的时候，才对下一个节点进行处理）</p>
<p><img src="/images/008eGmZEly1gnbmq3btubg30em09ue82.gif" srcset="/img/loading.gif" lazyload></p>
<p>迭代法中序遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                    st.<span class="hljs-built_in">pop</span>();                      		<span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中（要是不弹出就会出现中右中左的情况）</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.<span class="hljs-built_in">push</span>(node-&gt;right);               <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); 						  <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点作为标记。</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.<span class="hljs-built_in">push</span>(node-&gt;left);    		   <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                &#125;    <br>            &#125; <br>            <span class="hljs-keyword">else</span> &#123; 									<span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           				  <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();   				      <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); 	       <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3-二叉树的层序遍历"><a href="#3-二叉树的层序遍历" class="headerlink" title="3.二叉树的层序遍历"></a>3.二叉树的层序遍历</h2><p><img src="/images/image-20221101084138512.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>层序遍历指的是从左到右，从上到下遍历二叉树，需要借助一个辅助队列来实现，因为队列先进先出的特点符合从上到下、从左到右逐层遍历的逻辑；</p>
<p>实际上这种层序遍历的方式就是图论中的广度优先遍历；</p>
</blockquote>
<p><img src="/images/008eGmZEly1gnad5itmk8g30iw0cqe83.gif" srcset="/img/loading.gif" lazyload></p>
<p>下面这份代码作为二叉树层序遍历的基本模板，有必要好好理解(实际上使用递归也可以实现，并且不需要借助队列数据结构，但是递归的代码的确过于难以理解，故不推荐)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;      <span class="hljs-comment">//result数组作为结果数组，简单来说外层容器result的元素类型为vector&lt;int&gt;，内层容器的元素类型为int；之所以这样设计是因为内层容器代表二叉树的每一层；</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">同样地，我们结合上面的动画和这里的代码一起解释；</span><br><span class="hljs-comment">首先将root 6存入queue中，接着进入while循环，对size赋值为1；进入for循环，令node指针指向queue队首，接着弹出队首元素并将队首元素加入vec容器，接着依次加入左孩子和右孩子4，7进入队列；</span><br><span class="hljs-comment">当一层的节点全部存入vec中后（对应for循环遍历结束），将vec存入result数组；进入下一轮的while训话；</span><br><span class="hljs-comment">此时队首元素为4，size赋值为2，进入for循环后，存入4并依次加入左孩子和右孩子1，3；</span><br><span class="hljs-comment">同理，第二个for循环队首元素为7，存入7并依次加入左孩子和右孩子5，8...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h2 id="4-翻转二叉树"><a href="#4-翻转二叉树" class="headerlink" title="4.翻转二叉树"></a>4.翻转二叉树</h2><p><img src="/images/image-20221101091941672.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>这道题解题思想很简单，只需要将每个节点的左右孩子翻转即可，即可达到整体翻转的效果；</p>
<p>但是关键在于遍历顺序(这是所有二叉树问题的重中之重)，不能使用中序遍历（这将导致某些节点的左右孩子被翻转两次）；</p>
</blockquote>
<ul>
<li>前序遍历递归翻转二叉树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//1.确定递归函数的参数和返回值</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//2.确定终止条件</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//3.确定单层递归的逻辑</span><br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>前序遍历迭代翻转二叉树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>层序遍历迭代翻转二叉树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 节点处理</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="5-对称二叉树"><a href="#5-对称二叉树" class="headerlink" title="5.对称二叉树"></a>5.对称二叉树</h2><p><img src="/images/image-20221102081408865.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>判断二叉树是否对称，要比较的不是左右节点，而是根节点的左子树和右子树是否是相互翻转的，即比较的是两个树，因此在递归遍历的过程中要同时遍历两棵子树；</p>
<p>接着比较两个子树的内侧和外侧元素是否相等；</p>
</blockquote>
<blockquote>
<p>递归解法</p>
</blockquote>
<p>本题的遍历顺序只能是后序遍历，即“左右中”，因为要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等 —— 实际上一棵树的遍历顺序是“左右中”，另一棵树的遍历顺序是“右左中”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//1.确定递归函数的参数和返回值，参数就是左子树和右子树（更准确来说是树的节点），返回值是bool类型的值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-comment">//2.确定终止条件</span><br>        <span class="hljs-comment">//2.1 首先排除空节点的情况（否则后面比较数值的时候会操作空指针，是很危险的事）</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       <span class="hljs-comment">//2.1.1 左节点空，右节点不为空</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//2.1.2 左节点不为空，右节点为空</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//2.1.3 左右都为空</span><br>        <span class="hljs-comment">//2.2 排除了空节点，再排除数值不相同的情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//2.2.1 左右节点不为空，但左右节点的数值不同</span><br>	    <span class="hljs-comment">//3.确定单层递归的逻辑，单层递归的逻辑就是处理左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 比较二叉树外侧是否对称，传入左子树的左孩子、右子树的右子树</span><br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 比较二叉树内侧是否对称，传入左子树的右孩子、右子树的左孩子左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 如果内外侧都对称则返回ture，只要有一侧不对称就返回false</span><br>        <span class="hljs-keyword">return</span> isSame;									 <span class="hljs-comment">//如上代码可以看出来，左子树的遍历方式是左右中，右子树的遍历方式是右左中</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>迭代解法</p>
</blockquote>
<p>本题的迭代解法既可以使用队列也可以使用栈，大致的意思参考下面的动画</p>
<p><img src="/images/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">//continue是指直接进入下层循环，不执行下面的代码</span><br>            &#125;<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6.二叉树的最大深度"></a>6.二叉树的最大深度</h2><p><img src="/images/image-20221103080455839.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>递归解法</p>
</blockquote>
<p>这道题使用前序遍历可以求得深度，使用后序遍历求的是高度，深度和高度的区别是什么？</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li>
</ul>
<p><img src="/images/image-20221103081325092.png" srcset="/img/loading.gif" lazyload></p>
<p>因此根节点的高度就是二叉树的最大深度，因此本题选用后序遍历求根节点的高度进而得到二叉树的最大深度（实际上使用前序遍历才是真正的求深度的逻辑，但此处因为根节点的高度就是二叉树的最大深度，所以可以直接后序遍历求根节点的高度）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//1.确定递归函数的参数和返回值，参数是树的根节点，返回值是int型树的深度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(treenode* node)</span> </span>&#123;<br>        <span class="hljs-comment">//2.确定终止条件，若节点为空则返回0表示高度为0</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//3.确定单层递归的逻辑，先求得左子树的深度，再求得右子树的深度，最后取左右子树深度较大者加1即为以当前节点为根节点的树的深度</span><br>        <span class="hljs-type">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);       <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);     <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth); <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>迭代解法</p>
</blockquote>
<p>迭代解法使用层序遍历是最适合的，因为二叉树的层数就是其最大深度，实际上这道题直接使用层序遍历模板即可求解		</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;treenode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                treenode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="7-n叉树的最大深度"><a href="#7-n叉树的最大深度" class="headerlink" title="7.n叉树的最大深度"></a>7.n叉树的最大深度</h2><p><img src="/images/image-20221103082925293.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>在介绍了二叉树的最大深度之后，可以直接利用类似的思路</p>
</blockquote>
<blockquote>
<p>后续递归遍历</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找到子树中深度最大的子树深度，最后加1表示当前根节点的最大深度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; root-&gt;children.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            depth = <span class="hljs-built_in">max</span> (depth, <span class="hljs-built_in">maxdepth</span>(root-&gt;children[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>层序迭代遍历</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(node* root)</span> </span>&#123;<br>        queue&lt;node*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//同理，将所有的子节点都加入队列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                    <span class="hljs-keyword">if</span> (node-&gt;children[j]) que.<span class="hljs-built_in">push</span>(node-&gt;children[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="8-二叉树的最小深度"><a href="#8-二叉树的最小深度" class="headerlink" title="8.二叉树的最小深度"></a>8.二叉树的最小深度</h2><p><img src="/images/image-20221103083928080.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>后序递归遍历</p>
</blockquote>
<p>需要注意的是最小深度很容易理解出错，最小深度指的是根节点到最近叶子节点的最短路径上的节点数量，因此不能将根节点本身算进去（叶子节点指的是左右孩子都为空的节点）；</p>
<p><img src="/images/image-20221103084117926.png" srcset="/img/loading.gif" lazyload></p>
<p>为了解决上述问题，需要利用以下逻辑：</p>
<ul>
<li><p>左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；</p>
</li>
<li><p>右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；</p>
</li>
<li><p>如果左右子树都不为空，返回左右子树深度最小值 + 1 ；</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//1.确定函数的参数和返回值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-comment">//2.终止条件为遇到空节点返回0表示当前节点的高度为0</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//3.确定单层逻辑</span><br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;left);           <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;right);         <span class="hljs-comment">// 右</span><br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        int leftDepth = getDepth(node-&gt;left);</span><br><span class="hljs-comment">	    int rightDepth = getDepth(node-&gt;right);</span><br><span class="hljs-comment">	    int result = 1 + min(leftDepth, rightDepth);</span><br><span class="hljs-comment">		return result;</span><br><span class="hljs-comment">		可能很多人会直接套用最大深度的公式，那么就会导致之前所说的根节点会将到达自己的深度算成最小深度</span><br><span class="hljs-comment">		*/</span><br>        <span class="hljs-comment">//3.1 当一个左子树为空，右不为空</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">NULL</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth;<br>        &#125;   <br>        <span class="hljs-comment">//3.2 当一个右子树为空，左不为空</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth;<br>        &#125;<br>        <span class="hljs-comment">//3.3 如果左右子树都不为空，返回左右子树深度最小值 + 1</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>层序递归遍历</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录最小深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>                    <span class="hljs-keyword">return</span> depth;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="9-完全二叉树的节点个数"><a href="#9-完全二叉树的节点个数" class="headerlink" title="9.完全二叉树的节点个数"></a>9.完全二叉树的节点个数</h2><p><img src="/images/image-20221104083906681.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若完全二叉树最底层为第h层，则该层包含1~ 2^(h-1)^个节点；</p>
<p>额…我们看输入和输出的时候很容易产生这样一个疑问，我不是只需要获取root数组的元素个数就知道节点个数了吗，关键真的好像是这样？？？实际考察的是我们对完全二叉树性质的掌握（类中的某个函数是不能获取构造函数的参数的），当然不熟悉直接使用普通二叉树的遍历方法也可以做出来，我们下面会介绍这两种解法；</p>
</blockquote>
<blockquote>
<p>普通二叉树的后序递归解法：</p>
</blockquote>
<p>只需要修改模板加入treeNum变量记录节点数量即可，时间复杂度为O(n)，空间复杂度为O(logn)-递归栈会占用空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNodesNum</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftNum = <span class="hljs-built_in">getNodesNum</span>(cur-&gt;left);      <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightNum = <span class="hljs-built_in">getNodesNum</span>(cur-&gt;right);    <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">int</span> treeNum = leftNum + rightNum + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> treeNum;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNodesNum</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>普通二叉树的层序迭代解法：</p>
</blockquote>
<p>同理，层序遍历模板不变，增加统计节点数量即可，时间复杂度和空间复杂度均为O(n)；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                result++;   <span class="hljs-comment">// 记录节点数量</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>完全二叉树性质：完全二叉树分为两种情况，当它为满二叉树的时候直接使用2^深度-1得到节点数；当它最后一层的叶子节点不满时，可以分别递归左孩子和右孩子，递归到一定深度就可以发现左孩子或右孩子为满二叉树，同理使用计算公式计算；</p>
</blockquote>
<p><img src="/images/image-20221104090318414.png" srcset="/img/loading.gif" lazyload></p>
<p>关键在于如何判断左子树或者右子树是否是一个满二叉树呢？</p>
<p>在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明该完全二叉树是一棵满二叉树；</p>
<p><img src="/images/image-20221104090519638.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//1.传入参数以及确定返回值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//2.确定终止条件</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>        <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>            left = left-&gt;left;<br>            leftDepth++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>            right = right-&gt;right;<br>            rightDepth++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 这里就是满二叉树的节点数量计算方式(2^深度-1)</span><br>        &#125;<br>        <span class="hljs-comment">//3.确定单层递归逻辑（实际就是后序遍历）</span><br>		<span class="hljs-type">int</span> leftTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;left);       <span class="hljs-comment">// 左</span><br>		<span class="hljs-type">int</span> rightTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;right);     <span class="hljs-comment">// 右</span><br> 		<span class="hljs-type">int</span> result = leftTreeNum + rightTreeNum + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 中</span><br>         <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="10-平衡二叉树"><a href="#10-平衡二叉树" class="headerlink" title="10.平衡二叉树"></a>10.平衡二叉树</h2><p><img src="/images/image-20221111080347612.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>解析</p>
<p>需要先强调一下之前的概念：</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数 —— 求深度需要从上至下，使用前序遍历(有一种等价情况是，根节点的高度就是该二叉树的最大深度)；</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数 —— 求高度需要从下至上，使用后序遍历；</li>
</ul>
<p>该定义来自Wiki，但实际上不同的地方有不同的规定，leecode上规定以节点为度，同时不同的地方对根节点的深度究竟是1还是0的定义也各不相同；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1.明确函数参数(当前节点)和返回值(当前参数节点为根的树的高度)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-comment">//2.终止条件是遇到空节点，返回值为0，表示当前节点为根节点的树的高度为0</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//3.单层递归逻辑：判断当前传入节点为根节点二叉树是否为平衡，依据是其左子树和右子树高度之差不超过1</span><br>    <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// -1标记该二叉树不平衡</span><br>    <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>    <span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>    <span class="hljs-comment">// 如果左右子树的差值小于等于1，则返回当前平衡二叉树的高度，否则返回-1</span><br>    <span class="hljs-comment">// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外一个想法是能否像使用层序遍历求深度一样来求高度呢？这是不行的，也是求解高度和深度的区别之一；</p>
<p>在一定条件下迭代是可以转换成递归的，但是本题使用迭代的效率非常低而且代码体系也更加复杂，所以这里我们就不再赘述迭代法；</p>
<h2 id="11-二叉树的所有路径"><a href="#11-二叉树的所有路径" class="headerlink" title="11.二叉树的所有路径"></a>11.二叉树的所有路径</h2><p><img src="/images/image-20221111082430656.png" srcset="/img/loading.gif" lazyload></p>
<p>本题需要明确的两个点是需要使用前序遍历(方便父节点指向子节点)和回溯(方便回退并选择另一条路径)，还需要注意的是回溯法就是递归，没有人会去用迭代实现回溯(回溯是复杂递归，拆分为迭代的复杂程度极其大)</p>
<p><img src="/images/image-20221111083019705.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//1.递归函数的参数(根节点、记录路径的path、保存结果的result)和返回值(不需要返回值，设置为void)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">// 前序遍历的中间节点处理，因为最后一个节点也要加入到path中，如果写在终止条件后面就加不上最后的叶子节点了</span><br>        <span class="hljs-comment">//2.确定终止条件，本题不能直接使用cur==NULL来判断，因为cur==NULL表明此时已经超过叶子节点了，但是我们还需要处理叶子节点，所以需要换一种处理方式</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//此节点是叶子节点</span><br>            <span class="hljs-comment">//终止处理的逻辑</span><br>            string sPath;<span class="hljs-comment">//先使用vector的path记录路径，接着将path转换为string类型，最后将这个string类型的path放入vector中，之所以一开始使用vector的path而不是直接用string是因为vector回溯非常方便：vector类型的path，不管每次路径收集的数字是几位数，总之一定是int，所以就一次 pop_back就可以；反之string类型的path进行回溯需要调用对应位数的次数的回溯pop</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//2.1 将path中的路径转换为string</span><br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            &#125;<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]); <span class="hljs-comment">//2.2 加入最后一个节点(最后一个节点单独处理)</span><br>            result.<span class="hljs-built_in">push_back</span>(sPath);				 <span class="hljs-comment">//2.3 将该string类型的path存入结果集result中</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//3.确定单层递归逻辑，递归和回溯的过程，因为终止条件并没有判断cur是否为NULL，所以这里需要额外判断一下</span><br>        <span class="hljs-comment">//递归和回溯是一一对应的，有一个递归就需要有一个回溯，要么同时在花括号内，要么同时在花括号外</span><br>        <span class="hljs-comment">//回溯的作用是使得path不能一直加入节点，还需要删除节点</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) &#123; <span class="hljs-comment">// 左 </span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<span class="hljs-comment">// 递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<span class="hljs-comment">// 递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traversal</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="七、回溯算法"><a href="#七、回溯算法" class="headerlink" title="七、回溯算法"></a>七、回溯算法</h1><h2 id="0-回溯法概述"><a href="#0-回溯法概述" class="headerlink" title="0.回溯法概述"></a>0.回溯法概述</h2><p>回溯是递归的副产品，只要有递归就会有回溯，所以我们所说的回溯函数就是递归函数；</p>
<p>回溯法的本质是穷举所有的可能选出我们想要的答案，所以回溯法尽管很难理解但实际上效率并不是很高；</p>
<p>但是有些问题还真的就只能使用暴力穷举能做，我们能够对回溯法做的优化最多就是加一些剪枝的处理，回溯法一般用于解决如下类型的问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<blockquote>
<p>结论：回溯法解决的问题都可以抽象为树形结构(N叉树)，所有回溯法的问题都是如此没有例外(现在知道为什么先介绍树再介绍回溯了吧)</p>
</blockquote>
<p>因为回溯法解决的问题抽象出来都是在集合中递归的查找子集，因此集合的大小构成了树的宽度，递归的深度构成了树的深度；</p>
<hr>
<p>回溯法的三个步骤：</p>
<ul>
<li>确定回溯函数的参数和返回值<ul>
<li>回溯法的返回值一般是void；</li>
<li>回溯法的参数不像普通递归那么容易确定，一般是先写逻辑，需要什么参数写什么参数；</li>
</ul>
</li>
<li>确定回溯函数的终止条件<ul>
<li>回溯解决的问题是树形结构，一般而言树的终止条件就是搜索到叶子节点中，对回溯来说就是找到了满足条件的一条答案，将该答案保存并结束本层递归即可；</li>
</ul>
</li>
<li>单层回溯搜索</li>
</ul>
<p><img src="/images/image-20221111092432505.png" srcset="/img/loading.gif" lazyload></p>
<p>现在可以解释为什么集合大小就是树的宽度了，因为集合大小等于节点的孩子的数量，回溯函数遍历过程的伪代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次；</p>
</li>
<li><p>backtracking这里自己调用自己，实现递归；</p>
</li>
</ul>
<p>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索到的叶子节点就是找到的其中一个结果；</p>
<p>整个回溯算法的模板算法如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="八、贪心算法"><a href="#八、贪心算法" class="headerlink" title="八、贪心算法"></a>八、贪心算法</h1><h1 id="九、动态规划"><a href="#九、动态规划" class="headerlink" title="九、动态规划"></a>九、动态规划</h1><h2 id="0-动态规划概述"><a href="#0-动态规划概述" class="headerlink" title="0.动态规划概述"></a>0.动态规划概述</h2><p>动态规划Dyanmic Programming，简称DP，针对具有很多重叠子问题的问题来说很适合使用动态规划；</p>
<p>动态规划中的每一个状态一定是由上一个状态推导出来的，区别于直接从局部选最优的贪心算法；</p>
<p>需要注意的是分治法和动态规划都要求原问题具有最优子结构（可以认为动态规划也是一种分治思想），都是将原问题分治接着合并子问题的解形成原问题的解，分治法通常使用递归求解，动态规划可以使用自底向上的迭代或自顶向下的递归，不同点在于分治法将子问题看作独立的而动态规划将子问题看作相互依赖的、有重叠部分的；（分治法是万精油，动态规划可以求解全局最优并避免重复的计算，但是在使用上有一定限制(无后效性)）</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%9A%E8%AF%86%E8%AF%BE%E7%A8%8B/" class="category-chain-item">通识课程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%88%B7%E9%A2%98/">#刷题</a>
      
        <a href="/tags/%E8%80%83%E7%A0%94/">#考研</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法刷题</div>
      <div>https://gintoki-jpg.github.io/2022/06/27/其他_算法刷题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>杨再俨</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/27/%E5%B7%A5%E5%85%B7_pyside2/" title="Pyside2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Pyside2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/27/%E9%80%9A%E8%AF%86_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理">
                        <span class="hidden-mobile">计算机组成原理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  

</div>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>







  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
