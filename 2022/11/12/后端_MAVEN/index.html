

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/logo.png">
  <link rel="icon" href="/img/bg/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="杨再俨">
  <meta name="keywords" content="">
  
    <meta name="description" content="Maven 是 Apache 下的一个纯 Java 开发的开源项目，它是一个基于项目对象模型（POM）的项目管理和理解工具。">
<meta property="og:type" content="article">
<meta property="og:title" content="Maven">
<meta property="og:url" content="https://gintoki-jpg.github.io/2022/11/12/%E5%90%8E%E7%AB%AF_MAVEN/index.html">
<meta property="og:site_name" content="Tintoki_blog">
<meta property="og:description" content="Maven 是 Apache 下的一个纯 Java 开发的开源项目，它是一个基于项目对象模型（POM）的项目管理和理解工具。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gintoki-jpg.github.io/img/bg/JAVA.png">
<meta property="article:published_time" content="2022-11-12T08:15:00.000Z">
<meta property="article:modified_time" content="2022-11-14T06:13:11.254Z">
<meta property="article:author" content="YangZaiyan">
<meta property="article:tag" content="后端开发">
<meta property="article:tag" content="JAVA架构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gintoki-jpg.github.io/img/bg/JAVA.png">
  
  
  
  <title>Maven - Tintoki_blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gintoki-jpg.github.io","root":"/","version":"1.9.1","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tintoki_blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Maven</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-12 16:15" pubdate>
          2022年11月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          176 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Maven</h1>
            
            <div class="markdown-body">
              
              <p>文章参考<a target="_blank" rel="noopener" href="http://c.biancheng.net/Maven2/">Maven教程 (biancheng.net)</a></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Maven 是使用 Java 语言编写的，因此它具有跨平台性，主要服务于基于 Java 平台的项目构建、依赖管理和项目信息管理。当然，Maven 也可被用于构建和管理其他的项目，例如 C#，Ruby，Scala 和其他语言编写的项目；</p>
<p>Maven 是现今最流行的项目管理和理解工具之一，通过它我们可以很方便地完成项目的构建，例如 Maven 只需一条命令 mvn clean install 就可以完成项目的清理、编译、运行单元测试、生成文档、打包和部署等繁琐的构建工作，为我们节约了大量宝贵的时间；</p>
<hr>
<p>好的我知道你想问什么，项目的管理和构建啥的不是直接使用IDE就可以完成？？（毕竟之前使用的不管是Pycharm还是Codeblocks或者VS都是如此），怎么JAVA还非得整的和Linux环境下的Make一样来个项目管理工具？</p>
<p>纠结其本质，我们会提出这样一个问题：Maven到底是干啥用的？(不要给我整那些虚幻的概念，最好直接上例子)</p>
<p>参考视频<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YL411t7Ak/?spm_id_from=333.337.search-card.all.click&vd_source=276d55048634a5b508b1b53a1ecd56b3">【IDEA版胎教级】都学这么久编程了你Maven是什么都不知道嘛？太丢人了吧？_哔哩哔哩_bilibili</a></p>
<hr>
<p>目前无论使用IDEA还是Eclipse等其他IDE，使用里面ANT工具。ANT工具帮助我们进行编译，打包运行等工作；<br>Apache基于ANT进行了升级，研发出了全新的自动化构建工具Maven(可以说Maven现在已经逐步替代ANT了)；<br>Maven是Apache的一款开源的项目管理工具；<br>以后无论是普通javase项目还是javaee项目，我们都创建的是Maven项目(因为ANT能够做的Maven都能做)；<br>Maven使用项目对象模型（POM-Project Object Model，项目对象模型）的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导jar包、拆分项目等效果；</p>
<p>为啥咱们之后都要创建Maven项目使用Maven来管理呢？因为咱们初学的时候创建的项目都很简单，可以统称为单体结构项目，即分层项目(树结构，所有的业务逻辑都是基于这一个项目来实现的，这也是你为啥之前使用Pycharm和Codeblocks的时候没有意识到需要自己进行手动管理项目，因为你之前创建的全都是单体结构项目)；</p>
<p>However，JAVA的项目可不像之前我们开发的那些那么简单，随着用户基数的增大和项目复杂程度的提升，项目只使用单体结构会显得捉襟见肘，所以现在的JAVA项目一般使用的都是分布式架构，一旦采用分布式架构意味着项目的个数会越来越多(多个小项目组成一个大项目)，所以我们需要一个有效的管理工具来管理组织这些小项目，这个工具就是Maven</p>
<h2 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1.Maven简介"></a>1.Maven简介</h2><p>Maven 是一款基于 Java 平台的项目管理和整合工具，它将项目的开发和管理过程抽象成一个项目对象模型（POM）。开发人员只需要做一些简单的配置，Maven 就可以自动完成项目的编译、测试、打包、发布以及部署等工作；</p>
<p>Maven 是使用 Java 语言编写的，因此它和 Java 一样具有跨平台性，这意味着无论是在 Windows ，还是在 Linux 或者 Mac OS 上，都可以使用相同的命令进行操作；</p>
<p>Maven 使用标准的目录结构和默认构建生命周期，Maven 能够帮助开发者完成以下任务：</p>
<ul>
<li>构建项目</li>
<li>生成文档</li>
<li>创建报告</li>
<li>维护依赖</li>
<li>软件配置管理</li>
<li>发布</li>
<li>部署</li>
</ul>
<p>总而言之，Maven 简化并标准化了项目构建过程。它将项目的编译，生成文档，创建报告，发布，部署等任务无缝衔接，构建成一套完整的生命周期；</p>
<h3 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h3><p>Maven 的主要目标是为开发人员提供如下内容：</p>
<ul>
<li>一个可重复使用，可维护且易于理解的项目综合模型；</li>
<li>与此模型进行交互的工具和插件；</li>
</ul>
<h3 id="1-2-核心理念"><a href="#1-2-核心理念" class="headerlink" title="1.2 核心理念"></a>1.2 核心理念</h3><p>约定优于配置（Convention Over Configuration）是 Maven 最核心的设计理念之一 ，Maven对项目的目录结构、测试用例命名方式等内容都做了规定，凡是使用 Maven 管理的项目都必须遵守这些规则；</p>
<p>Maven 项目构建过程中，会自动创建默认项目结构，开发人员仅需要在相应目录结构下放置相应的文件即可；</p>
<p>下图展示了项目源代码文件，资源文件和其他配置在 Maven 项目中的默认位置</p>
<p><img src="/images/image-20221112164946949.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><p>Maven 具有以下特点：</p>
<ol>
<li>设置简单。</li>
<li>所有项目的用法一致。</li>
<li>可以管理和自动进行更新依赖。</li>
<li>庞大且不断增长的资源库。</li>
<li>可扩展，使用 Java 或脚本语言可以轻松的编写插件。</li>
<li>几乎无需额外配置，即可立即访问新功能。</li>
<li>基于模型的构建：Maven 能够将任意数量的项目构建为预定义的输出类型，例如 JAR，WAR。</li>
<li>项目信息采取集中式的元数据管理：使用与构建过程相同的元数据，Maven 能够生成一个网站（site）和一个包含完整文档的 PDF。</li>
<li>发布管理和发行发布：Maven 可以与源代码控制系统（例如 Git、SVN）集成并管理项目的发布。</li>
<li>向后兼容性：您可以轻松地将项目从旧版本的 Maven 移植到更高版本的 Maven 中。</li>
<li>并行构建：它能够分析项目依赖关系，并行构建工作，使用此功能，可以将性能提高 20%-50％。</li>
<li>更好的错误和完整性报告：Maven 使用了较为完善的错误报告机制，它提供了指向 Maven Wiki 页面的链接，您将在其中获得有关错误的完整描述。</li>
</ol>
<h1 id="二、Maven基础"><a href="#二、Maven基础" class="headerlink" title="二、Maven基础"></a>二、Maven基础</h1><h2 id="1-Maven-POM"><a href="#1-Maven-POM" class="headerlink" title="1.Maven POM"></a>1.Maven POM</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>POM（Project Object Model，项目对象模型）是 Maven 的基本组件，它是以 xml 文件的形式存放在项目的根目录下，名称为 pom.xml；</p>
<p>POM 中定义了项目的基本信息，用于描述项目如何构建、声明项目依赖等等；</p>
<p>当 Maven 执行一个任务时，它会先查找当前项目的 POM 文件，读取所需的配置信息，然后执行任务。在 POM 中可以设置如下配置：</p>
<ul>
<li>项目依赖</li>
<li>插件</li>
<li>目标</li>
<li>构建时的配置文件</li>
<li>版本 </li>
<li>开发者</li>
<li>邮件列表</li>
</ul>
<p>在创建 POM 之前，首先要确定项目的工程组（groupId）、名称（artifactId）和版本(version)，在仓库中这些属性是项目的唯一标识；</p>
<p>所有的 Maven 项目都有一个 POM 文件，所有的 POM 文件都必须有 project 元素和 3 个必填字段：groupId、artifactId 以及 version</p>
<p><img src="/images/image-20221112172041894.png" srcset="/img/loading.gif" lazyload></p>
<p>下面展示一个基本的POM文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.biancheng.www<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="1-2-Super-POM"><a href="#1-2-Super-POM" class="headerlink" title="1.2 Super POM"></a>1.2 Super POM</h3><p>无论 POM 文件中是否显示的声明，所有的 POM 均继承自一个父 POM，这个父 POM 被称为 Super POM，它包含了一些可以被继承的默认设置；</p>
<p>Maven 使用 effective pom (Super POM 的配置加上项目的配置）来执行相关任务；Super POM替开发人员在 pom.xml 中做了一些最基本的配置，当然开发人员可以根据需要重写其中的配置信息；</p>
<p>执行以下命令 ，就可以查看 Super POM 的默认配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn help:effective-pom<br></code></pre></td></tr></table></figure>

<p>注意执行这个命令的时候需要在对应根目录下存在POM文件，不然会爆红</p>
<p><img src="/images/image-20221112173244992.png" srcset="/img/loading.gif" lazyload></p>
<p>咱们现在在桌面创建一个pom.xml文件，将前面的示例复制粘贴，接着执行上述shell命令(但是这个输出实在太多了就只展示一部分)来查看其Super POM的默认配置；</p>
<p><img src="/images/image-20221112174442863.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到 effective-pom 中包含了 Maven 在执行任务时需要用到的默认目录结构、输出目录、插件、仓库和报表目录等内容</p>
<p>实际开发过程中，Maven 的 pom.xml 文件不需要手工编写，Maven 提供了大量的原型（Archetype）插件来创建项目，包括项目结构和 pom.xml，下面我们将介绍如何使用原型插件来创建Maven项目；</p>
<h2 id="2-Maven操作"><a href="#2-Maven操作" class="headerlink" title="2.Maven操作"></a>2.Maven操作</h2><p>尽管对于Maven我们现在可以说完全不懂，但是在介绍基础概念之前我认为很有必要实际操作演示一遍Maven创建、构建项目和运行的过程；</p>
<h3 id="2-1-创建Maven项目"><a href="#2-1-创建Maven项目" class="headerlink" title="2.1 创建Maven项目"></a>2.1 创建Maven项目</h3><p>Maven 提供了大量不同类型的 Archetype 模板，通过它们可以帮助用户快速的创建 Java 项目，其中最简单的模板就是 maven-archetype-quickstart，它只需要用户提供项目最基本的信息，就能生成项目的基本结构及 POM 文件；</p>
<p>下面通过 maven-archetype-quickstart 原型，创建一个基于 Maven 的 Java 项目</p>
<p>在指定根目录下的shell中输入如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn archetype:generate -DgroupId=net.biancheng.www -DartifactId=helloMaven -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false<br></code></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-DgroupId: 项目组 ID，通常为组织名或公司网址的反写。</li>
<li>-DartifactId: 项目名。</li>
<li>-DarchetypeArtifactId: 指定 ArchetypeId，maven-archetype-quickstart 用于快速创建一个简单的 Maven 项目。</li>
<li>-DinteractiveMode: 是否使用交互模式。</li>
</ul>
<p>Maven 开始进行处理，并创建一套完整的 Maven 项目目录结构</p>
<p><img src="/images/image-20221112191159391.png" srcset="/img/loading.gif" lazyload></p>
<p>在指定目录下我们可以看到成功创建了一个helloMaven项目，该项目使用一套标准的目录结构，如图所示</p>
<p><img src="/images/image-20221112191500962.png" srcset="/img/loading.gif" lazyload></p>
<p>目录及文件说明：</p>
<ul>
<li>helloMaven：项目名，包含 src 文件夹和 pom.xml。</li>
<li>src&#x2F;main&#x2F;java：用于存放项目的 Java 文件。</li>
<li>src&#x2F;main&#x2F;resources：用于存放项目资源文件。</li>
<li>src&#x2F;test&#x2F;java：用于存放所有测试 Java 文件，如 JUnit 测试类。</li>
<li>src&#x2F;test&#x2F;resources ：用于存放测试资源文件。</li>
<li>target：项目输出位置，用于存放编译后的文件。</li>
<li>pom.xml：Maven 项目核心配置文件。</li>
</ul>
<p>Maven 创建项目时，还自动生成了两个Java 文件： App.java 和 AppTest.java：</p>
<ul>
<li>App.java 位于 src&#x2F;main&#x2F;java 下；</li>
<li>AppTest.java 位于 src&#x2F;test&#x2F;java 下；</li>
</ul>
<h3 id="2-2-Maven项目的构建"><a href="#2-2-Maven项目的构建" class="headerlink" title="2.2 Maven项目的构建"></a>2.2 Maven项目的构建</h3><p>在创建好Maven项目之后，我们将对该项目进行构建和测试；</p>
<p>打开命令行窗口，跳转到 …\helloMaven 目录，执行以下 mvn 命令，对该项目进行构建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean package<br></code></pre></td></tr></table></figure>

<hr>
<p>关于构建过程中报错“不再支持源选项 5，请使用 7 或更高版本”，解决方法参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36521848/article/details/125893987">(5条消息) maven打包提示，不再支持源选项 5。请使用 7 或更高版本。_王家五哥的博客-CSDN博客_不再支持源选项5</a></p>
<hr>
<p>等待项目构建完成，我们会发现在项目的根目录下生成了一个target目录，包含了如下内容</p>
<p><img src="/images/image-20221113093609597.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Maven 命令中包含了两个命令：clean 和 package，其中 clean 负责清理 target 目录，package 负责将项目构建并打包输出为 jar 文件。</li>
<li>classes：源代码编译后存放在该目录中。</li>
<li>test-classes：测试源代码编译后并存放在该目录中。</li>
<li>surefire-reports：Maven 运行测试用例生成的测试报告存放在该目录中。</li>
<li>helloMaven-1.0-SNAPSHOT.jar：Maven 对项目进行打包生成的 jar 文件。</li>
</ul>
<p>接着进入target的class目录执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java net.biancheng.www.App<br></code></pre></td></tr></table></figure>

<p><img src="/images/image-20221113093759719.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-Maven坐标"><a href="#3-Maven坐标" class="headerlink" title="3.Maven坐标"></a>3.Maven坐标</h2><p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称为<code>构件</code>。在 Maven 世界中存在着数十万甚至数百万构件，在引入坐标概念之前，当用户需要使用某个构件时，只能去对应的网站寻找，但各个网站的风格迥异，这使得用户将大量的时间浪费在搜索和寻找上，严重地影响了研发效率。为了解决这个问题，于是 Maven 引入了 Maven 坐标的概念；</p>
<p>Maven坐标规定：世界上任何一个构件都可以使用 Maven 坐标并作为其唯一标识，Maven 坐标包括 groupId、artifactId、version、packaging 等元素，只要用户提供了正确的坐标元素，Maven 就能找到对应的构件；</p>
<p>任何一个构件都必须明确定义自己的坐标，这是 Maven 的强制要求，任何构件都不能例外。我们在开发 Maven 项目时，也需要为其定义合适的坐标，只有定义了坐标，其他项目才能引用该项目生成的构件；</p>
<p>Maven项目坐标定义如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.biancheng.www<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>helloMaven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>Maven 坐标主要由以下元素组成：</p>
<ul>
<li><p>groupId： 项目组 ID，定义当前 Maven 项目隶属的组织或公司，通常是唯一的，它的取值一般是项目所属公司或组织的网址或 URL 的反写，例如 net.biancheng.www；</p>
</li>
<li><p>artifactId： 项目 ID，通常是项目的名称；</p>
</li>
<li><p>version：版本；</p>
</li>
<li><p>packaging：项目的打包方式，默认值为 jar（只有该元素是可选的，上述三个元素都是必须定义的）；</p>
</li>
</ul>
<h2 id="4-Maven依赖"><a href="#4-Maven依赖" class="headerlink" title="4.Maven依赖"></a>4.Maven依赖</h2><p>Maven的介绍中提到，Maven是一款优秀的依赖管理工具，什么是依赖呢？</p>
<p>通俗的说，如果一个 Maven 构建所产生的构件（例如 Jar 文件）被其他项目引用，那么该构件就是其他项目的依赖；</p>
<h3 id="4-1-依赖声明"><a href="#4-1-依赖声明" class="headerlink" title="4.1 依赖声明"></a>4.1 依赖声明</h3><p>Maven 坐标是依赖的前提，所有 Maven 项目必须明确定义自己的坐标，只有这样，它们才可能成为其他项目的依赖。当一个项目的构件成为其他项目的依赖时，该项目的坐标才能体现出它的价值；</p>
<p>当 Maven 项目需要声明某一个依赖时，通常只需要在其 POM 中配置该依赖的坐标信息，Maven 会根据坐标自动将依赖下载到项目中；</p>
<p>例如，某个项目中使用 servlet-api 作为其依赖，其配置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span><br>...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>dependencies 元素可以包含一个或者多个 dependency 子元素，用以声明一个或者多个项目依赖，每个依赖都可以包含以下元素：</p>
<ul>
<li>groupId、artifactId 和 version：依赖的基本坐标元素，对于任何一个依赖来说，这三个基本坐标元素是最重要的，Maven 根据基本坐标元素才能找到需要的依赖。</li>
<li>type：依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值是 jar。</li>
<li>scope：依赖的范围。</li>
<li>optional：标记依赖是否可选。</li>
<li>exclusions：用来排除传递性依赖。</li>
</ul>
<blockquote>
<p>大部分依赖声明只包含 groupId、artifactId 和 version 三个元素，至于 scope、optional 以及 exclusions 等元素，了解即可；</p>
</blockquote>
<h3 id="4-2-获取依赖"><a href="#4-2-获取依赖" class="headerlink" title="4.2 获取依赖"></a>4.2 获取依赖</h3><p>通常情况下，绝大部分依赖的 Maven 坐标都能在 <a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/</a> 中获取，使用方法参考<a target="_blank" rel="noopener" href="http://c.biancheng.net/maven2/dependency.html">Maven依赖 (biancheng.net)</a></p>
<h3 id="4-3-依赖传递"><a href="#4-3-依赖传递" class="headerlink" title="4.3 依赖传递"></a>4.3 依赖传递</h3><p>Maven 依赖传递是 Maven 的核心机制之一，它能够一定程度上简化 Maven 的依赖配置；</p>
<p>Maven 的依赖传递机制是指：不管 Maven 项目存在多少间接依赖，POM 中都只需要定义其直接依赖，不必定义任何间接依赖，Maven 会动读取当前项目各个直接依赖的 POM，将那些必要的间接依赖以传递性依赖的形式引入到当前项目中，由此可见，Maven 的依赖传递机制能够帮助用户一定程度上简化 POM 的配置；</p>
<p>项目 A 依赖于项目 B，B 又依赖于项目 C，此时 B 是 A 的直接依赖，C 是 A 的间接依赖</p>
<p><img src="/images/image-20221114081829732.png" srcset="/img/loading.gif" lazyload></p>
<p>基于 A、B、C 三者的依赖关系，根据 Maven 的依赖传递机制，我们只需要在项目 A 的 POM 中定义其直接依赖 B，在项目 B 的 POM 中定义其直接依赖 C，Maven 会解析 A 的直接依赖 B的 POM ，将间接依赖 C 以传递性依赖的形式引入到项目 A 中；</p>
<p>通过这种依赖传递关系，可以使依赖关系树迅速增长到一个很大的量级，很有可能会出现依赖重复，依赖冲突等情况，Maven 针对这些情况提供了如下功能进行处理：</p>
<ul>
<li>依赖范围（Dependency scope）</li>
<li>依赖调节（Dependency mediation）</li>
<li>可选依赖（Optional dependencies）</li>
<li>排除依赖（Excluded dependencies）</li>
<li>依赖管理（Dependency management）</li>
</ul>
<h4 id="4-3-1-依赖范围"><a href="#4-3-1-依赖范围" class="headerlink" title="4.3.1 依赖范围"></a>4.3.1 依赖范围</h4><p>Maven 在对项目进行编译、测试和运行时，会分别使用三套不同的 classpath，Maven项目在构建的时候在不同阶段引入到相应的classpath中的依赖是不同的：</p>
<ul>
<li><p>编译时，Maven 会将与编译相关的依赖引入到编译 classpath 中；</p>
</li>
<li><p>测试时，Maven 会将与测试相关的的依赖引入到测试 classpath 中；</p>
</li>
<li><p>运行时，Maven 会将与运行相关的依赖引入到运行 classpath 中；</p>
</li>
</ul>
<blockquote>
<p>依赖范围：可以在 POM 的依赖声明使用 scope 元素来控制依赖与三种 classpath（编译 classpath、测试 classpath、运行 classpath ）之间的关系，这就是依赖范围；</p>
</blockquote>
<p>Maven有常见的6种依赖范围</p>
<p><img src="/images/image-20221114090000402.png" srcset="/img/loading.gif" lazyload></p>
<p>依赖范围与三种classpath的关系如下</p>
<p><img src="/images/image-20221114090053197.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-3-2-依赖调节"><a href="#4-3-2-依赖调节" class="headerlink" title="4.3.2 依赖调节"></a>4.3.2 依赖调节</h4><p>Maven 的依赖传递机制可以简化依赖的声明，用户只需要关心项目的直接依赖，而不必关心这些直接依赖会引入哪些间接依赖，但当一个间接依赖存在多条引入路径时，为了避免出现依赖重复的问题，Maven 通过依赖调节来确定间接依赖的引入路径；</p>
<p>依赖调节遵循以下两条原则：</p>
<ol>
<li>引入路径短者优先<ul>
<li>当一个间接依赖存在多条引入路径时，引入路径短的会被解析使用</li>
</ul>
</li>
<li>先声明者优先<ul>
<li>在引入路径长度相同的前提下，POM 文件中依赖声明的顺序决定了间接依赖会不会被解析使用，顺序靠前的优先使用</li>
</ul>
</li>
</ol>
<p>以上两条原则，优先使用第一条原则解决，第一条原则无法解决，再使用第二条原则解决；</p>
<p>具体例子可以参考<a target="_blank" rel="noopener" href="http://c.biancheng.net/maven2/dependency-delivery.html">Maven依赖传递 (biancheng.net)</a>理解；</p>
<h4 id="4-3-3-排除依赖"><a href="#4-3-3-排除依赖" class="headerlink" title="4.3.3 排除依赖"></a>4.3.3 排除依赖</h4><p>因为Maven依赖的传递性，在不考虑依赖范围等因素的情况下，Maven会根据依赖传递机制将间接依赖引入，但如果我们不希望引入间接依赖，也就是将依赖C排除，此时应该如何处理？Maven为用户提供了两种解决方式：排除依赖和可选依赖；</p>
<p>假设存在这样的依赖关系，A 依赖于 B，B 依赖于 X，B 又依赖于 Y。B 实现了两个特性，其中一个特性依赖于 X，另一个特性依赖于 Y，且两个特性是互斥的关系，用户无法同时使用两个特性，假设 A 不需要使用X特性，此时就可以在 A 中将间接依赖 X 排除；</p>
<p>排除依赖是通过在 A 中使用 exclusions 元素实现的，该元素下可以包含若干个 exclusion 子元素，用于排除若干个间接依赖；</p>
<p>关于 exclusions 元素及排除依赖说明如下：</p>
<ul>
<li>排除依赖是控制当前项目是否使用其直接依赖传递下来的间接依赖；</li>
<li>exclusions 元素下可以包含若干个 exclusion 子元素，用于排除若干个间接依赖；</li>
<li>exclusion 元素用来设置具体排除的间接依赖，该元素包含两个子元素：groupId 和 artifactId，用来确定需要排除的间接依赖的坐标信息；</li>
<li>exclusion 元素中只需要设置 groupId 和 artifactId 就可以确定需要排除的依赖，无需指定版本 version；</li>
</ul>
<h4 id="4-3-4-可选依赖"><a href="#4-3-4-可选依赖" class="headerlink" title="4.3.4 可选依赖"></a>4.3.4 可选依赖</h4><p>与上文的应用场景相同，也是 A 希望排除间接依赖 X，我们还可以在 B 中将 X 设置为可选依赖；</p>
<p>在 B 的 POM 关于 X 的依赖声明中使用 optional 元素，将其设置成可选依赖；</p>
<p>关于 optional 元素及可选依赖说明如下：</p>
<ul>
<li>可选依赖用来控制当前依赖是否向下传递成为间接依赖；</li>
<li>optional 默认值为 false，表示可以向下传递称为间接依赖；</li>
<li>若 optional 元素取值为 true，则表示当前依赖不能向下传递成为间接依赖；</li>
</ul>
<p>关于排除依赖和可选依赖的对比，排除依赖和可选依赖都能在项目中将间接依赖排除在外，但两者实现机制却完全不一样：</p>
<ul>
<li>排除依赖是控制当前项目是否使用其直接依赖传递下来的间接依赖；</li>
<li>可选依赖是控制当前项目的依赖是否向下传递(即一个是控制其是否传递，一个是控制其是否使用传递下来的依赖)；</li>
<li>可选依赖的优先级高于排除依赖；</li>
<li>若对于同一个间接依赖同时使用排除依赖和可选依赖进行设置，那么可选依赖的取值必须为 false，否则排除依赖无法生效。</li>
</ul>
<h4 id="4-3-5-依赖管理"><a href="#4-3-5-依赖管理" class="headerlink" title="4.3.5 依赖管理"></a>4.3.5 依赖管理</h4><p>子模块可以通过<code>继承</code>获得父模块中声明的全部依赖，这样虽然避免了在各个子模块 POM 中重复进行依赖声明，但也极有可能造成子模块中引入一些不必要的依赖。为此 Maven 引入了 dependencyManagement 来对依赖进行管理；</p>
<p>Maven 可以通过 dependencyManagement 元素对依赖进行管理，它具有以下 2 大特性：</p>
<ul>
<li>在该元素下声明的依赖不会实际引入到模块中，只有在 dependencies 元素下同样声明了该依赖，才会引入到模块中；</li>
<li>该元素能够约束 dependencies 下依赖的使用，即 dependencies 声明的依赖若未指定版本，则使用 dependencyManagement 中指定的版本，否则将覆盖 dependencyManagement 中的版本；</li>
</ul>
<p>在实际的开发过程中，dependencyManagement 很少会单独使用，通常它需要与 Maven 继承或依赖范围 import 配合使用才能展现它的优势；</p>
<blockquote>
<p>继承依赖管理</p>
</blockquote>
<p>由于 dependencyManagement 元素是可以被继承的，因此我们可以在父模块 POM 中使用 dependencyManagement 元素声明所有子模块的依赖，然后在各个子模块 POM 使用 dependencies 元素声明实际用到的依赖即可，这样既可以让子模块能够继承父模块的依赖配置，还能避免将不必要的依赖引入到子模块中；</p>
<p>在父模块 Root 中使用 dependencyManagement 元素声明的依赖，既不会给 Root 模块引入依赖，也不会给其子模块引入依赖，但这段配置是可以被继承的；</p>
<p>使用这种依赖管理机制似乎并不能减少太多 POM 配置，但我们仍然推荐使用这种方式，其原因主要有 2 个：</p>
<ul>
<li>在父模块中使用 dependencyManagement 声明依赖能够<code>统一项目内依赖的版本</code>，子模块无须声明版本，也就不会出现多个子模块使用同一依赖项版本不一致的情况，降低依赖冲突的几率；</li>
<li>dependencyManagement 声明的依赖不会被实际引入，子模块需要什么依赖就自己引入，增加了灵活性，<code>避免引入一些不必要的依赖</code>；</li>
</ul>
<blockquote>
<p>导入依赖管理</p>
</blockquote>
<p>import 依赖范围只能与 dependencyManagement 元素配合使用才会有效，其功能是将目标 pom.xml 中的 dependencyManagement 配置导入合并到当前 pom.xml 的 dependencyManagement 中；</p>
<p>由于 import 依赖范围的特殊性，一般都是指向打包类型为 pom 的模块，所以 type 元素的值一般为 pom；</p>
<p>若存在多个模块，它们使用的依赖版本都是一致的，则就可以定义一个使用 dependencyManagement 专门管理依赖的 POM，然后在各个模块中导入这些依赖管理配置；</p>
<h2 id="5-Maven仓库"><a href="#5-Maven仓库" class="headerlink" title="5.Maven仓库"></a>5.Maven仓库</h2><p>前面已经介绍过，在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称为构件；</p>
<p>Maven 在某个统一的位置存储所有项目的构件，这个统一的位置，我们就称之为仓库，即仓库就是存放依赖和插件的地方；</p>
<p>任何的构件都有唯一的坐标，该坐标定义了构件在仓库中的唯一存储路径，当 Maven 项目需要某些构件时，只要其 POM 文件中声明了这些构件的坐标，Maven 就会根据这些坐标找自动到仓库中找到并使用它们；</p>
<p>项目构建完成生成的构件，也可以安装或者部署到仓库中，供其他项目使用；</p>
<h3 id="5-1-仓库的分类"><a href="#5-1-仓库的分类" class="headerlink" title="5.1 仓库的分类"></a>5.1 仓库的分类</h3><p>Maven 仓库可以分为 2 个大类：</p>
<ul>
<li>本地仓库</li>
<li>远程仓库(远程仓库还可分为3个小类)：<ul>
<li><code>中央仓库</code>是由 Maven 社区提供的一种特殊的远程仓库，它包含了绝大多数流行的开源构件。在默认情况下，当本地仓库没有 Maven 所需的构件时，会首先尝试从中央仓库下载。</li>
<li><code>私服</code>是一种特殊的远程仓库，它通常设立在局域网内，用来代理所有外部的远程仓库。它的好处是可以节省带宽，比外部的远程仓库更加稳定。 </li>
<li>除了中央仓库和私服外，还有很多<code>其他公共仓库</code>，例如 JBoss Maven 库，Java.net Maven 库等等。</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20221113095515860.png" srcset="/img/loading.gif" lazyload></p>
<p>Maven 根据坐标寻找构件时，它会首先查看本地仓库，若本地仓库存在此构件，则直接使用；若本地仓库不存在此构件，Maven 就会去远程仓库查找，若发现所需的构件后，则下载到本地仓库使用。如果本地仓库和远程仓库都没有所需的构件，则 Maven 报错；</p>
<h3 id="5-2-本地仓库"><a href="#5-2-本地仓库" class="headerlink" title="5.2 本地仓库"></a>5.2 本地仓库</h3><p>Maven 本地仓库实际上就是本地计算机上的一个目录（文件夹），它会在第一次执行 Maven 命令时被创建；</p>
<p>Maven 本地仓库可以储存本地所有项目所需的构件。当 Maven 项目第一次进行构建时，会自动从远程仓库搜索依赖项，并将其下载到本地仓库中。当项目再进行构建时，会直接从本地仓库搜索依赖项并引用，而不会再次向远程仓库获取；</p>
<p>Maven 本地仓库默认地址为 C:%USER_HOME%.m2\repository，当然我们也可以重新定义本地仓库的位置，只需要修改 %MAVEN_HOME%\conf 目录下的 settings.xml 文件，通过 localRepository 元素定义另一个本地仓库地址；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:/myRepository/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>构件只有储存在本地仓库中，才能被其他的 Maven 项目使用，构件想要进入本地仓库，除了从远程仓库下载到本地仓库外，还可以使用命令 mvn install 将本地项目的输出构件安装到本地仓库中；</p>
<h3 id="5-3-中央仓库"><a href="#5-3-中央仓库" class="headerlink" title="5.3 中央仓库"></a>5.3 中央仓库</h3><p>中央仓库是由 Maven 社区提供的一种特殊的远程仓库，它包含了绝大多数流行的开源构件。在默认情况下，当本地仓库没有 Maven 所需的构件时，会首先尝试从中央仓库下载；</p>
<p>中央仓库具有如下特点：</p>
<ul>
<li>这个仓库由 Maven 社区管理</li>
<li>不需要配置</li>
<li>需要通过网络才能访问</li>
</ul>
<p>我们可以通过 Maven 社区提供的 URL：<a target="_blank" rel="noopener" href="http://search.maven.org/#browse%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%85%B6%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6%E3%80%82%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E5%8C%85%E5%90%AB%E4%BA%86%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BC%80%E6%BA%90">http://search.maven.org/#browse，浏览其中的构件。中央仓库包含了绝大多数流行的开源</a> Java 构件及其源码、作者信息和许可证信息等。一般来说，Maven 项目所依赖的构件都可以从中央仓库下载到；</p>
<p>虽然中央仓库属于远程仓库的范畴，但由于它的特殊性，一般会把它与其他远程仓库区分开，我们常说的远程仓库，一般不包括中央仓库；</p>
<h3 id="5-4-远程仓库"><a href="#5-4-远程仓库" class="headerlink" title="5.4 远程仓库"></a>5.4 远程仓库</h3><p>如果 Maven 在本地仓库和中央仓库中都找不到依赖的库文件，它就会停止构建过程并输出错误信息到控制台。为避免这种情况的发生，Maven 还提供了远程仓库的概念，它是一种由开发人员自己定制的仓库，其中包含了供其他项目使用的代码库或者构件；</p>
<hr>
<p>综上，可以总结，当通过Maven构建项目时，Maven会按照如下顺序查找依赖的构建</p>
<ol>
<li>从本地仓库查找构件，如果没有找到，跳到第 2 步，否则继续执行其他处理。</li>
<li>从中央仓库查找构件，如果没有找到，并且已经设置其他远程仓库，然后移动到第 4 步；如果找到，那么将构件下载到本地仓库中使用。</li>
<li>如果没有设置其他远程仓库，Maven 则会停止处理并抛出错误。</li>
<li>在远程仓库查找构件，如果找到，则会下载到本地仓库并使用，否则 Maven 停止处理并抛出错误。</li>
</ol>
<h2 id="6-Maven生命周期"><a href="#6-Maven生命周期" class="headerlink" title="6.Maven生命周期"></a>6.Maven生命周期</h2><p>在 Maven 出现之前，项目构建的生命周期就已经存在，开发人员每天都在对项目进行清理，编译，测试及部署，但由于没有统一的规范，不同公司甚至不同项目之间的构建的方式都不尽相同；</p>
<p>Maven 从大量项目和构建工具中学习和反思，最后总结了一套高度完美的，易扩展的生命周期。这个生命周期将项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建过程进行了抽象和统一；</p>
<h3 id="6-1-生命周期与插件"><a href="#6-1-生命周期与插件" class="headerlink" title="6.1 生命周期与插件"></a>6.1 生命周期与插件</h3><p>Maven 生命周期是抽象的，其本身不能做任何实际工作，这些实际工作（如源代码编译）都通过调用Maven插件（之后我们会介绍）中的插件目标（plugin goal）完成；</p>
<p>我们可以将 Maven 生命周期理解成一个抽象父类，将插件理解成其子类，将插件目标理解成子类中重写的方法；</p>
<p>生命周期抽象了构建的各个步骤，定义了它们的执行顺序，但却没有提供具体的实现；插件中完成了对构建过程的实现，想要完成某个构建步骤，调用插件中的一个或多个插件目标即可；</p>
<p>生命周期中的每个构建过程都可以绑定一个或多个插件目标，且 Maven 为大多数的构建步骤都绑定了默认的插件。例如，针对源代码编译的插件是 maven-compiler-plugin、针对集成测试的插件是 maven-surefire-plugin 等；</p>
<h3 id="6-2-标准生命周期"><a href="#6-2-标准生命周期" class="headerlink" title="6.2 标准生命周期"></a>6.2 标准生命周期</h3><p>Maven拥有三套标准的生命周期：</p>
<ul>
<li>clean：用于清理项目</li>
<li>default：用于构建项目</li>
<li>site：用于建立项目站点</li>
</ul>
<p>每套生命周期包含一系列的构建阶段（phase），这些阶段是有顺序的，且后面的阶段依赖于前面的阶段。用户与 Maven 最直接的交互方式就是调用这些生命周期阶段。以 clean 生命周期为例，它包含 pre-clean、clean 以及 post-clean 三个阶段：</p>
<ul>
<li>当用户调用 pre-clean 阶段时，则只有 pre-clean 阶段执行；</li>
<li>当用户调用 clean 阶段时，pre-clean 和 clean 阶段都会执行；</li>
<li>当用户调用 post-clean 阶段时，则 pre-clean、clean 以及 post-clean 三个阶段都会执行；</li>
</ul>
<p>通过将阶段名传递给 mvn 命令，就可以调用构建阶段</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn post-clean<br></code></pre></td></tr></table></figure>

<blockquote>
<p>生命周期的独立性：与构建阶段的前后依赖关系不同，三套生命周期本身是相互独立的，用户可以只调用 clean 生命周期的某个阶段，也可以只调用 default 生命周期的某个阶段，而不会对其他生命周期造成任何影响</p>
</blockquote>
<h4 id="6-2-1-clean生命周期"><a href="#6-2-1-clean生命周期" class="headerlink" title="6.2.1 clean生命周期"></a>6.2.1 clean生命周期</h4><p> clean 生命周期包括以下 3 个阶段。</p>
<ul>
<li>pre-clean（清理前）</li>
<li>clean（清理）</li>
<li>post-clean（清理后）</li>
</ul>
<p>可以通过在 clean 生命周期的各个阶段定义目标来修改这部分的操作行为；</p>
<h4 id="6-2-2-default生命周期"><a href="#6-2-2-default生命周期" class="headerlink" title="6.2.2 default生命周期"></a>6.2.2 default生命周期</h4><p>default 生命周期定义了项目真正构建时所需要的所有步骤，它是所有生命周期中最核心，最重要的部分；</p>
<p>default 生命周期包含非常多的阶段，如下所示</p>
<p><img src="/images/image-20221113102801489.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-2-3-site生命周期"><a href="#6-2-3-site生命周期" class="headerlink" title="6.2.3 site生命周期"></a>6.2.3 site生命周期</h4><p>site生命周期的目的是建立和部署项目站点，Maven 能够根据 POM 包含的信息，自动生成一个友好的站点，该站点包含一些与该项目相关的文档；</p>
<p>site 生命周期包含以下 4 个阶段：</p>
<ul>
<li>pre-site</li>
<li>site</li>
<li>post-site</li>
<li>site-deploy</li>
</ul>
<h2 id="7-Maven插件"><a href="#7-Maven插件" class="headerlink" title="7.Maven插件"></a>7.Maven插件</h2><p>Maven 实际上是一个依赖插件执行的框架，它执行的每个任务实际上都由插件完成的。Maven 的核心发布包中并不包含任何 Maven 插件，它们以独立构件的形式存在， 只有在 Maven 需要使用某个插件时，才会去仓库中下载；</p>
<p>如下表所示，Maven 提供了如下 2 种类型的插件</p>
<p><img src="/images/image-20221113103238995.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="7-1-插件目标"><a href="#7-1-插件目标" class="headerlink" title="7.1 插件目标"></a>7.1 插件目标</h3><p>对于 Maven 插件而言，为了提高代码的复用性，通常一个 Maven 插件能够实现多个功能，每一个功能都是一个<code>插件目标</code>，即 Maven 插件是插件目标的集合。我们可以把插件理解为一个类，而插件目标是类中的方法，调用插件目标就能实现对应的功能；</p>
<hr>
<p>插件目标的通用写法如下</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">插件名</span>]:<span class="hljs-link">[插件目标名]</span><br></code></pre></td></tr></table></figure>

<p>例如，maven-compiler-plugin 插件的 compile 目标的通用写法如下</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">maven-compiler-plugin:<span class="hljs-keyword">compile</span><br></code></pre></td></tr></table></figure>

<hr>
<p>使用Maven命令<code>执行插件目标</code>，语法如下</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">mvn <span class="hljs-comment">[插件名]</span>:<span class="hljs-comment">[目标名]</span><br></code></pre></td></tr></table></figure>

<p>例如，调用 maven-compiler-plugin 插件的 compile 目标，命令如下</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mvn</span> compiler:compile<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="7-2-插件绑定"><a href="#7-2-插件绑定" class="headerlink" title="7.2 插件绑定"></a>7.2 插件绑定</h3><p>为了完成某个具体的构建任务，Maven 生命周期的阶段需要和 Maven 插件的目标相互绑定。例如，代码编译任务对应了default 生命周期的 compile 阶段，而 maven-compiler-plugin 插件的 compile 目标能够完成这个任务，因此将它们进行绑定就能达到代码编译的目的；</p>
<h4 id="7-2-1-内置绑定"><a href="#7-2-1-内置绑定" class="headerlink" title="7.2.1 内置绑定"></a>7.2.1 内置绑定</h4><p>Maven 默认为一些核心的生命周期阶段绑定了插件目标，当用户调用这些阶段时，对应的插件目标就会自动执行相应的任务</p>
<p><img src="/images/image-20221113104145738.png" srcset="/img/loading.gif" lazyload></p>
<p>上表中，default 生命周期中只列出了绑定了插件目标的阶段，它还有很多其他的阶段，但这些阶段默认没有绑定任何插件目标，因此它们也没有任何实际的行为；</p>
<h4 id="7-2-2-自定义绑定"><a href="#7-2-2-自定义绑定" class="headerlink" title="7.2.2 自定义绑定"></a>7.2.2 自定义绑定</h4><p>除了内置绑定之外，用户也可以自己选择将某个插件目标绑定到 Maven 生命周期的某个阶段上，这种绑定方式就是自定义绑定。自定义绑定能够让 Maven 在构建过程中执行更多更丰富的任务；</p>
<p>我们常常在自定义绑定的同时通过execution元素定义一些执行配置，executions 下的每一个 executin 子元素都可以用来配置执行一个任务，execution 下各个元素含义如下：</p>
<ul>
<li>id：任务的唯一标识。</li>
<li>phase：插件目标需要绑定的生命周期阶段。</li>
<li>goals：用于指定一组插件目标，其子元素 goal 用于指定一个插件目标。</li>
<li>configuration：该任务的配置，其子元素 tasks 用于指定该插件目标执行的任务。</li>
</ul>
<blockquote>
<p>当插件目标绑定到生命周期的不同阶段时，其执行顺序由生命周期阶段的先后顺序决定。如果多个目标绑定到同一个生命周期阶段，其执行顺序与插件声明顺序一致，先声明的先执行，后声明的后执行。</p>
</blockquote>
<h3 id="7-3-插件管理"><a href="#7-3-插件管理" class="headerlink" title="7.3 插件管理"></a>7.3 插件管理</h3><p>Maven 使用 dependencyManagement 对依赖进行管理，与之类似地，Maven 中还提供了一个名为 pluginManagement 的元素，它可以帮助用户管理 Maven 插件；</p>
<p>pluginManagement 元素与 dependencyManagement 元素的原理十分相似，在 pluginManagement 元素中可以声明插件及插件配置，但不会发生实际的插件调用行为，只有在 POM 中配置了真正的 plugin 元素，且其 groupId 和 artifactId 与 pluginManagement 元素中配置的插件匹配时，pluginManagement 元素的配置才会影响到实际的插件行为；</p>
<p>使用 pluginManagement 管理插件很简单，只需要将声明插件的配置添加在 pluginManagement 元素中即可；</p>
<ul>
<li><p>当项目中的多个模块存在<code>相同的插件</code>时，应当将插件配置移动到父模块的 pluginManagement 元素中，即使各个模块对于同一插件的具体配置不尽相同，也应当在父模块中使用 pluginManagement 元素对插件版本进行统一声明；</p>
</li>
<li><p>我们甚至可以将项目中<code>所有插件的版本信息</code>都在父模块的 POM 中声明，子模块中不再配置任何的版本信息，这样不仅可以统一项目的插件版本，还可以避免出现版本冲突或插件不稳定等问题；</p>
</li>
</ul>
<h2 id="8-Maven-amp-jar包"><a href="#8-Maven-amp-jar包" class="headerlink" title="8.Maven&amp;jar包"></a>8.Maven&amp;jar包</h2><p>Maven 是通过仓库对依赖进行管理的，当 Maven 项目需要某个依赖时，只要其 POM 中声明了依赖的坐标信息，Maven 就会自动从仓库中去下载该构件使用；</p>
<p>但在实际的开发过程中，经常会遇到一种情况：某一个项目需要依赖于存储在本地的某个 jar 包，该 jar 包无法从任何仓库中下载的，这种依赖被称为<code>外部依赖</code>或<code>本地依赖</code>，那么这种依赖是如何声明的呢？</p>
<p>本节比较难，我们就不细讲了，参考<a target="_blank" rel="noopener" href="http://c.biancheng.net/maven2/import-local-jar.html">Maven导入本地jar包 (biancheng.net)</a></p>
<h2 id="9-Maven站点"><a href="#9-Maven站点" class="headerlink" title="9.Maven站点"></a>9.Maven站点</h2><p>Maven 不仅仅是一款项目构建和依赖管理工具，它还能够聚合项目信息，促进项目团队间地交流；POM 中可以包含各种项目信息，例如：项目描述、SCM 地址、许可证信息，开发者信息等；</p>
<p>用户可以使用 Maven 提供的 maven-site-plugin 插件让 Maven 生成一个 Web 站点， 以站点的形式发布以上信息；</p>
<h2 id="10-Maven原型"><a href="#10-Maven原型" class="headerlink" title="10.Maven原型"></a>10.Maven原型</h2><p>Archetype 是 Maven 项目的模板工具包，它定义了 Maven 项目的基本架构；</p>
<p>Archetype 为开发人员提供了数千种创建 Maven 项目的模板，Maven 通过这些模板可以帮助用户快速的生成项目的目录结构以及 POM 文件；</p>
<p>Maven Archetype 由下面 5 个模块组成：</p>
<ul>
<li>maven-archetype-plugin：Archetype 插件。</li>
<li>archetype-packaging：用于描述 Archetype 的生命周期与构建项目软件包。</li>
<li>archetype-models：用于描述类与引用。</li>
<li>archetype-common：核心类。</li>
<li>archetype-testing：用于测试 Maven Archetype 的内部组件。</li>
</ul>
<h3 id="10-1-maven-archetype-plugin"><a href="#10-1-maven-archetype-plugin" class="headerlink" title="10.1 maven-archetype-plugin"></a>10.1 maven-archetype-plugin</h3><p>我们知道 Maven 的所有功能都是通过插件实现的，Archetype 也不例外，它是由一个名为 maven-archetype-plugin 的插件实现的，该插件提供了 ArcheType 的所有功能；</p>
<p>虽然 ArcheType 只是一个插件，但其应用范围十分的广泛，几乎所有的主流 IDE（例如 Eclipse、NetBeans 和 IntelliJ IDEA）都在集成 Maven 时着重继承了 Archetype 特性，以方便用户快速的创建 Maven 项目；</p>
<p>为了满足用户的需求，Maven 为用户提供了大量不同类型的 Archetype 模板；</p>
<p>在执行以下命令时，Maven 会输出一个 ArcheType 列表，每个ArcheType 前面都对应一个编号，我们可以根据不同的需求选择合适的 Archetype；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn archetype:generate #帮助用户快速的创建 Maven 项目<br></code></pre></td></tr></table></figure>

<p>说到底，Archetype 只是一个模板，为了保持模板的通用性，它的很多重要的信息都是可配置的，在用户选择了 Archetype 后，还需要提供一些关于项目的基本参数，主要包括以下参数：</p>
<ul>
<li>groupId</li>
<li>artifactId</li>
<li>version</li>
<li>package</li>
</ul>
<p>在输入以上参数后，Archetype 插件就能够为用户生成项目的基本目录结构和 POM 文件；</p>
<h2 id="11-Maven快照"><a href="#11-Maven快照" class="headerlink" title="11.Maven快照"></a>11.Maven快照</h2><p>Maven 项目第一次构建时，会自动从远程仓库搜索依赖项，并将其下载到本地仓库中。当项目再进行构建时，会直接从本地仓库搜索依赖项并引用，而不会再次向远程仓库获取。这样的设计能够避免项目每次构建时都去远程仓库下载依赖，减轻了网络带宽的压力，但也带来了问题；</p>
<p>大型的应用软件通常由多个功能模块组成，这些模块一般分别于不同的团队负责开发。假设有两个团队，他们分别负责项目中的 app-ui（前端） 和 data-service（数据服务） 两个模块，且 app-ui 需要依赖 data-service 项目作为数据服务来源；</p>
<p>基于以上假设，若 data-service 团队正在进行快节奏的 bug 修复及功能增强，会在短时间内高频率地更新代码以及发布版本。就会出现以下情况：</p>
<ol>
<li>data-service 团队每次发布新版本更新代码时，都应该通知 app-ui 团队；</li>
<li>app-ui 团队则需要定期更新其 pom.xml 以获得最新的版本；</li>
</ol>
<p>这样造成的影响最显著的就是影响开发效率，要解决这个问题，可以使用快照版本：data-servcie 团队每次更新代码都使用快照版本发布到仓库中，app-ui 团队则引用快照版本的依赖，这样 app-ui 不再需要重复修改 pom.xml 中的配置，每次构建时都会自动从仓库中获取最新的构件；</p>
<blockquote>
<p>快照：一种特殊的版本，表示当前开发进度的副本，与常规版本的构件不同之处在于快照版本的构件在发布的时候Maven会自动为其打上时间戳，在之后依赖该构件的项目进行构建的时候Maven会自动从仓库中找到最新的快照版本；</p>
</blockquote>
<p>定义一个组件或模块为快照版本，只需要在其pom.xml中的version元素的值后加上-SNAPSHOT即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.biancheng.www<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>helloMaven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="11-1-SNAPSHOT-amp-RELEASE"><a href="#11-1-SNAPSHOT-amp-RELEASE" class="headerlink" title="11.1 SNAPSHOT&amp;RELEASE"></a>11.1 SNAPSHOT&amp;RELEASE</h3><p>Maven仓库分为SNAPSHOT快照仓库和RELEASE发行仓库，Snapshot 快照仓库用于保存开发过程中的不稳定 SNAPSHOT 版本，Release 发行仓库则用来保存稳定的 RELEASE 版本；</p>
<p>Maven 会根据模块的版本号（pom.xml 文件中的 version 元素）中是否带有 -SNAPSHOT 来判断是 SNAPSHOT 版本还是正式 RELEASE 版本：带有 -SNAPSHOT 是SNAPSHOT（快照）版本，不带 -SNAPSHOT 的就是正式 RELEASE（发布）版本；</p>
<p>SNAPSHOT 版本和 RELEASE 版本区别如下</p>
<p><img src="/images/image-20221114081216715.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="12-Maven继承"><a href="#12-Maven继承" class="headerlink" title="12.Maven继承"></a>12.Maven继承</h2><p>关于几个常见概念的区别，可以参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fe949c2f081a">继承、实现、依赖、关联、聚合、组合的联系与区别 - 简书 (jianshu.com)</a></p>
<hr>
<p>Maven 在设计时，借鉴了 Java 面向对象中的继承思想，提出了 POM 继承思想；</p>
<p>当一个项目包含多个模块时，可以在该项目中再创建一个父模块，并在其 POM 中声明依赖，其他模块的 POM 可通过继承父模块的 POM 来获得对相关依赖的声明。创建父模块的目的是为了消除子模块 POM 中的重复配置，其中不包含有任何实际代码，因此父模块 POM 的打包类型（packaging）必须是 pom；</p>
<p>如下项目存在多个模块以及相互之间的关系</p>
<p><img src="/images/image-20221114092838995.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>App-UI-WAR 依赖于 App-Core-lib 和 App-Data-lib；</li>
<li>Root 是 App-Core-lib 和 App-Data-lib 的父模块；</li>
<li>Root 在它的依赖部分定义了 junit 4.9、mysql-connector-java 5.1.18 以及 c3p0 0.9.1 作为其依赖；</li>
</ul>
<p>在子模块 App-Core-lib 和 App-Data-lib 的 pom.xml 中，使用 parent 元素声明父模块，parent元素的子元素如下</p>
<p><img src="/images/image-20221114093109465.png" srcset="/img/loading.gif" lazyload></p>
<p>子模块的 POM 中，当前模块的 groupId 和 version 元素可以省略，但这并不意味着当前模块没有 groupId 和 version，子模块会隐式的从父模块中继承这两个元素，即由父模块控制子模块的公司组织 id 以及版本，这样可以简化 POM 的配置；</p>
<p>下面给出Maven可以通过继承获得POM的元素</p>
<p><img src="/images/image-20221114093509300.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="13-Maven聚合"><a href="#13-Maven聚合" class="headerlink" title="13.Maven聚合"></a>13.Maven聚合</h2><p>在实际的开发过程中，我们所接触的项目一般都由多个模块组成，在构建项目时，如果每次都按模块一个一个地进行构建会十分得麻烦，Maven 的聚合功能很好的解决了这个问题；</p>
<p>使用 Maven 聚合功能对项目进行构建时，需要在该项目中额外创建一个的聚合模块，然后通过这个模块构建整个项目的所有模块。聚合模块仅仅是帮助聚合其他模块的工具，其本身并无任何实质内容，因此聚合模块中只有一个 POM 文件，不像其他的模块一样包含 src&#x2F;main&#x2F;java、src&#x2F;test&#x2F;java 等多个目录；</p>
<p>与父模块相似，聚合模块的打包方式（packaging）也是 pom，用户可以在其 POM 中通过 modules 下的 module 子元素来添加需要聚合的模块的目录路径；</p>
<p>聚合模块在构建时，Maven 会先解析聚合模块的 POM、分析需要构建的模块，并根据这些模块之间的关系计算出构建顺序，然后根据这个顺序依次构建各个模块；构建完成后输出的是一个项目构建的小结报告，该报告中包括各个模块构建成功与否、构建花费的时间、以及整个构建构成所花费的时间等信息；</p>
<hr>
<p>在实际的项目中，一个模块往往既是聚合模块又是其他项目的父模块，那么 Maven 的继承和聚合的关系是如何的呢？</p>
<p>Maven 的继承和聚合的目的不同，继承的目的是为了消除 POM 中的重复配置，聚合的目的是为了方便快速的构建项目：</p>
<ul>
<li><p>对于继承中的父模块来说，它不知道那些模块继承了它，但子模块都知道自己的父模块是谁；</p>
</li>
<li><p>对于聚合模块来说，它知道哪些模块被聚合了，但那些被聚合的模块根本不知道聚合模块的存在；</p>
</li>
</ul>
<p>两者在结构和形式上还是有一定的共同点的，最直观的就是两者的打包方式都是 pom，两者除了 POM 外都没有实际的代码内容；</p>
<h2 id="14-Maven-Profile"><a href="#14-Maven-Profile" class="headerlink" title="14.Maven Profile"></a>14.Maven Profile</h2><p>一个项目通常都会有多个不同的运行环境，例如开发环境，测试环境、生产环境等。而不同环境的构建过程很可能是不同的，例如数据源配置、插件、以及依赖的版本等。每次将项目部署到不同的环境时，都需要修改相应的配置，这样重复的工作，不仅浪费劳动力，还容易出错。为了解决这一问题，Maven 引入了 Profile 的概念，通过它可以<code>为不同的环境定制不同的构建过程</code>；</p>
<p>Profile 可以分为 3 个类型，它们的作用范围也各不相同；</p>
<p><img src="/images/image-20221114134139087.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="14-1-声明Profile"><a href="#14-1-声明Profile" class="headerlink" title="14.1 声明Profile"></a>14.1 声明Profile</h3><p>Maven 通过 profiles 元素来声明一组 Profile 配置，该元素下可以包含多个 profile 子元素，每个 profile 元素表示一个 Profile 配置。每个 profile 元素中通常都要包含一个 id 子元素，该元素是调用当前 Profile 的标识；</p>
<p>定义 Profile 的一般形式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>profile id<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        ....<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>profile id<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        ....<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>除此之外，Profile 中还可以声明一些其他的 POM 元素，但不同位置的 Profile 所能声明的 POM 元素也是不同的：</p>
<ul>
<li>在 pom.xml 中声明的 Profile，由于其能够随着 pom.xml 一起存在，它被提交到代码仓库中，被 Maven 安装到本地仓库或远程仓库中，所以它能够修改或增加很多 POM 元素；</li>
<li>在 setting.xml 中声明的 Profile 是无法保证能够随着 pom.xml 一起被分发的，因此 Maven 不允许用户在该类型的 Profile 修改或增加依赖或插件等配置信息，它只能声明以下范围较为宽泛的元素：<ul>
<li>repositories：仓库配置；</li>
<li>pluginRepositories：插件仓库配置；</li>
<li>properties：键值对，该键值对可以在 pom.xml 中使用；</li>
</ul>
</li>
</ul>
<h3 id="14-2-激活Profile"><a href="#14-2-激活Profile" class="headerlink" title="14.2 激活Profile"></a>14.2 激活Profile</h3><p>Profile 能够在项目构建时，修改 POM 中配置或者添加一些额外的配置元素，用户可以通过多种方式激活 Profile，以实现不同环境使用不同的配置，执行不同的构建过程；</p>
<p>Profile 可以通过以下 6 种方式激活：</p>
<ul>
<li>命令行激活</li>
<li>settings.xml 文件显示激活</li>
<li>系统属性激活</li>
<li>操作系统环境激活</li>
<li>文件存在与否激活</li>
<li>默认激活</li>
</ul>
<p>详细流程参考<a target="_blank" rel="noopener" href="http://c.biancheng.net/maven2/profile-tutorial.html">Maven Profile精讲 (biancheng.net)</a>，这里不再赘述；</p>
<h2 id="15-Maven镜像"><a href="#15-Maven镜像" class="headerlink" title="15.Maven镜像"></a>15.Maven镜像</h2><p>如果一个仓库 A 可以提供另一个仓库 B 的所有内容，那么就可以认为仓库 A 是仓库 B 的一个镜像，即仓库 B 中的任何一个构件都能从它的镜像中获取；</p>
<p>国内开发人员由于网络原因，直接从中央仓库下载构件时，速度较慢或不稳定，我们通常会使用中央仓库的国内镜像站来解决该问题；</p>
<p>配置 Maven 镜像的方法也非常的简单，我们只需要在 Maven 安装目录中 setting.xml 文件的 mirrors 节点中，使用 mirror 标签添加镜像的相关信息即可；</p>
<p>镜像通常会和 Maven 私服配合使用，由于 Maven 私服可以代理所有外部的公共仓库（包括中央仓库），因此对于组织内部的用户来说，使用一个私服就相当于使用了所有需要的外部仓库，这样就可以将配置集中到私服中，简化 Maven 本身的配置。这种情况下，用户所有所需的构件都可以从私服中获取，此时私服就是所有仓库的镜像；</p>
<blockquote>
<p>需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务时，Maven 也无法访问被镜像仓库，因而将无法下载构件；</p>
</blockquote>
<h2 id="16-Maven私服"><a href="#16-Maven私服" class="headerlink" title="16.Maven私服"></a>16.Maven私服</h2><p>Maven 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的远程仓库（中央仓库、其他远程公共仓库）；</p>
<p>建立了 Maven 私服后，当局域网内的用户需要某个构件时，会按照如下顺序进行请求和下载：</p>
<ol>
<li>请求本地仓库，若本地仓库不存在所需构件，则跳转到第 2 步；</li>
<li>请求 Maven 私服，将所需构件下载到本地仓库，若私服中不存在所需构件，则跳转到第 3 步；</li>
<li>请求外部的远程仓库，将所需构件下载并缓存到 Maven 私服，若外部远程仓库不存在所需构件，则 Maven 直接报错；</li>
</ol>
<p>此外，一些无法从外部仓库下载到的构件，也能从本地上传到私服供其他人使用；</p>
<p><img src="/images/image-20221114140644999.png" srcset="/img/loading.gif" lazyload></p>
<p>使用Maven私服主要有如下五个优势：</p>
<ol>
<li>节省外网带宽</li>
<li>下载速度更快</li>
<li>便于部署第三方构件</li>
<li>提高项目的稳定性，增强对项目的控制</li>
<li>降低中央仓库的负荷压力</li>
</ol>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%87%AA%E5%AD%A6%E8%AF%BE%E7%A8%8B/" class="category-chain-item">自学课程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">#后端开发</a>
      
        <a href="/tags/JAVA%E6%9E%B6%E6%9E%84/">#JAVA架构</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Maven</div>
      <div>https://gintoki-jpg.github.io/2022/11/12/后端_MAVEN/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>杨再俨</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月12日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/16/%E5%90%8E%E7%AB%AF_Nexus/" title="Nexus">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Nexus</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/08/%E9%A1%B9%E7%9B%AE_%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" title="中级项目_推荐系统">
                        <span class="hidden-mobile">中级项目_推荐系统</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  

</div>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>







  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
